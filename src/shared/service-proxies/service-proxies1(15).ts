/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.7.0 (NJsonSchema v9.13.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendPasswordResetCode(input: SendPasswordResetCodeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordInput | null | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResetPasswordOutput.fromJS(resultData200) : new ResetPasswordOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendEmailActivationLink(input: SendEmailActivationLinkInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    activateEmail(input: ActivateEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    impersonate(input: ImpersonateInput | null | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    switchToLinkedAccount(input: SwitchToLinkedAccountInput | null | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(<any>response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchToLinkedAccountOutput.fromJS(resultData200) : new SwitchToLinkedAccountOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeOrganization(input: ChangeOrganizationInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ChangeOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeOrganization(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeOrganization(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ApprovalRecordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDetails(id: string | null | undefined): Observable<GetApprovalRecordDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRecord/GetDetails?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetails(<any>response_);
                } catch (e) {
                    return <Observable<GetApprovalRecordDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetApprovalRecordDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetails(response: HttpResponseBase): Observable<GetApprovalRecordDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetApprovalRecordDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetApprovalRecordDetailDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    approvalAction(input: ApprovalActionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalRecord/ApprovalAction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApprovalAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApprovalAction(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processApprovalAction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ApprovalWorkflowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getApprovalWorkflowForEdit(id: string | null | undefined): Observable<GetApprovalWorkflowForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalWorkflow/GetApprovalWorkflowForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApprovalWorkflowForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApprovalWorkflowForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetApprovalWorkflowForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetApprovalWorkflowForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetApprovalWorkflowForEdit(response: HttpResponseBase): Observable<GetApprovalWorkflowForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetApprovalWorkflowForEditOutput.fromJS(resultData200) : new GetApprovalWorkflowForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetApprovalWorkflowForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateApprovalWorkflow(input: CreateOrUpdateApprovalWorkflowInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalWorkflow/CreateOrUpdateApprovalWorkflow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateApprovalWorkflow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateApprovalWorkflow(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateApprovalWorkflow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getApprovalWorkflows(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetApprovalWorkflowPaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalWorkflow/GetApprovalWorkflows?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApprovalWorkflows(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApprovalWorkflows(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetApprovalWorkflowPaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetApprovalWorkflowPaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetApprovalWorkflows(response: HttpResponseBase): Observable<PagedResultDtoOfGetApprovalWorkflowPaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetApprovalWorkflowPaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetApprovalWorkflowPaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetApprovalWorkflowPaginationOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteApprovalWorkflow(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ApprovalWorkflow/DeleteApprovalWorkflow?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApprovalWorkflow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApprovalWorkflow(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteApprovalWorkflow(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: Date | null | undefined, endDate: Date | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAuditLogListDto.fromJS(resultData200) : new PagedResultDtoOfAuditLogListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: Date | null | undefined, endDate: Date | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: Date | null | undefined, endDate: Date | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEntityChangeListDto.fromJS(resultData200) : new PagedResultDtoOfEntityChangeListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: Date | null | undefined, endDate: Date | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | null | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(<any>response_);
                } catch (e) {
                    return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntityPropertyChangeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityPropertyChangeDto[]>(<any>null);
    }
}

@Injectable()
export class BarcodePrintRecordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBarcodePrintRecordForEdit(id: string | null | undefined): Observable<GetBarcodePrintRecordForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BarcodePrintRecord/GetBarcodePrintRecordForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBarcodePrintRecordForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBarcodePrintRecordForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBarcodePrintRecordForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBarcodePrintRecordForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBarcodePrintRecordForEdit(response: HttpResponseBase): Observable<GetBarcodePrintRecordForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBarcodePrintRecordForEditOutput.fromJS(resultData200) : new GetBarcodePrintRecordForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBarcodePrintRecordForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateBarcodePrintRecord(input: CreateOrUpdateBarcodePrintRecordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BarcodePrintRecord/CreateOrUpdateBarcodePrintRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateBarcodePrintRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateBarcodePrintRecord(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateBarcodePrintRecord(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createBarcodePrintRecords(input: CreateBarcodePrintRecordsInput | null | undefined): Observable<CreateBarcodePrintRecordsOutput> {
        let url_ = this.baseUrl + "/api/services/app/BarcodePrintRecord/CreateBarcodePrintRecords";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBarcodePrintRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBarcodePrintRecords(<any>response_);
                } catch (e) {
                    return <Observable<CreateBarcodePrintRecordsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateBarcodePrintRecordsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBarcodePrintRecords(response: HttpResponseBase): Observable<CreateBarcodePrintRecordsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateBarcodePrintRecordsOutput.fromJS(resultData200) : new CreateBarcodePrintRecordsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateBarcodePrintRecordsOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param instrumentId (optional) 
     * @param brandId (optional) 
     * @param organizationId (optional) 
     * @param materialTypeId (optional) 
     * @param storageLocationId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getBarcodePrintRecords(startDate: Date | null | undefined, endDate: Date | null | undefined, instrumentId: string | null | undefined, brandId: string | null | undefined, organizationId: number | null | undefined, materialTypeId: string | null | undefined, storageLocationId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetBarcodePrintRecordPaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/BarcodePrintRecord/GetBarcodePrintRecords?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (instrumentId !== undefined)
            url_ += "InstrumentId=" + encodeURIComponent("" + instrumentId) + "&"; 
        if (brandId !== undefined)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        if (materialTypeId !== undefined)
            url_ += "MaterialTypeId=" + encodeURIComponent("" + materialTypeId) + "&"; 
        if (storageLocationId !== undefined)
            url_ += "StorageLocationId=" + encodeURIComponent("" + storageLocationId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBarcodePrintRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBarcodePrintRecords(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetBarcodePrintRecordPaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetBarcodePrintRecordPaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBarcodePrintRecords(response: HttpResponseBase): Observable<PagedResultDtoOfGetBarcodePrintRecordPaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetBarcodePrintRecordPaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetBarcodePrintRecordPaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetBarcodePrintRecordPaginationOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteBarcodePrintRecord(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BarcodePrintRecord/DeleteBarcodePrintRecord?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBarcodePrintRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBarcodePrintRecord(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBarcodePrintRecord(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param barcode (optional) 
     * @param scanType (optional) 
     * @return Success
     */
    getBarcodeInfo(barcode: string | null | undefined, scanType: ScanType | null | undefined): Observable<GetBarcodeInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/BarcodePrintRecord/GetBarcodeInfo?";
        if (barcode !== undefined)
            url_ += "Barcode=" + encodeURIComponent("" + barcode) + "&"; 
        if (scanType !== undefined)
            url_ += "ScanType=" + encodeURIComponent("" + scanType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBarcodeInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBarcodeInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetBarcodeInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBarcodeInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBarcodeInfo(response: HttpResponseBase): Observable<GetBarcodeInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBarcodeInfoOutput.fromJS(resultData200) : new GetBarcodeInfoOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBarcodeInfoOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBarcodes(id: string | null | undefined): Observable<GetBarcodesOutput> {
        let url_ = this.baseUrl + "/api/services/app/BarcodePrintRecord/GetBarcodes?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBarcodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBarcodes(<any>response_);
                } catch (e) {
                    return <Observable<GetBarcodesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBarcodesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBarcodes(response: HttpResponseBase): Observable<GetBarcodesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBarcodesOutput.fromJS(resultData200) : new GetBarcodesOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBarcodesOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    validateBarcode(input: ValidateBarcodeInput | null | undefined): Observable<ValidateBarcodeOutput> {
        let url_ = this.baseUrl + "/api/services/app/BarcodePrintRecord/ValidateBarcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateBarcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateBarcode(<any>response_);
                } catch (e) {
                    return <Observable<ValidateBarcodeOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ValidateBarcodeOutput>><any>_observableThrow(response_);
        }));
    }

    protected processValidateBarcode(response: HttpResponseBase): Observable<ValidateBarcodeOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ValidateBarcodeOutput.fromJS(resultData200) : new ValidateBarcodeOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValidateBarcodeOutput>(<any>null);
    }

    /**
     * @param materialId (optional) 
     * @param batchNo (optional) 
     * @param expiryDate (optional) 
     * @return Success
     */
    getInventoryCodes(materialId: string | null | undefined, batchNo: string | null | undefined, expiryDate: Date | null | undefined): Observable<GetInventoryCodesOutput> {
        let url_ = this.baseUrl + "/api/services/app/BarcodePrintRecord/GetInventoryCodes?";
        if (materialId !== undefined)
            url_ += "MaterialId=" + encodeURIComponent("" + materialId) + "&"; 
        if (batchNo !== undefined)
            url_ += "BatchNo=" + encodeURIComponent("" + batchNo) + "&"; 
        if (expiryDate !== undefined)
            url_ += "ExpiryDate=" + encodeURIComponent(expiryDate ? "" + expiryDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInventoryCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInventoryCodes(<any>response_);
                } catch (e) {
                    return <Observable<GetInventoryCodesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetInventoryCodesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetInventoryCodes(response: HttpResponseBase): Observable<GetInventoryCodesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetInventoryCodesOutput.fromJS(resultData200) : new GetInventoryCodesOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInventoryCodesOutput>(<any>null);
    }

    /**
     * @param eventSourceId (optional) 
     * @param materialId (optional) 
     * @param batchNo (optional) 
     * @param expiryDate (optional) 
     * @return Success
     */
    getEventBarcodes(eventSourceId: string | null | undefined, materialId: string | null | undefined, batchNo: string | null | undefined, expiryDate: Date | null | undefined): Observable<GetEventBarcodesDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BarcodePrintRecord/GetEventBarcodes?";
        if (eventSourceId !== undefined)
            url_ += "EventSourceId=" + encodeURIComponent("" + eventSourceId) + "&"; 
        if (materialId !== undefined)
            url_ += "MaterialId=" + encodeURIComponent("" + materialId) + "&"; 
        if (batchNo !== undefined)
            url_ += "BatchNo=" + encodeURIComponent("" + batchNo) + "&"; 
        if (expiryDate !== undefined)
            url_ += "ExpiryDate=" + encodeURIComponent(expiryDate ? "" + expiryDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEventBarcodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEventBarcodes(<any>response_);
                } catch (e) {
                    return <Observable<GetEventBarcodesDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEventBarcodesDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEventBarcodes(response: HttpResponseBase): Observable<GetEventBarcodesDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetEventBarcodesDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEventBarcodesDto[]>(<any>null);
    }
}

@Injectable()
export class BrandServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBrandForEdit(id: string | null | undefined): Observable<GetBrandForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Brand/GetBrandForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBrandForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBrandForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrandForEdit(response: HttpResponseBase): Observable<GetBrandForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBrandForEditOutput.fromJS(resultData200) : new GetBrandForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBrandForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateBrand(input: CreateOrUpdateBrandInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Brand/CreateOrUpdateBrand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateBrand(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateBrand(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param code (optional) 
     * @param name (optional) 
     * @param shortName (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getBrands(code: string | null | undefined, name: string | null | undefined, shortName: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetBrandPaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/Brand/GetBrands?";
        if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (shortName !== undefined)
            url_ += "ShortName=" + encodeURIComponent("" + shortName) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrands(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetBrandPaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetBrandPaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrands(response: HttpResponseBase): Observable<PagedResultDtoOfGetBrandPaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetBrandPaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetBrandPaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetBrandPaginationOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getBrandList(): Observable<GetBrandListOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/Brand/GetBrandList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandList(<any>response_);
                } catch (e) {
                    return <Observable<GetBrandListOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBrandListOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrandList(response: HttpResponseBase): Observable<GetBrandListOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetBrandListOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBrandListOutput[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteBrand(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Brand/DeleteBrand?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrand(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBrand(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    handleImportFile(filePath: string | null | undefined): Observable<BrandImportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Brand/HandleImportFile?";
        if (filePath !== undefined)
            url_ += "filePath=" + encodeURIComponent("" + filePath) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHandleImportFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHandleImportFile(<any>response_);
                } catch (e) {
                    return <Observable<BrandImportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandImportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processHandleImportFile(response: HttpResponseBase): Observable<BrandImportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BrandImportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandImportDto[]>(<any>null);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfCacheDto.fromJS(resultData200) : new ListResultDtoOfCacheDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCacheDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    clearCache(input: EntityDtoOfString | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserChatFriendsWithSettingsOutput.fromJS(resultData200) : new GetUserChatFriendsWithSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserChatFriendsWithSettingsOutput>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | null | undefined, userId: number | null | undefined, minMessageId: number | null | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatMessages?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (minMessageId !== undefined)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfChatMessageDto.fromJS(resultData200) : new ListResultDtoOfChatMessageDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfChatMessageDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(input: MarkAllUnreadMessagesOfUserAsReadInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | null | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200) : new ListResultDtoOfSubscribableEditionComboboxItemDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSubscribableEditionComboboxItemDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findUsers(input: FindUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDefaultEditionNameOutput.fromJS(resultData200) : new GetDefaultEditionNameOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(<any>null);
    }
}

@Injectable()
export class DataDictionaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDataDictionaryForEdit(id: string | null | undefined): Observable<GetDataDictionaryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/DataDictionary/GetDataDictionaryForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataDictionaryForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataDictionaryForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDataDictionaryForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDataDictionaryForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataDictionaryForEdit(response: HttpResponseBase): Observable<GetDataDictionaryForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDataDictionaryForEditOutput.fromJS(resultData200) : new GetDataDictionaryForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDataDictionaryForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateDataDictionary(input: CreateOrUpdateDataDictionaryInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DataDictionary/CreateOrUpdateDataDictionary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateDataDictionary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateDataDictionary(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateDataDictionary(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param name (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getDataDictionarys(name: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGeDataDictionaryPaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/DataDictionary/GetDataDictionarys?";
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataDictionarys(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataDictionarys(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGeDataDictionaryPaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGeDataDictionaryPaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataDictionarys(response: HttpResponseBase): Observable<PagedResultDtoOfGeDataDictionaryPaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGeDataDictionaryPaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGeDataDictionaryPaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGeDataDictionaryPaginationOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteDataDictionary(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DataDictionary/DeleteDataDictionary?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDataDictionary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDataDictionary(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDataDictionary(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getDictTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DataDictionary/GetDictTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDictTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDictTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDictTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param dictTypes (optional) 
     * @return Success
     */
    getDataDictionaryValues(dictTypes: DictTypes[] | null | undefined): Observable<DataDictionaryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DataDictionary/GetDataDictionaryValues?";
        if (dictTypes !== undefined)
            dictTypes && dictTypes.forEach(item => { url_ += "DictTypes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataDictionaryValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataDictionaryValues(<any>response_);
                } catch (e) {
                    return <Observable<DataDictionaryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataDictionaryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataDictionaryValues(response: HttpResponseBase): Observable<DataDictionaryDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DataDictionaryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataDictionaryDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    sync(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DataDictionary/Sync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDate(date: Date | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDate?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDate(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDate(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: Date | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateTime?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateTime(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: Date | null | undefined, endDate: Date | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateRange?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateRange(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/GetCountries?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param selectedCountries (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(selectedCountries: NameValueOfString[] | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectedCountries);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetSelectedCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetSelectedCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string | null | undefined): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetValue?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetValue(<any>response_);
                } catch (e) {
                    return <Observable<StringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringOutput.fromJS(resultData200) : new StringOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringOutput>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfEditionListDto.fromJS(resultData200) : new ListResultDtoOfEditionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEditionListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionEditOutput.fromJS(resultData200) : new GetEditionEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateEdition(input: CreateOrUpdateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateOrUpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEdition(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | null | undefined, addAllItem: boolean | null | undefined, onlyFreeItems: boolean | null | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&"; 
        if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&"; 
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class EnumDescriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEnumDescriptionForEdit(id: string | null | undefined): Observable<GetEnumDescriptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/EnumDescription/GetEnumDescriptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnumDescriptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnumDescriptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEnumDescriptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEnumDescriptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEnumDescriptionForEdit(response: HttpResponseBase): Observable<GetEnumDescriptionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEnumDescriptionForEditOutput.fromJS(resultData200) : new GetEnumDescriptionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEnumDescriptionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateEnumDescription(input: CreateOrUpdateEnumDescriptionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EnumDescription/CreateOrUpdateEnumDescription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateEnumDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateEnumDescription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateEnumDescription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param name (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEnumDescriptions(name: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGeEnumDescriptionPaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/EnumDescription/GetEnumDescriptions?";
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnumDescriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnumDescriptions(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGeEnumDescriptionPaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGeEnumDescriptionPaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEnumDescriptions(response: HttpResponseBase): Observable<PagedResultDtoOfGeEnumDescriptionPaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGeEnumDescriptionPaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGeEnumDescriptionPaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGeEnumDescriptionPaginationOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEnumDescription(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EnumDescription/DeleteEnumDescription?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEnumDescription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEnumDescription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEnumDescription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getEnumTypes(): Observable<EnumerationInfo[]> {
        let url_ = this.baseUrl + "/api/services/app/EnumDescription/GetEnumTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnumTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnumTypes(<any>response_);
                } catch (e) {
                    return <Observable<EnumerationInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EnumerationInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEnumTypes(response: HttpResponseBase): Observable<EnumerationInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EnumerationInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EnumerationInfo[]>(<any>null);
    }

    /**
     * @return Success
     */
    sync(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EnumDescription/Sync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSync(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSync(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class FocusInfomationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param organizationId (optional) 
     * @return Success
     */
    getDashboardInfo(organizationId: number | null | undefined): Observable<GetDashboardInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/FocusInfomation/GetDashboardInfo?";
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetDashboardInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDashboardInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardInfo(response: HttpResponseBase): Observable<GetDashboardInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDashboardInfoOutput.fromJS(resultData200) : new GetDashboardInfoOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDashboardInfoOutput>(<any>null);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createFriendshipRequest(input: CreateFriendshipRequestInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(input: CreateFriendshipRequestByUserNameInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    blockUser(input: BlockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unblockUser(input: UnblockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    acceptFriendshipRequest(input: AcceptFriendshipRequestInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param incomeStatisticsDateInterval (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getDashboardStatisticsData(incomeStatisticsDateInterval: IncomeStatisticsDateInterval | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined): Observable<HostDashboardData> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetDashboardStatisticsData?";
        if (incomeStatisticsDateInterval !== undefined)
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardStatisticsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardStatisticsData(<any>response_);
                } catch (e) {
                    return <Observable<HostDashboardData>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostDashboardData>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardStatisticsData(response: HttpResponseBase): Observable<HostDashboardData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostDashboardData.fromJS(resultData200) : new HostDashboardData();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostDashboardData>(<any>null);
    }

    /**
     * @param incomeStatisticsDateInterval (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: IncomeStatisticsDateInterval2 | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval !== undefined)
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetIncomeStatisticsDataOutput.fromJS(resultData200) : new GetIncomeStatisticsDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncomeStatisticsDataOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: Date | null | undefined, endDate: Date | null | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetEditionTenantStatistics?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionTenantStatisticsOutput.fromJS(resultData200) : new GetEditionTenantStatisticsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionTenantStatisticsOutput>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostSettingsEditDto.fromJS(resultData200) : new HostSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateAllSettings(input: HostSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class InspectionItemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInspectionItemForEdit(id: string | null | undefined): Observable<GetInspectionItemForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/InspectionItem/GetInspectionItemForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInspectionItemForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInspectionItemForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetInspectionItemForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetInspectionItemForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetInspectionItemForEdit(response: HttpResponseBase): Observable<GetInspectionItemForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetInspectionItemForEditOutput.fromJS(resultData200) : new GetInspectionItemForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInspectionItemForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateInspectionItem(input: CreateOrUpdateInspectionItemInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InspectionItem/CreateOrUpdateInspectionItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateInspectionItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateInspectionItem(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateInspectionItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param code (optional) 
     * @param name (optional) 
     * @param performanceVerificationType (optional) 
     * @param minReferenceRange (optional) 
     * @param maxReferenceRange (optional) 
     * @param referenceResult (optional) 
     * @param referenceUnit (optional) 
     * @param calculationFormula (optional) 
     * @param deviation (optional) 
     * @param remark (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getInspectionItems(code: string | null | undefined, name: string | null | undefined, performanceVerificationType: PerformanceVerificationType | null | undefined, minReferenceRange: number | null | undefined, maxReferenceRange: number | null | undefined, referenceResult: string | null | undefined, referenceUnit: string | null | undefined, calculationFormula: string | null | undefined, deviation: number | null | undefined, remark: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetInspectionItemPaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/InspectionItem/GetInspectionItems?";
        if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (performanceVerificationType !== undefined)
            url_ += "PerformanceVerificationType=" + encodeURIComponent("" + performanceVerificationType) + "&"; 
        if (minReferenceRange !== undefined)
            url_ += "MinReferenceRange=" + encodeURIComponent("" + minReferenceRange) + "&"; 
        if (maxReferenceRange !== undefined)
            url_ += "MaxReferenceRange=" + encodeURIComponent("" + maxReferenceRange) + "&"; 
        if (referenceResult !== undefined)
            url_ += "ReferenceResult=" + encodeURIComponent("" + referenceResult) + "&"; 
        if (referenceUnit !== undefined)
            url_ += "ReferenceUnit=" + encodeURIComponent("" + referenceUnit) + "&"; 
        if (calculationFormula !== undefined)
            url_ += "CalculationFormula=" + encodeURIComponent("" + calculationFormula) + "&"; 
        if (deviation !== undefined)
            url_ += "Deviation=" + encodeURIComponent("" + deviation) + "&"; 
        if (remark !== undefined)
            url_ += "Remark=" + encodeURIComponent("" + remark) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInspectionItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInspectionItems(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetInspectionItemPaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetInspectionItemPaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetInspectionItems(response: HttpResponseBase): Observable<PagedResultDtoOfGetInspectionItemPaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetInspectionItemPaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetInspectionItemPaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetInspectionItemPaginationOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getInspectionItemList(): Observable<GetInspectionItemListOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/InspectionItem/GetInspectionItemList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInspectionItemList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInspectionItemList(<any>response_);
                } catch (e) {
                    return <Observable<GetInspectionItemListOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetInspectionItemListOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetInspectionItemList(response: HttpResponseBase): Observable<GetInspectionItemListOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetInspectionItemListOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInspectionItemListOutput[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteInspectionItem(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InspectionItem/DeleteInspectionItem?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInspectionItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInspectionItem(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteInspectionItem(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class InstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setup(input: InstallDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/app/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSettingsJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettingsJson(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingsJsonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppSettingsJsonDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AppSettingsJsonDto.fromJS(resultData200) : new AppSettingsJsonDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingsJsonDto>(<any>null);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/app/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDatabase(<any>response_);
                } catch (e) {
                    return <Observable<CheckDatabaseOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckDatabaseOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckDatabaseOutput.fromJS(resultData200) : new CheckDatabaseOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckDatabaseOutput>(<any>null);
    }
}

@Injectable()
export class InstrumentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInstrumentForEdit(id: string | null | undefined): Observable<GetInstrumentForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Instrument/GetInstrumentForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInstrumentForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstrumentForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetInstrumentForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetInstrumentForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetInstrumentForEdit(response: HttpResponseBase): Observable<GetInstrumentForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetInstrumentForEditOutput.fromJS(resultData200) : new GetInstrumentForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInstrumentForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateInstrument(input: CreateOrUpdateInstrumentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Instrument/CreateOrUpdateInstrument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateInstrument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateInstrument(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateInstrument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param code (optional) 
     * @param name (optional) 
     * @param organizationId (optional) 
     * @param shortName (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getInstruments(code: string | null | undefined, name: string | null | undefined, organizationId: number | null | undefined, shortName: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetInstrumentPaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/Instrument/GetInstruments?";
        if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        if (shortName !== undefined)
            url_ += "ShortName=" + encodeURIComponent("" + shortName) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInstruments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstruments(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetInstrumentPaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetInstrumentPaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetInstruments(response: HttpResponseBase): Observable<PagedResultDtoOfGetInstrumentPaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetInstrumentPaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetInstrumentPaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetInstrumentPaginationOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getInstrumentList(): Observable<GetInstrumentListOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/Instrument/GetInstrumentList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInstrumentList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstrumentList(<any>response_);
                } catch (e) {
                    return <Observable<GetInstrumentListOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetInstrumentListOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetInstrumentList(response: HttpResponseBase): Observable<GetInstrumentListOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetInstrumentListOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInstrumentListOutput[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteInstrument(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Instrument/DeleteInstrument?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInstrument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInstrument(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteInstrument(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | null | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceInfo?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceDto.fromJS(resultData200) : new InvoiceDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createInvoice(input: CreateInvoiceDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguagesOutput.fromJS(resultData200) : new GetLanguagesOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguageForEditOutput.fromJS(resultData200) : new GetLanguageForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateLanguage(input: CreateOrUpdateLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setDefaultLanguage(input: SetDefaultLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @param baseLanguageName (optional) 
     * @param targetValueFilter (optional) 
     * @param filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined, sourceName: string, baseLanguageName: string | null | undefined, targetLanguageName: string, targetValueFilter: string | null | undefined, filterText: string | null | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&"; 
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&"; 
        if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&"; 
        if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLanguageTextListDto.fromJS(resultData200) : new PagedResultDtoOfLanguageTextListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLanguageTextListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateLanguageText(input: UpdateLanguageTextInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MaterialServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaterialForEdit(id: string | null | undefined): Observable<GetMaterialForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Material/GetMaterialForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMaterialForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMaterialForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialForEdit(response: HttpResponseBase): Observable<GetMaterialForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMaterialForEditOutput.fromJS(resultData200) : new GetMaterialForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMaterialForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateMaterial(input: CreateOrUpdateMaterialInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Material/CreateOrUpdateMaterial";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateMaterial(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateMaterial(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param systemMaterialCode (optional) 
     * @param hospitalMaterialCode (optional) 
     * @param name (optional) 
     * @param shortName (optional) 
     * @param manufacturerId (optional) 
     * @param supplierId (optional) 
     * @param deliveryCompanyId (optional) 
     * @param invoicingCompanyId (optional) 
     * @param startExpiryDate (optional) 
     * @param endExpiryDate (optional) 
     * @param outInStorageType (optional) 
     * @param isPrint (optional) 
     * @param instrumentId (optional) 
     * @param brandId (optional) 
     * @param organizationId (optional) 
     * @param materialTypeId (optional) 
     * @param storageLocationId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMaterials(systemMaterialCode: string | null | undefined, hospitalMaterialCode: string | null | undefined, name: string | null | undefined, shortName: string | null | undefined, manufacturerId: string | null | undefined, supplierId: string | null | undefined, deliveryCompanyId: string | null | undefined, invoicingCompanyId: string | null | undefined, startExpiryDate: Date | null | undefined, endExpiryDate: Date | null | undefined, outInStorageType: OutInStorageType | null | undefined, isPrint: boolean | null | undefined, instrumentId: string | null | undefined, brandId: string | null | undefined, organizationId: number | null | undefined, materialTypeId: string | null | undefined, storageLocationId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetMaterialPaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/Material/GetMaterials?";
        if (systemMaterialCode !== undefined)
            url_ += "SystemMaterialCode=" + encodeURIComponent("" + systemMaterialCode) + "&"; 
        if (hospitalMaterialCode !== undefined)
            url_ += "HospitalMaterialCode=" + encodeURIComponent("" + hospitalMaterialCode) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (shortName !== undefined)
            url_ += "ShortName=" + encodeURIComponent("" + shortName) + "&"; 
        if (manufacturerId !== undefined)
            url_ += "ManufacturerId=" + encodeURIComponent("" + manufacturerId) + "&"; 
        if (supplierId !== undefined)
            url_ += "SupplierId=" + encodeURIComponent("" + supplierId) + "&"; 
        if (deliveryCompanyId !== undefined)
            url_ += "DeliveryCompanyId=" + encodeURIComponent("" + deliveryCompanyId) + "&"; 
        if (invoicingCompanyId !== undefined)
            url_ += "InvoicingCompanyId=" + encodeURIComponent("" + invoicingCompanyId) + "&"; 
        if (startExpiryDate !== undefined)
            url_ += "StartExpiryDate=" + encodeURIComponent(startExpiryDate ? "" + startExpiryDate.toJSON() : "") + "&"; 
        if (endExpiryDate !== undefined)
            url_ += "EndExpiryDate=" + encodeURIComponent(endExpiryDate ? "" + endExpiryDate.toJSON() : "") + "&"; 
        if (outInStorageType !== undefined)
            url_ += "OutInStorageType=" + encodeURIComponent("" + outInStorageType) + "&"; 
        if (isPrint !== undefined)
            url_ += "IsPrint=" + encodeURIComponent("" + isPrint) + "&"; 
        if (instrumentId !== undefined)
            url_ += "InstrumentId=" + encodeURIComponent("" + instrumentId) + "&"; 
        if (brandId !== undefined)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        if (materialTypeId !== undefined)
            url_ += "MaterialTypeId=" + encodeURIComponent("" + materialTypeId) + "&"; 
        if (storageLocationId !== undefined)
            url_ += "StorageLocationId=" + encodeURIComponent("" + storageLocationId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterials(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMaterialPaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMaterialPaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterials(response: HttpResponseBase): Observable<PagedResultDtoOfGetMaterialPaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetMaterialPaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetMaterialPaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMaterialPaginationOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteMaterial(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Material/DeleteMaterial?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMaterial(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMaterial(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    handleImportFile(filePath: string | null | undefined): Observable<MaterialImportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Material/HandleImportFile?";
        if (filePath !== undefined)
            url_ += "filePath=" + encodeURIComponent("" + filePath) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHandleImportFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHandleImportFile(<any>response_);
                } catch (e) {
                    return <Observable<MaterialImportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialImportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processHandleImportFile(response: HttpResponseBase): Observable<MaterialImportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MaterialImportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialImportDto[]>(<any>null);
    }
}

@Injectable()
export class MaterialInventoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaterialInventoryForEdit(id: string | null | undefined): Observable<GetMaterialInventoryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInventory/GetMaterialInventoryForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialInventoryForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialInventoryForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMaterialInventoryForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMaterialInventoryForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialInventoryForEdit(response: HttpResponseBase): Observable<GetMaterialInventoryForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMaterialInventoryForEditOutput.fromJS(resultData200) : new GetMaterialInventoryForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMaterialInventoryForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateMaterialInventory(input: CreateOrUpdateMaterialInventoryInput | null | undefined): Observable<CreateOrUpdateMaterialInventoryOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInventory/CreateOrUpdateMaterialInventory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateMaterialInventory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateMaterialInventory(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrUpdateMaterialInventoryOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrUpdateMaterialInventoryOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateMaterialInventory(response: HttpResponseBase): Observable<CreateOrUpdateMaterialInventoryOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateOrUpdateMaterialInventoryOutput.fromJS(resultData200) : new CreateOrUpdateMaterialInventoryOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrUpdateMaterialInventoryOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param instrumentId (optional) 
     * @param brandId (optional) 
     * @param organizationId (optional) 
     * @param materialTypeId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMaterialInventorys(startDate: Date | null | undefined, endDate: Date | null | undefined, instrumentId: string | null | undefined, brandId: string | null | undefined, organizationId: number | null | undefined, materialTypeId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetMaterialInventoryPaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInventory/GetMaterialInventorys?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (instrumentId !== undefined)
            url_ += "InstrumentId=" + encodeURIComponent("" + instrumentId) + "&"; 
        if (brandId !== undefined)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        if (materialTypeId !== undefined)
            url_ += "MaterialTypeId=" + encodeURIComponent("" + materialTypeId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialInventorys(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialInventorys(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMaterialInventoryPaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMaterialInventoryPaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialInventorys(response: HttpResponseBase): Observable<PagedResultDtoOfGetMaterialInventoryPaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetMaterialInventoryPaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetMaterialInventoryPaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMaterialInventoryPaginationOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteMaterialInventory(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInventory/DeleteMaterialInventory?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMaterialInventory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMaterialInventory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMaterialInventory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInventoryDetail(id: string | null | undefined): Observable<GetInventoryRecordDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInventory/GetInventoryDetail?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInventoryDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInventoryDetail(<any>response_);
                } catch (e) {
                    return <Observable<GetInventoryRecordDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetInventoryRecordDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInventoryDetail(response: HttpResponseBase): Observable<GetInventoryRecordDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetInventoryRecordDto.fromJS(resultData200) : new GetInventoryRecordDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInventoryRecordDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createInventoryRecord(input: CreateInventoryRecordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInventory/CreateInventoryRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInventoryRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInventoryRecord(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateInventoryRecord(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    finishedInventoryRecord(input: CreateInventoryRecordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInventory/FinishedInventoryRecord";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinishedInventoryRecord(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinishedInventoryRecord(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFinishedInventoryRecord(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param instrumentId (optional) 
     * @param brandId (optional) 
     * @param organizationId (optional) 
     * @param materialTypeId (optional) 
     * @param storageLocationId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getInventoryRecords(startDate: Date | null | undefined, endDate: Date | null | undefined, instrumentId: string | null | undefined, brandId: string | null | undefined, organizationId: number | null | undefined, materialTypeId: string | null | undefined, storageLocationId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetInventoryRecordPaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInventory/GetInventoryRecords?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (instrumentId !== undefined)
            url_ += "InstrumentId=" + encodeURIComponent("" + instrumentId) + "&"; 
        if (brandId !== undefined)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        if (materialTypeId !== undefined)
            url_ += "MaterialTypeId=" + encodeURIComponent("" + materialTypeId) + "&"; 
        if (storageLocationId !== undefined)
            url_ += "StorageLocationId=" + encodeURIComponent("" + storageLocationId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInventoryRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInventoryRecords(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetInventoryRecordPaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetInventoryRecordPaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetInventoryRecords(response: HttpResponseBase): Observable<PagedResultDtoOfGetInventoryRecordPaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetInventoryRecordPaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetInventoryRecordPaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetInventoryRecordPaginationOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    inventoryOutOrStorage(input: EntityDtoOfGuid | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInventory/InventoryOutOrStorage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInventoryOutOrStorage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInventoryOutOrStorage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInventoryOutOrStorage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInventoryToExcel(id: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialInventory/GetInventoryToExcel?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInventoryToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInventoryToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInventoryToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class MaterialOutStorageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaterialOutStorageForEdit(id: string | null | undefined): Observable<GetMaterialOutStorageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialOutStorage/GetMaterialOutStorageForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialOutStorageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialOutStorageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMaterialOutStorageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMaterialOutStorageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialOutStorageForEdit(response: HttpResponseBase): Observable<GetMaterialOutStorageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMaterialOutStorageForEditOutput.fromJS(resultData200) : new GetMaterialOutStorageForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMaterialOutStorageForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateMaterialOutStorage(input: CreateOrUpdateMaterialOutStorageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialOutStorage/CreateOrUpdateMaterialOutStorage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateMaterialOutStorage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateMaterialOutStorage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateMaterialOutStorage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param outStorage (optional) 
     * @return Success
     */
    outStorageSyncK3(outStorage: MaterialOutStorage | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialOutStorage/OutStorageSyncK3";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(outStorage);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOutStorageSyncK3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOutStorageSyncK3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processOutStorageSyncK3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    syncK3(input: EntityDtoOfGuid | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialOutStorage/SyncK3";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncK3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncK3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSyncK3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param requestOrderNo (optional) 
     * @param outStorageOrderNo (optional) 
     * @param userId (optional) 
     * @param accountOrName (optional) 
     * @param instrumentId (optional) 
     * @param brandId (optional) 
     * @param organizationId (optional) 
     * @param materialTypeId (optional) 
     * @param storageLocationId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMaterialOutStorages(startDate: Date | null | undefined, endDate: Date | null | undefined, requestOrderNo: string | null | undefined, outStorageOrderNo: string | null | undefined, userId: number | null | undefined, accountOrName: string | null | undefined, instrumentId: string | null | undefined, brandId: string | null | undefined, organizationId: number | null | undefined, materialTypeId: string | null | undefined, storageLocationId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetMaterialOutStoragePaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialOutStorage/GetMaterialOutStorages?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (requestOrderNo !== undefined)
            url_ += "RequestOrderNo=" + encodeURIComponent("" + requestOrderNo) + "&"; 
        if (outStorageOrderNo !== undefined)
            url_ += "OutStorageOrderNo=" + encodeURIComponent("" + outStorageOrderNo) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (accountOrName !== undefined)
            url_ += "AccountOrName=" + encodeURIComponent("" + accountOrName) + "&"; 
        if (instrumentId !== undefined)
            url_ += "InstrumentId=" + encodeURIComponent("" + instrumentId) + "&"; 
        if (brandId !== undefined)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        if (materialTypeId !== undefined)
            url_ += "MaterialTypeId=" + encodeURIComponent("" + materialTypeId) + "&"; 
        if (storageLocationId !== undefined)
            url_ += "StorageLocationId=" + encodeURIComponent("" + storageLocationId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialOutStorages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialOutStorages(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMaterialOutStoragePaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMaterialOutStoragePaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialOutStorages(response: HttpResponseBase): Observable<PagedResultDtoOfGetMaterialOutStoragePaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetMaterialOutStoragePaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetMaterialOutStoragePaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMaterialOutStoragePaginationOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    xGetMaterialOutStorages(input: GetMaterialOutStoragePaginationInput | null | undefined): Observable<SumQualtityPagedResultDtoOfXGetMaterialOutStoragePaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialOutStorage/XGetMaterialOutStorages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXGetMaterialOutStorages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXGetMaterialOutStorages(<any>response_);
                } catch (e) {
                    return <Observable<SumQualtityPagedResultDtoOfXGetMaterialOutStoragePaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SumQualtityPagedResultDtoOfXGetMaterialOutStoragePaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processXGetMaterialOutStorages(response: HttpResponseBase): Observable<SumQualtityPagedResultDtoOfXGetMaterialOutStoragePaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SumQualtityPagedResultDtoOfXGetMaterialOutStoragePaginationOutput.fromJS(resultData200) : new SumQualtityPagedResultDtoOfXGetMaterialOutStoragePaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SumQualtityPagedResultDtoOfXGetMaterialOutStoragePaginationOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteMaterialOutStorage(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialOutStorage/DeleteMaterialOutStorage?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMaterialOutStorage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMaterialOutStorage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMaterialOutStorage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    validateMaterialExpiryDate(input: ValidateMaterialExpiryDateInput | null | undefined): Observable<ValidateMaterialExpiryDateOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialOutStorage/ValidateMaterialExpiryDate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateMaterialExpiryDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateMaterialExpiryDate(<any>response_);
                } catch (e) {
                    return <Observable<ValidateMaterialExpiryDateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ValidateMaterialExpiryDateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processValidateMaterialExpiryDate(response: HttpResponseBase): Observable<ValidateMaterialExpiryDateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ValidateMaterialExpiryDateOutput.fromJS(resultData200) : new ValidateMaterialExpiryDateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ValidateMaterialExpiryDateOutput>(<any>null);
    }
}

@Injectable()
export class MaterialPurchaseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaterialPurchaseForEdit(id: string | null | undefined): Observable<GetMaterialPurchaseForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialPurchase/GetMaterialPurchaseForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialPurchaseForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialPurchaseForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMaterialPurchaseForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMaterialPurchaseForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialPurchaseForEdit(response: HttpResponseBase): Observable<GetMaterialPurchaseForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMaterialPurchaseForEditOutput.fromJS(resultData200) : new GetMaterialPurchaseForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMaterialPurchaseForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateMaterialPurchase(input: CreateOrUpdateMaterialPurchaseInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialPurchase/CreateOrUpdateMaterialPurchase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateMaterialPurchase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateMaterialPurchase(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateMaterialPurchase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param purchaseOrderNo (optional) 
     * @param userId (optional) 
     * @param instrumentId (optional) 
     * @param brandId (optional) 
     * @param organizationId (optional) 
     * @param materialTypeId (optional) 
     * @param storageLocationId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMaterialPurchases(startDate: Date | null | undefined, endDate: Date | null | undefined, purchaseOrderNo: string | null | undefined, userId: number | null | undefined, instrumentId: string | null | undefined, brandId: string | null | undefined, organizationId: number | null | undefined, materialTypeId: string | null | undefined, storageLocationId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetMaterialPurchasePaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialPurchase/GetMaterialPurchases?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (purchaseOrderNo !== undefined)
            url_ += "PurchaseOrderNo=" + encodeURIComponent("" + purchaseOrderNo) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (instrumentId !== undefined)
            url_ += "InstrumentId=" + encodeURIComponent("" + instrumentId) + "&"; 
        if (brandId !== undefined)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        if (materialTypeId !== undefined)
            url_ += "MaterialTypeId=" + encodeURIComponent("" + materialTypeId) + "&"; 
        if (storageLocationId !== undefined)
            url_ += "StorageLocationId=" + encodeURIComponent("" + storageLocationId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialPurchases(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialPurchases(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMaterialPurchasePaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMaterialPurchasePaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialPurchases(response: HttpResponseBase): Observable<PagedResultDtoOfGetMaterialPurchasePaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetMaterialPurchasePaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetMaterialPurchasePaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMaterialPurchasePaginationOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteMaterialPurchase(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialPurchase/DeleteMaterialPurchase?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMaterialPurchase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMaterialPurchase(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMaterialPurchase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    waitingForApprovalList(input: WaitingForPurchaseApprovalListInput | null | undefined): Observable<PagedResultDtoOfWaitingForPurchaseApprovalListOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialPurchase/WaitingForApprovalList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWaitingForApprovalList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitingForApprovalList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWaitingForPurchaseApprovalListOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWaitingForPurchaseApprovalListOutput>><any>_observableThrow(response_);
        }));
    }

    protected processWaitingForApprovalList(response: HttpResponseBase): Observable<PagedResultDtoOfWaitingForPurchaseApprovalListOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWaitingForPurchaseApprovalListOutput.fromJS(resultData200) : new PagedResultDtoOfWaitingForPurchaseApprovalListOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWaitingForPurchaseApprovalListOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    invalidMaterialPurchase(input: EntityDtoOfGuid[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialPurchase/InvalidMaterialPurchase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvalidMaterialPurchase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvalidMaterialPurchase(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processInvalidMaterialPurchase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    closingMaterialPurchase(input: EntityDtoOfGuid[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialPurchase/ClosingMaterialPurchase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClosingMaterialPurchase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClosingMaterialPurchase(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClosingMaterialPurchase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    waitingForAcceptanceList(input: WaitingForAcceptanceListInput | null | undefined): Observable<PagedResultDtoOfWaitingForAcceptanceListOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialPurchase/WaitingForAcceptanceList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWaitingForAcceptanceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitingForAcceptanceList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWaitingForAcceptanceListOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWaitingForAcceptanceListOutput>><any>_observableThrow(response_);
        }));
    }

    protected processWaitingForAcceptanceList(response: HttpResponseBase): Observable<PagedResultDtoOfWaitingForAcceptanceListOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWaitingForAcceptanceListOutput.fromJS(resultData200) : new PagedResultDtoOfWaitingForAcceptanceListOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWaitingForAcceptanceListOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    purchaseSyncK3(input: EntityDtoOfGuid | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialPurchase/PurchaseSyncK3";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPurchaseSyncK3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPurchaseSyncK3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPurchaseSyncK3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    handleImportFile(filePath: string | null | undefined): Observable<PurchaseOrderImportOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialPurchase/HandleImportFile?";
        if (filePath !== undefined)
            url_ += "filePath=" + encodeURIComponent("" + filePath) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHandleImportFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHandleImportFile(<any>response_);
                } catch (e) {
                    return <Observable<PurchaseOrderImportOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PurchaseOrderImportOutput>><any>_observableThrow(response_);
        }));
    }

    protected processHandleImportFile(response: HttpResponseBase): Observable<PurchaseOrderImportOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PurchaseOrderImportOutput.fromJS(resultData200) : new PurchaseOrderImportOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseOrderImportOutput>(<any>null);
    }
}

@Injectable()
export class MaterialRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaterialRequestForEdit(id: string | null | undefined): Observable<GetMaterialRequestForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialRequest/GetMaterialRequestForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialRequestForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialRequestForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMaterialRequestForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMaterialRequestForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialRequestForEdit(response: HttpResponseBase): Observable<GetMaterialRequestForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMaterialRequestForEditOutput.fromJS(resultData200) : new GetMaterialRequestForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMaterialRequestForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateMaterialRequest(input: CreateOrUpdateMaterialRequestInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialRequest/CreateOrUpdateMaterialRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateMaterialRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateMaterialRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateMaterialRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param requestOrderNo (optional) 
     * @param userId (optional) 
     * @param instrumentId (optional) 
     * @param brandId (optional) 
     * @param organizationId (optional) 
     * @param materialTypeId (optional) 
     * @param storageLocationId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMaterialRequests(startDate: Date | null | undefined, endDate: Date | null | undefined, requestOrderNo: string | null | undefined, userId: number | null | undefined, instrumentId: string | null | undefined, brandId: string | null | undefined, organizationId: number | null | undefined, materialTypeId: string | null | undefined, storageLocationId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetMaterialRequestPaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialRequest/GetMaterialRequests?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (requestOrderNo !== undefined)
            url_ += "RequestOrderNo=" + encodeURIComponent("" + requestOrderNo) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (instrumentId !== undefined)
            url_ += "InstrumentId=" + encodeURIComponent("" + instrumentId) + "&"; 
        if (brandId !== undefined)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        if (materialTypeId !== undefined)
            url_ += "MaterialTypeId=" + encodeURIComponent("" + materialTypeId) + "&"; 
        if (storageLocationId !== undefined)
            url_ += "StorageLocationId=" + encodeURIComponent("" + storageLocationId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialRequests(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMaterialRequestPaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMaterialRequestPaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialRequests(response: HttpResponseBase): Observable<PagedResultDtoOfGetMaterialRequestPaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetMaterialRequestPaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetMaterialRequestPaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMaterialRequestPaginationOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteMaterialRequest(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialRequest/DeleteMaterialRequest?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMaterialRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMaterialRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMaterialRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    waitingForApprovalList(input: WaitingForMaterialRequestApprovalListInput | null | undefined): Observable<PagedResultDtoOfWaitingForMaterialRequestApprovalListOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialRequest/WaitingForApprovalList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWaitingForApprovalList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitingForApprovalList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWaitingForMaterialRequestApprovalListOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWaitingForMaterialRequestApprovalListOutput>><any>_observableThrow(response_);
        }));
    }

    protected processWaitingForApprovalList(response: HttpResponseBase): Observable<PagedResultDtoOfWaitingForMaterialRequestApprovalListOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWaitingForMaterialRequestApprovalListOutput.fromJS(resultData200) : new PagedResultDtoOfWaitingForMaterialRequestApprovalListOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWaitingForMaterialRequestApprovalListOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    requestOutStorage(input: RequestOutStorageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialRequest/RequestOutStorage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestOutStorage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestOutStorage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRequestOutStorage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    waitingForAcceptanceRequestList(input: WaitingForAcceptanceRequestListInput | null | undefined): Observable<PagedResultDtoOfWaitingForAcceptanceRequestListOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialRequest/WaitingForAcceptanceRequestList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWaitingForAcceptanceRequestList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWaitingForAcceptanceRequestList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWaitingForAcceptanceRequestListOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWaitingForAcceptanceRequestListOutput>><any>_observableThrow(response_);
        }));
    }

    protected processWaitingForAcceptanceRequestList(response: HttpResponseBase): Observable<PagedResultDtoOfWaitingForAcceptanceRequestListOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWaitingForAcceptanceRequestListOutput.fromJS(resultData200) : new PagedResultDtoOfWaitingForAcceptanceRequestListOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWaitingForAcceptanceRequestListOutput>(<any>null);
    }
}

@Injectable()
export class MaterialStockServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaterialStockForEdit(id: string | null | undefined): Observable<GetMaterialStockForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialStock/GetMaterialStockForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialStockForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialStockForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMaterialStockForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMaterialStockForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialStockForEdit(response: HttpResponseBase): Observable<GetMaterialStockForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMaterialStockForEditOutput.fromJS(resultData200) : new GetMaterialStockForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMaterialStockForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateMaterialStock(input: CreateOrUpdateMaterialStockInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialStock/CreateOrUpdateMaterialStock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateMaterialStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateMaterialStock(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateMaterialStock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param outInStorageType (optional) 
     * @param instrumentId (optional) 
     * @param brandId (optional) 
     * @param organizationId (optional) 
     * @param materialTypeId (optional) 
     * @param storageLocationId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMaterialStocks(outInStorageType: OutInStorageType2 | null | undefined, instrumentId: string | null | undefined, brandId: string | null | undefined, organizationId: number | null | undefined, materialTypeId: string | null | undefined, storageLocationId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetMaterialStockPaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialStock/GetMaterialStocks?";
        if (outInStorageType !== undefined)
            url_ += "OutInStorageType=" + encodeURIComponent("" + outInStorageType) + "&"; 
        if (instrumentId !== undefined)
            url_ += "InstrumentId=" + encodeURIComponent("" + instrumentId) + "&"; 
        if (brandId !== undefined)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        if (materialTypeId !== undefined)
            url_ += "MaterialTypeId=" + encodeURIComponent("" + materialTypeId) + "&"; 
        if (storageLocationId !== undefined)
            url_ += "StorageLocationId=" + encodeURIComponent("" + storageLocationId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialStocks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialStocks(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMaterialStockPaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMaterialStockPaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialStocks(response: HttpResponseBase): Observable<PagedResultDtoOfGetMaterialStockPaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetMaterialStockPaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetMaterialStockPaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMaterialStockPaginationOutput>(<any>null);
    }

    /**
     * @param outInStorageType (optional) 
     * @param instrumentId (optional) 
     * @param brandId (optional) 
     * @param organizationId (optional) 
     * @param materialTypeId (optional) 
     * @param storageLocationId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMaterialStocksToExcel(outInStorageType: OutInStorageType3 | null | undefined, instrumentId: string | null | undefined, brandId: string | null | undefined, organizationId: number | null | undefined, materialTypeId: string | null | undefined, storageLocationId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialStock/GetMaterialStocksToExcel?";
        if (outInStorageType !== undefined)
            url_ += "OutInStorageType=" + encodeURIComponent("" + outInStorageType) + "&"; 
        if (instrumentId !== undefined)
            url_ += "InstrumentId=" + encodeURIComponent("" + instrumentId) + "&"; 
        if (brandId !== undefined)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        if (materialTypeId !== undefined)
            url_ += "MaterialTypeId=" + encodeURIComponent("" + materialTypeId) + "&"; 
        if (storageLocationId !== undefined)
            url_ += "StorageLocationId=" + encodeURIComponent("" + storageLocationId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialStocksToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialStocksToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialStocksToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteMaterialStock(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialStock/DeleteMaterialStock?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMaterialStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMaterialStock(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMaterialStock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    outOrStorage(input: MaterialStockOutOrStorageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialStock/OutOrStorage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOutOrStorage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOutOrStorage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processOutOrStorage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MaterialStorageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaterialStorageForEdit(id: string | null | undefined): Observable<GetMaterialStorageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialStorage/GetMaterialStorageForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialStorageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialStorageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMaterialStorageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMaterialStorageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialStorageForEdit(response: HttpResponseBase): Observable<GetMaterialStorageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMaterialStorageForEditOutput.fromJS(resultData200) : new GetMaterialStorageForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMaterialStorageForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateMaterialStorage(input: CreateOrUpdateMaterialStorageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialStorage/CreateOrUpdateMaterialStorage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateMaterialStorage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateMaterialStorage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateMaterialStorage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cancel(input: EntityDtoOfGuid | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialStorage/Cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param storageOrderNo (optional) 
     * @param userId (optional) 
     * @param accountOrName (optional) 
     * @param instrumentId (optional) 
     * @param brandId (optional) 
     * @param organizationId (optional) 
     * @param materialTypeId (optional) 
     * @param storageLocationId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getMaterialStorages(startDate: Date | null | undefined, endDate: Date | null | undefined, storageOrderNo: string | null | undefined, userId: number | null | undefined, accountOrName: string | null | undefined, instrumentId: string | null | undefined, brandId: string | null | undefined, organizationId: number | null | undefined, materialTypeId: string | null | undefined, storageLocationId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetMaterialStoragePaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialStorage/GetMaterialStorages?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (storageOrderNo !== undefined)
            url_ += "StorageOrderNo=" + encodeURIComponent("" + storageOrderNo) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (accountOrName !== undefined)
            url_ += "AccountOrName=" + encodeURIComponent("" + accountOrName) + "&"; 
        if (instrumentId !== undefined)
            url_ += "InstrumentId=" + encodeURIComponent("" + instrumentId) + "&"; 
        if (brandId !== undefined)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        if (materialTypeId !== undefined)
            url_ += "MaterialTypeId=" + encodeURIComponent("" + materialTypeId) + "&"; 
        if (storageLocationId !== undefined)
            url_ += "StorageLocationId=" + encodeURIComponent("" + storageLocationId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialStorages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialStorages(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMaterialStoragePaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMaterialStoragePaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialStorages(response: HttpResponseBase): Observable<PagedResultDtoOfGetMaterialStoragePaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetMaterialStoragePaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetMaterialStoragePaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMaterialStoragePaginationOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    xGetMaterialStorages(input: GetMaterialStoragePaginationInput | null | undefined): Observable<SumQualtityPagedResultDtoOfXGetMaterialStoragePaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialStorage/XGetMaterialStorages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXGetMaterialStorages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXGetMaterialStorages(<any>response_);
                } catch (e) {
                    return <Observable<SumQualtityPagedResultDtoOfXGetMaterialStoragePaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SumQualtityPagedResultDtoOfXGetMaterialStoragePaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processXGetMaterialStorages(response: HttpResponseBase): Observable<SumQualtityPagedResultDtoOfXGetMaterialStoragePaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SumQualtityPagedResultDtoOfXGetMaterialStoragePaginationOutput.fromJS(resultData200) : new SumQualtityPagedResultDtoOfXGetMaterialStoragePaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SumQualtityPagedResultDtoOfXGetMaterialStoragePaginationOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteMaterialStorage(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialStorage/DeleteMaterialStorage?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMaterialStorage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMaterialStorage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMaterialStorage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    returnErrorOperation(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialStorage/ReturnErrorOperation";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReturnErrorOperation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReturnErrorOperation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReturnErrorOperation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ModuleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getModuleForEdit(id: string | null | undefined): Observable<GetModuleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetModuleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModuleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModuleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetModuleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetModuleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetModuleForEdit(response: HttpResponseBase): Observable<GetModuleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetModuleForEditOutput.fromJS(resultData200) : new GetModuleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetModuleForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateModule(input: CreateOrUpdateModuleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Module/CreateOrUpdateModule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateModule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateModule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getModules(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetModulePaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetModules?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModules(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetModulePaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetModulePaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetModules(response: HttpResponseBase): Observable<PagedResultDtoOfGetModulePaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetModulePaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetModulePaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetModulePaginationOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getModuleList(): Observable<GetModuleListOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/Module/GetModuleList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModuleList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModuleList(<any>response_);
                } catch (e) {
                    return <Observable<GetModuleListOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetModuleListOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetModuleList(response: HttpResponseBase): Observable<GetModuleListOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetModuleListOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetModuleListOutput[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteModule(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Module/DeleteModule?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteModule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteModule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    handleImportFile(filePath: string | null | undefined): Observable<ModuleImportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Module/HandleImportFile?";
        if (filePath !== undefined)
            url_ += "filePath=" + encodeURIComponent("" + filePath) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHandleImportFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHandleImportFile(<any>response_);
                } catch (e) {
                    return <Observable<ModuleImportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ModuleImportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processHandleImportFile(response: HttpResponseBase): Observable<ModuleImportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ModuleImportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ModuleImportDto[]>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param state (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: State | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationsOutput.fromJS(resultData200) : new GetNotificationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setNotificationAsRead(input: EntityDtoOfGuid | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationSettingsOutput.fromJS(resultData200) : new GetNotificationSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateNotificationSettings(input: UpdateNotificationSettingsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfOrganizationUnitDto.fromJS(resultData200) : new ListResultDtoOfOrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfOrganizationUnitDto>(<any>null);
    }

    /**
     * @return Success
     */
    getOrganizationUnitsWithChildren(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitsWithChildren";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitsWithChildren(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitsWithChildren(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitsWithChildren(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfOrganizationUnitDto.fromJS(resultData200) : new ListResultDtoOfOrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfOrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserOrganizationUnits(id: number | null | undefined): Observable<GetUserOrganizationUnitsOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetUserOrganizationUnits?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<GetUserOrganizationUnitsOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserOrganizationUnitsOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserOrganizationUnits(response: HttpResponseBase): Observable<GetUserOrganizationUnitsOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetUserOrganizationUnitsOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserOrganizationUnitsOutput[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    xGetUserOrganizationUnits(input: GetUserOrganizationUnitsInput | null | undefined): Observable<GetUserOrganizationUnitsOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/XGetUserOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXGetUserOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXGetUserOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<GetUserOrganizationUnitsOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserOrganizationUnitsOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processXGetUserOrganizationUnits(response: HttpResponseBase): Observable<GetUserOrganizationUnitsOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetUserOrganizationUnitsOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserOrganizationUnitsOutput[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitUserListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateOrganizationUnit(input: CreateOrUpdateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrUpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrganizationUnit(input: CreateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateOrganizationUnit(input: UpdateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setOrganizationOutInStorageSetting(input: UpdateOrganizationOutInStorageSettingInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/SetOrganizationOutInStorageSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetOrganizationOutInStorageSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetOrganizationOutInStorageSetting(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetOrganizationOutInStorageSetting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOrganizationUnitForEdit(id: number | null | undefined): Observable<OrganizationUnitForEditDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitForEdit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitForEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitForEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitForEdit(response: HttpResponseBase): Observable<OrganizationUnitForEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitForEditDto.fromJS(resultData200) : new OrganizationUnitForEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitForEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveOrganizationUnit(input: MoveOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(input: UsersToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findUsers(input: FindOrganizationUnitUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number | null | undefined): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentInfo?";
        if (upgradeEditionId !== undefined)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<PaymentInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentInfoDto.fromJS(resultData200) : new PaymentInfoDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInfoDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createPayment(input: CreatePaymentDto | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    executePayment(input: ExecutePaymentDto | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ExecutePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExecutePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExecutePayment(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processExecutePayment(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaymentHistory(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentHistory?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentHistory(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200) : new PagedResultDtoOfSubscriptionPaymentListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSubscriptionPaymentListDto>(<any>null);
    }
}

@Injectable()
export class PerformanceVerificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param instrumentId (optional) 
     * @param brandId (optional) 
     * @param organizationId (optional) 
     * @param materialTypeId (optional) 
     * @param storageLocationId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWaitForVerfifyMaterials(instrumentId: string | null | undefined, brandId: string | null | undefined, organizationId: number | null | undefined, materialTypeId: string | null | undefined, storageLocationId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetWaitForVerfifyMaterialsOutput> {
        let url_ = this.baseUrl + "/api/services/app/PerformanceVerification/GetWaitForVerfifyMaterials?";
        if (instrumentId !== undefined)
            url_ += "InstrumentId=" + encodeURIComponent("" + instrumentId) + "&"; 
        if (brandId !== undefined)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        if (materialTypeId !== undefined)
            url_ += "MaterialTypeId=" + encodeURIComponent("" + materialTypeId) + "&"; 
        if (storageLocationId !== undefined)
            url_ += "StorageLocationId=" + encodeURIComponent("" + storageLocationId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWaitForVerfifyMaterials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWaitForVerfifyMaterials(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWaitForVerfifyMaterialsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWaitForVerfifyMaterialsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWaitForVerfifyMaterials(response: HttpResponseBase): Observable<PagedResultDtoOfGetWaitForVerfifyMaterialsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWaitForVerfifyMaterialsOutput.fromJS(resultData200) : new PagedResultDtoOfGetWaitForVerfifyMaterialsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWaitForVerfifyMaterialsOutput>(<any>null);
    }

    /**
     * @param materialId (optional) 
     * @param instrumentId (optional) 
     * @return Success
     */
    getPerformanceVerificationInfo(materialId: string | null | undefined, instrumentId: string | null | undefined): Observable<GetPerformanceVerificationInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/PerformanceVerification/GetPerformanceVerificationInfo?";
        if (materialId !== undefined)
            url_ += "MaterialId=" + encodeURIComponent("" + materialId) + "&"; 
        if (instrumentId !== undefined)
            url_ += "InstrumentId=" + encodeURIComponent("" + instrumentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformanceVerificationInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformanceVerificationInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetPerformanceVerificationInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPerformanceVerificationInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformanceVerificationInfo(response: HttpResponseBase): Observable<GetPerformanceVerificationInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPerformanceVerificationInfoOutput.fromJS(resultData200) : new GetPerformanceVerificationInfoOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPerformanceVerificationInfoOutput>(<any>null);
    }
}

@Injectable()
export class PerformanceVerificationReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPerformanceVerificationReportForEdit(id: string | null | undefined): Observable<GetPerformanceVerificationReportForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/PerformanceVerificationReport/GetPerformanceVerificationReportForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformanceVerificationReportForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformanceVerificationReportForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPerformanceVerificationReportForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPerformanceVerificationReportForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformanceVerificationReportForEdit(response: HttpResponseBase): Observable<GetPerformanceVerificationReportForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPerformanceVerificationReportForEditOutput.fromJS(resultData200) : new GetPerformanceVerificationReportForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPerformanceVerificationReportForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdatePerformanceVerificationReport(input: CreateOrUpdatePerformanceVerificationReportInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PerformanceVerificationReport/CreateOrUpdatePerformanceVerificationReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdatePerformanceVerificationReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdatePerformanceVerificationReport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdatePerformanceVerificationReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param reportNo (optional) 
     * @param instrumentId (optional) 
     * @param brandId (optional) 
     * @param organizationId (optional) 
     * @param materialTypeId (optional) 
     * @param storageLocationId (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPerformanceVerificationReports(startDate: Date | null | undefined, endDate: Date | null | undefined, reportNo: string | null | undefined, instrumentId: string | null | undefined, brandId: string | null | undefined, organizationId: number | null | undefined, materialTypeId: string | null | undefined, storageLocationId: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetPerformanceVerificationReportPaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/PerformanceVerificationReport/GetPerformanceVerificationReports?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (reportNo !== undefined)
            url_ += "ReportNo=" + encodeURIComponent("" + reportNo) + "&"; 
        if (instrumentId !== undefined)
            url_ += "InstrumentId=" + encodeURIComponent("" + instrumentId) + "&"; 
        if (brandId !== undefined)
            url_ += "BrandId=" + encodeURIComponent("" + brandId) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        if (materialTypeId !== undefined)
            url_ += "MaterialTypeId=" + encodeURIComponent("" + materialTypeId) + "&"; 
        if (storageLocationId !== undefined)
            url_ += "StorageLocationId=" + encodeURIComponent("" + storageLocationId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPerformanceVerificationReports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPerformanceVerificationReports(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetPerformanceVerificationReportPaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetPerformanceVerificationReportPaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPerformanceVerificationReports(response: HttpResponseBase): Observable<PagedResultDtoOfGetPerformanceVerificationReportPaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetPerformanceVerificationReportPaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetPerformanceVerificationReportPaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetPerformanceVerificationReportPaginationOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deletePerformanceVerificationReport(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PerformanceVerificationReport/DeletePerformanceVerificationReport?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePerformanceVerificationReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePerformanceVerificationReport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePerformanceVerificationReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getUserAllPermissions(userId: number | null | undefined): Observable<ListResultDtoOfGetAllPermissionOutput> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetUserAllPermissions?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGetAllPermissionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGetAllPermissionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfGetAllPermissionOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfGetAllPermissionOutput.fromJS(resultData200) : new ListResultDtoOfGetAllPermissionOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllPermissionOutput>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @return Success
     */
    getRoleAllPermissions(roleId: number | null | undefined): Observable<ListResultDtoOfGetAllPermissionOutput> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetRoleAllPermissions?";
        if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGetAllPermissionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGetAllPermissionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfGetAllPermissionOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfGetAllPermissionOutput.fromJS(resultData200) : new ListResultDtoOfGetAllPermissionOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllPermissionOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getGrantedPermissions(): Observable<ListResultDtoOfGetGrantedPermissionOutput> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetGrantedPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGrantedPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGrantedPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGetGrantedPermissionOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGetGrantedPermissionOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGrantedPermissions(response: HttpResponseBase): Observable<ListResultDtoOfGetGrantedPermissionOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfGetGrantedPermissionOutput.fromJS(resultData200) : new ListResultDtoOfGetGrantedPermissionOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetGrantedPermissionOutput>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentUserProfileEditDto.fromJS(resultData200) : new CurrentUserProfileEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentUserProfileEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(<any>response_);
                } catch (e) {
                    return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200) : new UpdateGoogleAuthenticatorKeyOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateGoogleAuthenticatorKeyOutput>(<any>null);
    }

    /**
     * @return Success
     */
    sendVerificationSms(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    verifySmsCode(input: VerifySmsCodeInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateCurrentUserProfile(input: CurrentUserProfileEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changePassword(input: ChangePasswordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateProfilePicture(input: UpdateProfilePictureInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(<any>response_);
                } catch (e) {
                    return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPasswordComplexitySettingOutput.fromJS(resultData200) : new GetPasswordComplexitySettingOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPasswordComplexitySettingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @param userId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getFriendProfilePictureById(profilePictureId: string | null | undefined, userId: number | null | undefined, tenantId: number | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetFriendProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "ProfilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFriendProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @return Success
     */
    getProfilePictureById(profilePictureId: string | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRoleList(): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleList(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleList(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateRole(input: CreateOrUpdateRoleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRole(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateRolePermissionsWithCustom(input: UpdateRolePermissionsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/UpdateRolePermissionsWithCustom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRolePermissionsWithCustom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRolePermissionsWithCustom(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRolePermissionsWithCustom(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateUserSignInTokenOutput.fromJS(resultData200) : new UpdateUserSignInTokenOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
    }
}

@Injectable()
export class StorageLocationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getStorageLocationForEdit(id: string | null | undefined): Observable<GetStorageLocationForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/StorageLocation/GetStorageLocationForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStorageLocationForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStorageLocationForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetStorageLocationForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetStorageLocationForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetStorageLocationForEdit(response: HttpResponseBase): Observable<GetStorageLocationForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetStorageLocationForEditOutput.fromJS(resultData200) : new GetStorageLocationForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetStorageLocationForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateStorageLocation(input: CreateOrUpdateStorageLocationInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StorageLocation/CreateOrUpdateStorageLocation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateStorageLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateStorageLocation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateStorageLocation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param organizationId (optional) 
     * @param warehouseInfoId (optional) 
     * @param locationName (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getStorageLocations(organizationId: number | null | undefined, warehouseInfoId: string | null | undefined, locationName: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetStorageLocationPaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/StorageLocation/GetStorageLocations?";
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        if (warehouseInfoId !== undefined)
            url_ += "WarehouseInfoId=" + encodeURIComponent("" + warehouseInfoId) + "&"; 
        if (locationName !== undefined)
            url_ += "LocationName=" + encodeURIComponent("" + locationName) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStorageLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStorageLocations(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetStorageLocationPaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetStorageLocationPaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetStorageLocations(response: HttpResponseBase): Observable<PagedResultDtoOfGetStorageLocationPaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetStorageLocationPaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetStorageLocationPaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetStorageLocationPaginationOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteStorageLocation(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StorageLocation/DeleteStorageLocation?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteStorageLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteStorageLocation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteStorageLocation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    upgradeTenantToEquivalentEdition(upgradeEditionId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/UpgradeTenantToEquivalentEdition?";
        if (upgradeEditionId !== undefined)
            url_ += "upgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeTenantToEquivalentEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeTenantToEquivalentEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeTenantToEquivalentEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param subscriptionEndDateStart (optional) 
     * @param subscriptionEndDateEnd (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param editionId (optional) 
     * @param editionIdSpecified (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | null | undefined, subscriptionEndDateStart: Date | null | undefined, subscriptionEndDateEnd: Date | null | undefined, creationDateStart: Date | null | undefined, creationDateEnd: Date | null | undefined, editionId: number | null | undefined, editionIdSpecified: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (subscriptionEndDateStart !== undefined)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toJSON() : "") + "&"; 
        if (subscriptionEndDateEnd !== undefined)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toJSON() : "") + "&"; 
        if (creationDateStart !== undefined)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&"; 
        if (creationDateEnd !== undefined)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&"; 
        if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&"; 
        if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantListDto.fromJS(resultData200) : new PagedResultDtoOfTenantListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createTenant(input: CreateTenantInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | null | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(<any>response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantEditDto.fromJS(resultData200) : new TenantEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateTenant(input: TenantEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTenant(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteTenant?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | null | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTenantFeaturesEditOutput.fromJS(resultData200) : new GetTenantFeaturesEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateTenantFeatures(input: UpdateTenantFeaturesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlockTenantAdmin(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberActivityOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberActivityOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemberActivityOutput.fromJS(resultData200) : new GetMemberActivityOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberActivityOutput>(<any>null);
    }

    /**
     * @param salesSummaryDatePeriod (optional) 
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod | null | undefined): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod !== undefined)
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<GetDashboardDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDashboardDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDashboardDataOutput.fromJS(resultData200) : new GetDashboardDataOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDashboardDataOutput>(<any>null);
    }

    /**
     * @param salesSummaryDatePeriod (optional) 
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod2 | null | undefined): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod !== undefined)
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(<any>response_);
                } catch (e) {
                    return <Observable<GetSalesSummaryOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSalesSummaryOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSalesSummaryOutput.fromJS(resultData200) : new GetSalesSummaryOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSalesSummaryOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getRegionalStats(input: any | null | undefined): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRegionalStats?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionalStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(<any>response_);
                } catch (e) {
                    return <Observable<GetRegionalStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRegionalStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRegionalStatsOutput.fromJS(resultData200) : new GetRegionalStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRegionalStatsOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getGeneralStats(input: any | null | undefined): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetGeneralStats?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(<any>response_);
                } catch (e) {
                    return <Observable<GetGeneralStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGeneralStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetGeneralStatsOutput.fromJS(resultData200) : new GetGeneralStatsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGeneralStatsOutput>(<any>null);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    registerTenant(input: RegisterTenantInput | null | undefined): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterTenantOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterTenantOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterTenantOutput.fromJS(resultData200) : new RegisterTenantOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterTenantOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForSelect(<any>response_);
                } catch (e) {
                    return <Observable<EditionsSelectOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionsSelectOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionsSelectOutput.fromJS(resultData200) : new EditionsSelectOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionsSelectOutput>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getEdition(editionId: number | null | undefined): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEdition?";
        if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEdition(<any>response_);
                } catch (e) {
                    return <Observable<EditionSelectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionSelectDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionSelectDto.fromJS(resultData200) : new EditionSelectDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionSelectDto>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSettingsEditDto.fromJS(resultData200) : new TenantSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateAllSettings(input: TenantSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param defaultTimezoneScope (optional) 
     * @return Success
     */
    getTimezones(defaultTimezoneScope: DefaultTimezoneScope | null | undefined): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope !== undefined)
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfNameValueDto.fromJS(resultData200) : new ListResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<UiCustomizationSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<UiCustomizationSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UiCustomizationSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<UiCustomizationSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UiCustomizationSettingsEditDto.fromJS(resultData200) : new UiCustomizationSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UiCustomizationSettingsEditDto>(<any>null);
    }

    /**
     * @param settings (optional) 
     * @return Success
     */
    updateUiManagementSettings(settings: UiCustomizationSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param settings (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(settings: UiCustomizationSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param permission (optional) 
     * @param role (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUsers(filter: string | null | undefined, permission: string | null | undefined, role: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserListDto.fromJS(resultData200) : new PagedResultDtoOfUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * @return Success
     */
    getUserList(): Observable<UserListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserList(<any>response_);
                } catch (e) {
                    return <Observable<UserListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserList(response: HttpResponseBase): Observable<UserListDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserListDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getUsersToExcel(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserForEditOutput.fromJS(resultData200) : new GetUserForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | null | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserPermissionsForEditOutput.fromJS(resultData200) : new GetUserPermissionsForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateUserPassword(input: UpdateUserPasswordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateUserPermissions(input: UpdateUserPermissionsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateUserPermissionsWithCustom(input: UpdateUserPermissionsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissionsWithCustom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissionsWithCustom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissionsWithCustom(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPermissionsWithCustom(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateUser(input: CreateOrUpdateUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUser(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlockUser(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    handleImportFile(filePath: string | null | undefined): Observable<UserImportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/HandleImportFile?";
        if (filePath !== undefined)
            url_ += "filePath=" + encodeURIComponent("" + filePath) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHandleImportFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHandleImportFile(<any>response_);
                } catch (e) {
                    return <Observable<UserImportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserImportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processHandleImportFile(response: HttpResponseBase): Observable<UserImportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserImportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserImportDto[]>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    linkToUser(input: LinkToUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLinkedUserDto.fromJS(resultData200) : new PagedResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLinkedUserDto.fromJS(resultData200) : new ListResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlinkUser(input: UnlinkUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200) : new ListResultDtoOfUserLoginAttemptDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(<any>null);
    }
}

@Injectable()
export class VendorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVendorForEdit(id: string | null | undefined): Observable<GetVendorForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Vendor/GetVendorForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetVendorForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVendorForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorForEdit(response: HttpResponseBase): Observable<GetVendorForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetVendorForEditOutput.fromJS(resultData200) : new GetVendorForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVendorForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    syncVendor(input: NullableIdDtoOfGuid | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Vendor/SyncVendor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncVendor(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSyncVendor(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param vendorType (optional) 
     * @param filter (optional) 
     * @return Success
     */
    getVendorList(vendorType: VendorType | null | undefined, filter: string | null | undefined): Observable<GetVendorListOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/Vendor/GetVendorList?";
        if (vendorType !== undefined)
            url_ += "VendorType=" + encodeURIComponent("" + vendorType) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorList(<any>response_);
                } catch (e) {
                    return <Observable<GetVendorListOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVendorListOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorList(response: HttpResponseBase): Observable<GetVendorListOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetVendorListOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVendorListOutput[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateVendor(input: CreateOrUpdateVendorInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Vendor/CreateOrUpdateVendor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateVendor(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateVendor(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param vendorType (optional) 
     * @param code (optional) 
     * @param name (optional) 
     * @param contact (optional) 
     * @param telephone (optional) 
     * @param remark (optional) 
     * @param shortName (optional) 
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getVendors(vendorType: VendorType2 | null | undefined, code: string | null | undefined, name: string | null | undefined, contact: string | null | undefined, telephone: string | null | undefined, remark: string | null | undefined, shortName: string | null | undefined, filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetVendorPaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/Vendor/GetVendors?";
        if (vendorType !== undefined)
            url_ += "VendorType=" + encodeURIComponent("" + vendorType) + "&"; 
        if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (contact !== undefined)
            url_ += "Contact=" + encodeURIComponent("" + contact) + "&"; 
        if (telephone !== undefined)
            url_ += "Telephone=" + encodeURIComponent("" + telephone) + "&"; 
        if (remark !== undefined)
            url_ += "Remark=" + encodeURIComponent("" + remark) + "&"; 
        if (shortName !== undefined)
            url_ += "ShortName=" + encodeURIComponent("" + shortName) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendors(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendors(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetVendorPaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetVendorPaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendors(response: HttpResponseBase): Observable<PagedResultDtoOfGetVendorPaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetVendorPaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetVendorPaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetVendorPaginationOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteVendor(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Vendor/DeleteVendor?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVendor(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteVendor(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filePath (optional) 
     * @return Success
     */
    handleImportFile(filePath: string | null | undefined): Observable<VendorImportDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Vendor/HandleImportFile?";
        if (filePath !== undefined)
            url_ += "filePath=" + encodeURIComponent("" + filePath) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHandleImportFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHandleImportFile(<any>response_);
                } catch (e) {
                    return <Observable<VendorImportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<VendorImportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processHandleImportFile(response: HttpResponseBase): Observable<VendorImportDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(VendorImportDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VendorImportDto[]>(<any>null);
    }
}

@Injectable()
export class WarehouseInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWarehouseInfoForEdit(id: string | null | undefined): Observable<GetWarehouseInfoForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WarehouseInfo/GetWarehouseInfoForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWarehouseInfoForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWarehouseInfoForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWarehouseInfoForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWarehouseInfoForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWarehouseInfoForEdit(response: HttpResponseBase): Observable<GetWarehouseInfoForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWarehouseInfoForEditOutput.fromJS(resultData200) : new GetWarehouseInfoForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWarehouseInfoForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateWarehouseInfo(input: CreateOrUpdateWarehouseInfoInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WarehouseInfo/CreateOrUpdateWarehouseInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateWarehouseInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateWarehouseInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateWarehouseInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getWarehouseInfos(filter: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfGetWarehouseInfoPaginationOutput> {
        let url_ = this.baseUrl + "/api/services/app/WarehouseInfo/GetWarehouseInfos?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWarehouseInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWarehouseInfos(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWarehouseInfoPaginationOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWarehouseInfoPaginationOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWarehouseInfos(response: HttpResponseBase): Observable<PagedResultDtoOfGetWarehouseInfoPaginationOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetWarehouseInfoPaginationOutput.fromJS(resultData200) : new PagedResultDtoOfGetWarehouseInfoPaginationOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWarehouseInfoPaginationOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteWarehouseInfo(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WarehouseInfo/DeleteWarehouseInfo?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWarehouseInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWarehouseInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteWarehouseInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getWarehouseInfoList(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WarehouseInfo/GetWarehouseInfoList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWarehouseInfoList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWarehouseInfoList(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWarehouseInfoList(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param targetOrganizationId (optional) 
     * @return Success
     */
    getOrganizationWarehouseInfos(targetOrganizationId: number | null | undefined): Observable<GetOrganizationWarehouseInfosDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WarehouseInfo/GetOrganizationWarehouseInfos?";
        if (targetOrganizationId !== undefined)
            url_ += "TargetOrganizationId=" + encodeURIComponent("" + targetOrganizationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationWarehouseInfos(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationWarehouseInfos(<any>response_);
                } catch (e) {
                    return <Observable<GetOrganizationWarehouseInfosDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetOrganizationWarehouseInfosDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationWarehouseInfos(response: HttpResponseBase): Observable<GetOrganizationWarehouseInfosDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetOrganizationWarehouseInfosDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetOrganizationWarehouseInfosDto[]>(<any>null);
    }

    /**
     * @param warehouseGradeType (optional) 
     * @return Success
     */
    exsitWarehouseInfo(warehouseGradeType: WarehouseGradeType | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WarehouseInfo/ExsitWarehouseInfo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(warehouseGradeType);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExsitWarehouseInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExsitWarehouseInfo(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processExsitWarehouseInfo(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class WarningServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param userId (optional) 
     * @param organizationId (optional) 
     * @return Success
     */
    getWarningInfo(userId: number | null | undefined, organizationId: number | null | undefined): Observable<GetWarningInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/Warning/GetWarningInfo?";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWarningInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWarningInfo(<any>response_);
                } catch (e) {
                    return <Observable<GetWarningInfoOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWarningInfoOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWarningInfo(response: HttpResponseBase): Observable<GetWarningInfoOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWarningInfoOutput.fromJS(resultData200) : new GetWarningInfoOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWarningInfoOutput>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param organizationId (optional) 
     * @return Success
     */
    getPurchaseMaterialUnArrivedDetail(userId: number | null | undefined, organizationId: number | null | undefined): Observable<PurchaseMaterialUnArrivedDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Warning/GetPurchaseMaterialUnArrivedDetail?";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurchaseMaterialUnArrivedDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurchaseMaterialUnArrivedDetail(<any>response_);
                } catch (e) {
                    return <Observable<PurchaseMaterialUnArrivedDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<PurchaseMaterialUnArrivedDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPurchaseMaterialUnArrivedDetail(response: HttpResponseBase): Observable<PurchaseMaterialUnArrivedDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PurchaseMaterialUnArrivedDetailOutput.fromJS(resultData200) : new PurchaseMaterialUnArrivedDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseMaterialUnArrivedDetailOutput>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param organizationId (optional) 
     * @return Success
     */
    getMaterialStockAlertDetail(userId: number | null | undefined, organizationId: number | null | undefined): Observable<MaterialStockAlertDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Warning/GetMaterialStockAlertDetail?";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialStockAlertDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialStockAlertDetail(<any>response_);
                } catch (e) {
                    return <Observable<MaterialStockAlertDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<MaterialStockAlertDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaterialStockAlertDetail(response: HttpResponseBase): Observable<MaterialStockAlertDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MaterialStockAlertDetailOutput.fromJS(resultData200) : new MaterialStockAlertDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialStockAlertDetailOutput>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param organizationId (optional) 
     * @return Success
     */
    getCertificateExpirationDetail(userId: number | null | undefined, organizationId: number | null | undefined): Observable<CertificateExpirationDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Warning/GetCertificateExpirationDetail?";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCertificateExpirationDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCertificateExpirationDetail(<any>response_);
                } catch (e) {
                    return <Observable<CertificateExpirationDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CertificateExpirationDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCertificateExpirationDetail(response: HttpResponseBase): Observable<CertificateExpirationDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CertificateExpirationDetailOutput.fromJS(resultData200) : new CertificateExpirationDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CertificateExpirationDetailOutput>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param organizationId (optional) 
     * @return Success
     */
    getStockValidityPeriodDetail(userId: number | null | undefined, organizationId: number | null | undefined): Observable<GetStockValidityPeriodDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/Warning/GetStockValidityPeriodDetail?";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStockValidityPeriodDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStockValidityPeriodDetail(<any>response_);
                } catch (e) {
                    return <Observable<GetStockValidityPeriodDetailOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetStockValidityPeriodDetailOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetStockValidityPeriodDetail(response: HttpResponseBase): Observable<GetStockValidityPeriodDetailOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetStockValidityPeriodDetailOutput.fromJS(resultData200) : new GetStockValidityPeriodDetailOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetStockValidityPeriodDetailOutput>(<any>null);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLatestWebLogsOutput.fromJS(resultData200) : new GetLatestWebLogsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
            this.serverRootAddress = data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean | undefined;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean | undefined;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress: string;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): SendPasswordResetCodeInput {
        const json = this.toJSON();
        let result = new SendPasswordResetCodeInput();
        result.init(json);
        return result;
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId: number | undefined;
    resetCode: string;
    password: string;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.password = data["password"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }

    clone(): ResetPasswordInput {
        const json = this.toJSON();
        let result = new ResetPasswordInput();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordInput {
    userId: number | undefined;
    resetCode: string;
    password: string;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin: boolean | undefined;
    userName: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }

    clone(): ResetPasswordOutput {
        const json = this.toJSON();
        let result = new ResetPasswordOutput();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean | undefined;
    userName: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): SendEmailActivationLinkInput {
        const json = this.toJSON();
        let result = new SendEmailActivationLinkInput();
        result.init(json);
        return result;
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId: number;
    confirmationCode: string;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.confirmationCode = data["confirmationCode"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        return data; 
    }

    clone(): ActivateEmailInput {
        const json = this.toJSON();
        let result = new ActivateEmailInput();
        result.init(json);
        return result;
    }
}

export interface IActivateEmailInput {
    userId: number;
    confirmationCode: string;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId: number | undefined;
    userId: number | undefined;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): ImpersonateInput {
        const json = this.toJSON();
        let result = new ImpersonateInput();
        result.init(json);
        return result;
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.impersonationToken = data["impersonationToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): ImpersonateOutput {
        const json = this.toJSON();
        let result = new ImpersonateOutput();
        result.init(json);
        return result;
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number | undefined;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetTenantId = data["targetTenantId"];
            this.targetUserId = data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }

    clone(): SwitchToLinkedAccountInput {
        const json = this.toJSON();
        let result = new SwitchToLinkedAccountInput();
        result.init(json);
        return result;
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number | undefined;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.switchAccountToken = data["switchAccountToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): SwitchToLinkedAccountOutput {
        const json = this.toJSON();
        let result = new SwitchToLinkedAccountOutput();
        result.init(json);
        return result;
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class ChangeOrganizationInput implements IChangeOrganizationInput {
    organizationId: number | undefined;

    constructor(data?: IChangeOrganizationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationId = data["organizationId"];
        }
    }

    static fromJS(data: any): ChangeOrganizationInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeOrganizationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationId"] = this.organizationId;
        return data; 
    }

    clone(): ChangeOrganizationInput {
        const json = this.toJSON();
        let result = new ChangeOrganizationInput();
        result.init(json);
        return result;
    }
}

export interface IChangeOrganizationInput {
    organizationId: number | undefined;
}

export class GetApprovalRecordDetailDto implements IGetApprovalRecordDetailDto {
    eventSourceId: string | undefined;
    approvalWorkflowId: string | undefined;
    approvalWorkflowName: string | undefined;
    workflowType: GetApprovalRecordDetailDtoWorkflowType | undefined;
    applyOrganizationId: number | undefined;
    applyOrganizationName: string | undefined;
    approvalRoleId: number | undefined;
    approvalUserId: number | undefined;
    isApproval: boolean | undefined;
    approvalTime: Date | undefined;
    approvalResultState: GetApprovalRecordDetailDtoApprovalResultState | undefined;
    reason: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetApprovalRecordDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.eventSourceId = data["eventSourceId"];
            this.approvalWorkflowId = data["approvalWorkflowId"];
            this.approvalWorkflowName = data["approvalWorkflowName"];
            this.workflowType = data["workflowType"];
            this.applyOrganizationId = data["applyOrganizationId"];
            this.applyOrganizationName = data["applyOrganizationName"];
            this.approvalRoleId = data["approvalRoleId"];
            this.approvalUserId = data["approvalUserId"];
            this.isApproval = data["isApproval"];
            this.approvalTime = data["approvalTime"] ? new Date(data["approvalTime"].toString()) : <any>undefined;
            this.approvalResultState = data["approvalResultState"];
            this.reason = data["reason"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetApprovalRecordDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetApprovalRecordDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventSourceId"] = this.eventSourceId;
        data["approvalWorkflowId"] = this.approvalWorkflowId;
        data["approvalWorkflowName"] = this.approvalWorkflowName;
        data["workflowType"] = this.workflowType;
        data["applyOrganizationId"] = this.applyOrganizationId;
        data["applyOrganizationName"] = this.applyOrganizationName;
        data["approvalRoleId"] = this.approvalRoleId;
        data["approvalUserId"] = this.approvalUserId;
        data["isApproval"] = this.isApproval;
        data["approvalTime"] = this.approvalTime ? this.approvalTime.toISOString() : <any>undefined;
        data["approvalResultState"] = this.approvalResultState;
        data["reason"] = this.reason;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetApprovalRecordDetailDto {
        const json = this.toJSON();
        let result = new GetApprovalRecordDetailDto();
        result.init(json);
        return result;
    }
}

export interface IGetApprovalRecordDetailDto {
    eventSourceId: string | undefined;
    approvalWorkflowId: string | undefined;
    approvalWorkflowName: string | undefined;
    workflowType: GetApprovalRecordDetailDtoWorkflowType | undefined;
    applyOrganizationId: number | undefined;
    applyOrganizationName: string | undefined;
    approvalRoleId: number | undefined;
    approvalUserId: number | undefined;
    isApproval: boolean | undefined;
    approvalTime: Date | undefined;
    approvalResultState: GetApprovalRecordDetailDtoApprovalResultState | undefined;
    reason: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ApprovalActionInput implements IApprovalActionInput {
    eventSourceId: string | undefined;
    approvalResultState: ApprovalActionInputApprovalResultState | undefined;
    reason: string | undefined;

    constructor(data?: IApprovalActionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.eventSourceId = data["eventSourceId"];
            this.approvalResultState = data["approvalResultState"];
            this.reason = data["reason"];
        }
    }

    static fromJS(data: any): ApprovalActionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalActionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventSourceId"] = this.eventSourceId;
        data["approvalResultState"] = this.approvalResultState;
        data["reason"] = this.reason;
        return data; 
    }

    clone(): ApprovalActionInput {
        const json = this.toJSON();
        let result = new ApprovalActionInput();
        result.init(json);
        return result;
    }
}

export interface IApprovalActionInput {
    eventSourceId: string | undefined;
    approvalResultState: ApprovalActionInputApprovalResultState | undefined;
    reason: string | undefined;
}

export class GetApprovalWorkflowForEditOutput implements IGetApprovalWorkflowForEditOutput {
    name: string | undefined;
    workflowType: GetApprovalWorkflowForEditOutputWorkflowType | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    approvalWorkflowDetails: ApprovalWorkflowDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetApprovalWorkflowForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.workflowType = data["workflowType"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            if (data["approvalWorkflowDetails"] && data["approvalWorkflowDetails"].constructor === Array) {
                this.approvalWorkflowDetails = [];
                for (let item of data["approvalWorkflowDetails"])
                    this.approvalWorkflowDetails.push(ApprovalWorkflowDetailDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetApprovalWorkflowForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetApprovalWorkflowForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["workflowType"] = this.workflowType;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        if (this.approvalWorkflowDetails && this.approvalWorkflowDetails.constructor === Array) {
            data["approvalWorkflowDetails"] = [];
            for (let item of this.approvalWorkflowDetails)
                data["approvalWorkflowDetails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetApprovalWorkflowForEditOutput {
        const json = this.toJSON();
        let result = new GetApprovalWorkflowForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetApprovalWorkflowForEditOutput {
    name: string | undefined;
    workflowType: GetApprovalWorkflowForEditOutputWorkflowType | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    approvalWorkflowDetails: ApprovalWorkflowDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ApprovalWorkflowDetailDto implements IApprovalWorkflowDetailDto {
    approvalWorkflowId: string | undefined;
    roleId: number | undefined;
    roleName: string | undefined;
    sortRank: number | undefined;
    isAutoApproval: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IApprovalWorkflowDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.approvalWorkflowId = data["approvalWorkflowId"];
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.sortRank = data["sortRank"];
            this.isAutoApproval = data["isAutoApproval"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApprovalWorkflowDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalWorkflowDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvalWorkflowId"] = this.approvalWorkflowId;
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["sortRank"] = this.sortRank;
        data["isAutoApproval"] = this.isAutoApproval;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ApprovalWorkflowDetailDto {
        const json = this.toJSON();
        let result = new ApprovalWorkflowDetailDto();
        result.init(json);
        return result;
    }
}

export interface IApprovalWorkflowDetailDto {
    approvalWorkflowId: string | undefined;
    roleId: number | undefined;
    roleName: string | undefined;
    sortRank: number | undefined;
    isAutoApproval: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateOrUpdateApprovalWorkflowInput implements ICreateOrUpdateApprovalWorkflowInput {
    name: string | undefined;
    workflowType: CreateOrUpdateApprovalWorkflowInputWorkflowType | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    approvalWorkflowDetails: CreateOrUpdateApprovalWorkflowDetailInput[] | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateApprovalWorkflowInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.workflowType = data["workflowType"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            if (data["approvalWorkflowDetails"] && data["approvalWorkflowDetails"].constructor === Array) {
                this.approvalWorkflowDetails = [];
                for (let item of data["approvalWorkflowDetails"])
                    this.approvalWorkflowDetails.push(CreateOrUpdateApprovalWorkflowDetailInput.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateApprovalWorkflowInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateApprovalWorkflowInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["workflowType"] = this.workflowType;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        if (this.approvalWorkflowDetails && this.approvalWorkflowDetails.constructor === Array) {
            data["approvalWorkflowDetails"] = [];
            for (let item of this.approvalWorkflowDetails)
                data["approvalWorkflowDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateApprovalWorkflowInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateApprovalWorkflowInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateApprovalWorkflowInput {
    name: string | undefined;
    workflowType: CreateOrUpdateApprovalWorkflowInputWorkflowType | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    approvalWorkflowDetails: CreateOrUpdateApprovalWorkflowDetailInput[] | undefined;
    id: string | undefined;
}

export class CreateOrUpdateApprovalWorkflowDetailInput implements ICreateOrUpdateApprovalWorkflowDetailInput {
    roleId: number | undefined;
    roleName: string | undefined;
    sortRank: number | undefined;
    isAutoApproval: boolean | undefined;

    constructor(data?: ICreateOrUpdateApprovalWorkflowDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.sortRank = data["sortRank"];
            this.isAutoApproval = data["isAutoApproval"];
        }
    }

    static fromJS(data: any): CreateOrUpdateApprovalWorkflowDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateApprovalWorkflowDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["sortRank"] = this.sortRank;
        data["isAutoApproval"] = this.isAutoApproval;
        return data; 
    }

    clone(): CreateOrUpdateApprovalWorkflowDetailInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateApprovalWorkflowDetailInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateApprovalWorkflowDetailInput {
    roleId: number | undefined;
    roleName: string | undefined;
    sortRank: number | undefined;
    isAutoApproval: boolean | undefined;
}

export class PagedResultDtoOfGetApprovalWorkflowPaginationOutput implements IPagedResultDtoOfGetApprovalWorkflowPaginationOutput {
    totalCount: number | undefined;
    items: GetApprovalWorkflowPaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetApprovalWorkflowPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetApprovalWorkflowPaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetApprovalWorkflowPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetApprovalWorkflowPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetApprovalWorkflowPaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetApprovalWorkflowPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetApprovalWorkflowPaginationOutput {
    totalCount: number | undefined;
    items: GetApprovalWorkflowPaginationOutput[] | undefined;
}

export class GetApprovalWorkflowPaginationOutput implements IGetApprovalWorkflowPaginationOutput {
    name: string | undefined;
    workflowType: GetApprovalWorkflowPaginationOutputWorkflowType | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    approvalWorkflowDetails: ApprovalWorkflowDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetApprovalWorkflowPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.workflowType = data["workflowType"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            if (data["approvalWorkflowDetails"] && data["approvalWorkflowDetails"].constructor === Array) {
                this.approvalWorkflowDetails = [];
                for (let item of data["approvalWorkflowDetails"])
                    this.approvalWorkflowDetails.push(ApprovalWorkflowDetailDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetApprovalWorkflowPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetApprovalWorkflowPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["workflowType"] = this.workflowType;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        if (this.approvalWorkflowDetails && this.approvalWorkflowDetails.constructor === Array) {
            data["approvalWorkflowDetails"] = [];
            for (let item of this.approvalWorkflowDetails)
                data["approvalWorkflowDetails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetApprovalWorkflowPaginationOutput {
        const json = this.toJSON();
        let result = new GetApprovalWorkflowPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetApprovalWorkflowPaginationOutput {
    name: string | undefined;
    workflowType: GetApprovalWorkflowPaginationOutputWorkflowType | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    approvalWorkflowDetails: ApprovalWorkflowDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount: number | undefined;
    items: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfAuditLogListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number | undefined;
    items: AuditLogListDto[] | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: Date | undefined;
    executionDuration: number | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number | undefined;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? new Date(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }

    clone(): AuditLogListDto {
        const json = this.toJSON();
        let result = new AuditLogListDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: Date | undefined;
    executionDuration: number | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number | undefined;
}

export class FileDto implements IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }

    clone(): FileDto {
        const json = this.toJSON();
        let result = new FileDto();
        result.init(json);
        return result;
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;
}

export class NameValueDto implements INameValueDto {
    name: string | undefined;
    value: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): NameValueDto {
        const json = this.toJSON();
        let result = new NameValueDto();
        result.init(json);
        return result;
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount: number | undefined;
    items: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfEntityChangeListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number | undefined;
    items: EntityChangeListDto[] | undefined;
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: Date | undefined;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeListDtoChangeType | undefined;
    changeTypeName: string | undefined;
    entityChangeSetId: number | undefined;
    id: number | undefined;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.changeTime = data["changeTime"] ? new Date(data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = data["entityTypeFullName"];
            this.changeType = data["changeType"];
            this.changeTypeName = data["changeTypeName"];
            this.entityChangeSetId = data["entityChangeSetId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityChangeListDto {
        const json = this.toJSON();
        let result = new EntityChangeListDto();
        result.init(json);
        return result;
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: Date | undefined;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeListDtoChangeType | undefined;
    changeTypeName: string | undefined;
    entityChangeSetId: number | undefined;
    id: number | undefined;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId: number | undefined;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number | undefined;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.entityChangeId = data["entityChangeId"];
            this.newValue = data["newValue"];
            this.originalValue = data["originalValue"];
            this.propertyName = data["propertyName"];
            this.propertyTypeFullName = data["propertyTypeFullName"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityPropertyChangeDto {
        const json = this.toJSON();
        let result = new EntityPropertyChangeDto();
        result.init(json);
        return result;
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number | undefined;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number | undefined;
}

export class GetBarcodePrintRecordForEditOutput implements IGetBarcodePrintRecordForEditOutput {
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    printNumber: number | undefined;
    printUserId: number | undefined;
    printTime: Date | undefined;
    material: MaterialShareDto | undefined;
    barcodeInfos: BarcodeInfoDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetBarcodePrintRecordForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialPurchaseId = data["materialPurchaseId"];
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.printNumber = data["printNumber"];
            this.printUserId = data["printUserId"];
            this.printTime = data["printTime"] ? new Date(data["printTime"].toString()) : <any>undefined;
            this.material = data["material"] ? MaterialShareDto.fromJS(data["material"]) : <any>undefined;
            if (data["barcodeInfos"] && data["barcodeInfos"].constructor === Array) {
                this.barcodeInfos = [];
                for (let item of data["barcodeInfos"])
                    this.barcodeInfos.push(BarcodeInfoDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetBarcodePrintRecordForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBarcodePrintRecordForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialPurchaseId"] = this.materialPurchaseId;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["printNumber"] = this.printNumber;
        data["printUserId"] = this.printUserId;
        data["printTime"] = this.printTime ? this.printTime.toISOString() : <any>undefined;
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        if (this.barcodeInfos && this.barcodeInfos.constructor === Array) {
            data["barcodeInfos"] = [];
            for (let item of this.barcodeInfos)
                data["barcodeInfos"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetBarcodePrintRecordForEditOutput {
        const json = this.toJSON();
        let result = new GetBarcodePrintRecordForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetBarcodePrintRecordForEditOutput {
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    printNumber: number | undefined;
    printUserId: number | undefined;
    printTime: Date | undefined;
    material: MaterialShareDto | undefined;
    barcodeInfos: BarcodeInfoDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class MaterialShareDto implements IMaterialShareDto {
    systemMaterialCode: string | undefined;
    hospitalMaterialCode: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    specification: string | undefined;
    storageConditionId: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeId: string | undefined;
    temperatureRangeName: string | undefined;
    materialTypeId: string | undefined;
    materialTypeName: string | undefined;
    brandId: string | undefined;
    brandName: string | undefined;
    price: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    minUnitId: string | undefined;
    minUnitName: string | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    supplierId: string | undefined;
    supplierName: string | undefined;
    deliveryCompanyId: string | undefined;
    deliveryCompanyName: string | undefined;
    invoicingCompanyId: string | undefined;
    invoicingCompanyName: string | undefined;
    isRegistrationCertificate: boolean | undefined;
    registrationCertificateNo: string | undefined;
    registrationCertificateFilePath: string | undefined;
    expiryDate: Date | undefined;
    outBoxExpiryDate: number | undefined;
    instrumentId: string | undefined;
    instrumentName: string | undefined;
    arrivalDateSetting: string | undefined;
    isDisabled: boolean | undefined;
    disabledDate: Date | undefined;
    disabledReasonId: string | undefined;
    disabledReasonName: string | undefined;
    vendorMaterialCode: string | undefined;
    isStopPurchase: boolean | undefined;
    isAutoGenerateUniqueCode: boolean | undefined;
    isEnableVendorMaterialCode: boolean | undefined;
    isEnableOpenLabel: boolean | undefined;
    isHavePpCertificate: boolean | undefined;
    isPublicReagent: boolean | undefined;
    isCombinationReagent: boolean | undefined;
    combinationReagentProportion: string | undefined;
    isInventoryAlert: boolean | undefined;
    alertMaterialNumber: number | undefined;
    alertMinMaterialNumber: number | undefined;
    isAvailableDayAlert: boolean | undefined;
    alertAvailableDay: number | undefined;
    alertMinAvailableDay: number | undefined;
    isAutoPurchaseCalculate: boolean | undefined;
    monthPurchaseUpperLimit: number | undefined;
    isDefaultPurchaseNumber: boolean | undefined;
    defaultPurchaseNumber: number | undefined;
    unitConvertSetting: string | undefined;
    methodologyId: string | undefined;
    methodologyName: string | undefined;
    organizationMaterials: OrganizationMaterialDto[] | undefined;
    id: string | undefined;

    constructor(data?: IMaterialShareDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.systemMaterialCode = data["systemMaterialCode"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.name = data["name"];
            this.shortName = data["shortName"];
            this.specification = data["specification"];
            this.storageConditionId = data["storageConditionId"];
            this.storageConditionName = data["storageConditionName"];
            this.temperatureRangeId = data["temperatureRangeId"];
            this.temperatureRangeName = data["temperatureRangeName"];
            this.materialTypeId = data["materialTypeId"];
            this.materialTypeName = data["materialTypeName"];
            this.brandId = data["brandId"];
            this.brandName = data["brandName"];
            this.price = data["price"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.minUnitId = data["minUnitId"];
            this.minUnitName = data["minUnitName"];
            this.manufacturerId = data["manufacturerId"];
            this.manufacturerName = data["manufacturerName"];
            this.supplierId = data["supplierId"];
            this.supplierName = data["supplierName"];
            this.deliveryCompanyId = data["deliveryCompanyId"];
            this.deliveryCompanyName = data["deliveryCompanyName"];
            this.invoicingCompanyId = data["invoicingCompanyId"];
            this.invoicingCompanyName = data["invoicingCompanyName"];
            this.isRegistrationCertificate = data["isRegistrationCertificate"];
            this.registrationCertificateNo = data["registrationCertificateNo"];
            this.registrationCertificateFilePath = data["registrationCertificateFilePath"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.outBoxExpiryDate = data["outBoxExpiryDate"];
            this.instrumentId = data["instrumentId"];
            this.instrumentName = data["instrumentName"];
            this.arrivalDateSetting = data["arrivalDateSetting"];
            this.isDisabled = data["isDisabled"];
            this.disabledDate = data["disabledDate"] ? new Date(data["disabledDate"].toString()) : <any>undefined;
            this.disabledReasonId = data["disabledReasonId"];
            this.disabledReasonName = data["disabledReasonName"];
            this.vendorMaterialCode = data["vendorMaterialCode"];
            this.isStopPurchase = data["isStopPurchase"];
            this.isAutoGenerateUniqueCode = data["isAutoGenerateUniqueCode"];
            this.isEnableVendorMaterialCode = data["isEnableVendorMaterialCode"];
            this.isEnableOpenLabel = data["isEnableOpenLabel"];
            this.isHavePpCertificate = data["isHavePpCertificate"];
            this.isPublicReagent = data["isPublicReagent"];
            this.isCombinationReagent = data["isCombinationReagent"];
            this.combinationReagentProportion = data["combinationReagentProportion"];
            this.isInventoryAlert = data["isInventoryAlert"];
            this.alertMaterialNumber = data["alertMaterialNumber"];
            this.alertMinMaterialNumber = data["alertMinMaterialNumber"];
            this.isAvailableDayAlert = data["isAvailableDayAlert"];
            this.alertAvailableDay = data["alertAvailableDay"];
            this.alertMinAvailableDay = data["alertMinAvailableDay"];
            this.isAutoPurchaseCalculate = data["isAutoPurchaseCalculate"];
            this.monthPurchaseUpperLimit = data["monthPurchaseUpperLimit"];
            this.isDefaultPurchaseNumber = data["isDefaultPurchaseNumber"];
            this.defaultPurchaseNumber = data["defaultPurchaseNumber"];
            this.unitConvertSetting = data["unitConvertSetting"];
            this.methodologyId = data["methodologyId"];
            this.methodologyName = data["methodologyName"];
            if (data["organizationMaterials"] && data["organizationMaterials"].constructor === Array) {
                this.organizationMaterials = [];
                for (let item of data["organizationMaterials"])
                    this.organizationMaterials.push(OrganizationMaterialDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MaterialShareDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialShareDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemMaterialCode"] = this.systemMaterialCode;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["specification"] = this.specification;
        data["storageConditionId"] = this.storageConditionId;
        data["storageConditionName"] = this.storageConditionName;
        data["temperatureRangeId"] = this.temperatureRangeId;
        data["temperatureRangeName"] = this.temperatureRangeName;
        data["materialTypeId"] = this.materialTypeId;
        data["materialTypeName"] = this.materialTypeName;
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        data["price"] = this.price;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["minUnitId"] = this.minUnitId;
        data["minUnitName"] = this.minUnitName;
        data["manufacturerId"] = this.manufacturerId;
        data["manufacturerName"] = this.manufacturerName;
        data["supplierId"] = this.supplierId;
        data["supplierName"] = this.supplierName;
        data["deliveryCompanyId"] = this.deliveryCompanyId;
        data["deliveryCompanyName"] = this.deliveryCompanyName;
        data["invoicingCompanyId"] = this.invoicingCompanyId;
        data["invoicingCompanyName"] = this.invoicingCompanyName;
        data["isRegistrationCertificate"] = this.isRegistrationCertificate;
        data["registrationCertificateNo"] = this.registrationCertificateNo;
        data["registrationCertificateFilePath"] = this.registrationCertificateFilePath;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["outBoxExpiryDate"] = this.outBoxExpiryDate;
        data["instrumentId"] = this.instrumentId;
        data["instrumentName"] = this.instrumentName;
        data["arrivalDateSetting"] = this.arrivalDateSetting;
        data["isDisabled"] = this.isDisabled;
        data["disabledDate"] = this.disabledDate ? this.disabledDate.toISOString() : <any>undefined;
        data["disabledReasonId"] = this.disabledReasonId;
        data["disabledReasonName"] = this.disabledReasonName;
        data["vendorMaterialCode"] = this.vendorMaterialCode;
        data["isStopPurchase"] = this.isStopPurchase;
        data["isAutoGenerateUniqueCode"] = this.isAutoGenerateUniqueCode;
        data["isEnableVendorMaterialCode"] = this.isEnableVendorMaterialCode;
        data["isEnableOpenLabel"] = this.isEnableOpenLabel;
        data["isHavePpCertificate"] = this.isHavePpCertificate;
        data["isPublicReagent"] = this.isPublicReagent;
        data["isCombinationReagent"] = this.isCombinationReagent;
        data["combinationReagentProportion"] = this.combinationReagentProportion;
        data["isInventoryAlert"] = this.isInventoryAlert;
        data["alertMaterialNumber"] = this.alertMaterialNumber;
        data["alertMinMaterialNumber"] = this.alertMinMaterialNumber;
        data["isAvailableDayAlert"] = this.isAvailableDayAlert;
        data["alertAvailableDay"] = this.alertAvailableDay;
        data["alertMinAvailableDay"] = this.alertMinAvailableDay;
        data["isAutoPurchaseCalculate"] = this.isAutoPurchaseCalculate;
        data["monthPurchaseUpperLimit"] = this.monthPurchaseUpperLimit;
        data["isDefaultPurchaseNumber"] = this.isDefaultPurchaseNumber;
        data["defaultPurchaseNumber"] = this.defaultPurchaseNumber;
        data["unitConvertSetting"] = this.unitConvertSetting;
        data["methodologyId"] = this.methodologyId;
        data["methodologyName"] = this.methodologyName;
        if (this.organizationMaterials && this.organizationMaterials.constructor === Array) {
            data["organizationMaterials"] = [];
            for (let item of this.organizationMaterials)
                data["organizationMaterials"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialShareDto {
        const json = this.toJSON();
        let result = new MaterialShareDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialShareDto {
    systemMaterialCode: string | undefined;
    hospitalMaterialCode: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    specification: string | undefined;
    storageConditionId: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeId: string | undefined;
    temperatureRangeName: string | undefined;
    materialTypeId: string | undefined;
    materialTypeName: string | undefined;
    brandId: string | undefined;
    brandName: string | undefined;
    price: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    minUnitId: string | undefined;
    minUnitName: string | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    supplierId: string | undefined;
    supplierName: string | undefined;
    deliveryCompanyId: string | undefined;
    deliveryCompanyName: string | undefined;
    invoicingCompanyId: string | undefined;
    invoicingCompanyName: string | undefined;
    isRegistrationCertificate: boolean | undefined;
    registrationCertificateNo: string | undefined;
    registrationCertificateFilePath: string | undefined;
    expiryDate: Date | undefined;
    outBoxExpiryDate: number | undefined;
    instrumentId: string | undefined;
    instrumentName: string | undefined;
    arrivalDateSetting: string | undefined;
    isDisabled: boolean | undefined;
    disabledDate: Date | undefined;
    disabledReasonId: string | undefined;
    disabledReasonName: string | undefined;
    vendorMaterialCode: string | undefined;
    isStopPurchase: boolean | undefined;
    isAutoGenerateUniqueCode: boolean | undefined;
    isEnableVendorMaterialCode: boolean | undefined;
    isEnableOpenLabel: boolean | undefined;
    isHavePpCertificate: boolean | undefined;
    isPublicReagent: boolean | undefined;
    isCombinationReagent: boolean | undefined;
    combinationReagentProportion: string | undefined;
    isInventoryAlert: boolean | undefined;
    alertMaterialNumber: number | undefined;
    alertMinMaterialNumber: number | undefined;
    isAvailableDayAlert: boolean | undefined;
    alertAvailableDay: number | undefined;
    alertMinAvailableDay: number | undefined;
    isAutoPurchaseCalculate: boolean | undefined;
    monthPurchaseUpperLimit: number | undefined;
    isDefaultPurchaseNumber: boolean | undefined;
    defaultPurchaseNumber: number | undefined;
    unitConvertSetting: string | undefined;
    methodologyId: string | undefined;
    methodologyName: string | undefined;
    organizationMaterials: OrganizationMaterialDto[] | undefined;
    id: string | undefined;
}

export class BarcodeInfoDto implements IBarcodeInfoDto {
    barcodePrintRecordId: string | undefined;
    barcode: string | undefined;
    serialNumber: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBarcodeInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.barcodePrintRecordId = data["barcodePrintRecordId"];
            this.barcode = data["barcode"];
            this.serialNumber = data["serialNumber"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BarcodeInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new BarcodeInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["barcodePrintRecordId"] = this.barcodePrintRecordId;
        data["barcode"] = this.barcode;
        data["serialNumber"] = this.serialNumber;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BarcodeInfoDto {
        const json = this.toJSON();
        let result = new BarcodeInfoDto();
        result.init(json);
        return result;
    }
}

export interface IBarcodeInfoDto {
    barcodePrintRecordId: string | undefined;
    barcode: string | undefined;
    serialNumber: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class OrganizationMaterialDto implements IOrganizationMaterialDto {
    organizationId: number | undefined;
    organizationName: string | undefined;

    constructor(data?: IOrganizationMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
        }
    }

    static fromJS(data: any): OrganizationMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        return data; 
    }

    clone(): OrganizationMaterialDto {
        const json = this.toJSON();
        let result = new OrganizationMaterialDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationMaterialDto {
    organizationId: number | undefined;
    organizationName: string | undefined;
}

export class CreateOrUpdateBarcodePrintRecordInput implements ICreateOrUpdateBarcodePrintRecordInput {
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    printNumber: number | undefined;
    printUserId: number | undefined;
    printTime: Date | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateBarcodePrintRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialPurchaseId = data["materialPurchaseId"];
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.printNumber = data["printNumber"];
            this.printUserId = data["printUserId"];
            this.printTime = data["printTime"] ? new Date(data["printTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateBarcodePrintRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateBarcodePrintRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialPurchaseId"] = this.materialPurchaseId;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["printNumber"] = this.printNumber;
        data["printUserId"] = this.printUserId;
        data["printTime"] = this.printTime ? this.printTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateBarcodePrintRecordInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateBarcodePrintRecordInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateBarcodePrintRecordInput {
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    printNumber: number | undefined;
    printUserId: number | undefined;
    printTime: Date | undefined;
    id: string | undefined;
}

export class CreateBarcodePrintRecordsInput implements ICreateBarcodePrintRecordsInput {
    barcodePrintRecords: CreateOrUpdateBarcodePrintRecordInput[] | undefined;

    constructor(data?: ICreateBarcodePrintRecordsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["barcodePrintRecords"] && data["barcodePrintRecords"].constructor === Array) {
                this.barcodePrintRecords = [];
                for (let item of data["barcodePrintRecords"])
                    this.barcodePrintRecords.push(CreateOrUpdateBarcodePrintRecordInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateBarcodePrintRecordsInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBarcodePrintRecordsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.barcodePrintRecords && this.barcodePrintRecords.constructor === Array) {
            data["barcodePrintRecords"] = [];
            for (let item of this.barcodePrintRecords)
                data["barcodePrintRecords"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateBarcodePrintRecordsInput {
        const json = this.toJSON();
        let result = new CreateBarcodePrintRecordsInput();
        result.init(json);
        return result;
    }
}

export interface ICreateBarcodePrintRecordsInput {
    barcodePrintRecords: CreateOrUpdateBarcodePrintRecordInput[] | undefined;
}

export class CreateBarcodePrintRecordsOutput implements ICreateBarcodePrintRecordsOutput {
    barcodePrintRecords: BarcodePrintRecordDto[] | undefined;

    constructor(data?: ICreateBarcodePrintRecordsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["barcodePrintRecords"] && data["barcodePrintRecords"].constructor === Array) {
                this.barcodePrintRecords = [];
                for (let item of data["barcodePrintRecords"])
                    this.barcodePrintRecords.push(BarcodePrintRecordDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateBarcodePrintRecordsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBarcodePrintRecordsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.barcodePrintRecords && this.barcodePrintRecords.constructor === Array) {
            data["barcodePrintRecords"] = [];
            for (let item of this.barcodePrintRecords)
                data["barcodePrintRecords"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateBarcodePrintRecordsOutput {
        const json = this.toJSON();
        let result = new CreateBarcodePrintRecordsOutput();
        result.init(json);
        return result;
    }
}

export interface ICreateBarcodePrintRecordsOutput {
    barcodePrintRecords: BarcodePrintRecordDto[] | undefined;
}

export class BarcodePrintRecordDto implements IBarcodePrintRecordDto {
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    printNumber: number | undefined;
    printUserId: number | undefined;
    printTime: Date | undefined;
    material: MaterialShareDto | undefined;
    barcodeInfos: BarcodeInfoDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IBarcodePrintRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialPurchaseId = data["materialPurchaseId"];
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.printNumber = data["printNumber"];
            this.printUserId = data["printUserId"];
            this.printTime = data["printTime"] ? new Date(data["printTime"].toString()) : <any>undefined;
            this.material = data["material"] ? MaterialShareDto.fromJS(data["material"]) : <any>undefined;
            if (data["barcodeInfos"] && data["barcodeInfos"].constructor === Array) {
                this.barcodeInfos = [];
                for (let item of data["barcodeInfos"])
                    this.barcodeInfos.push(BarcodeInfoDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BarcodePrintRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new BarcodePrintRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialPurchaseId"] = this.materialPurchaseId;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["printNumber"] = this.printNumber;
        data["printUserId"] = this.printUserId;
        data["printTime"] = this.printTime ? this.printTime.toISOString() : <any>undefined;
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        if (this.barcodeInfos && this.barcodeInfos.constructor === Array) {
            data["barcodeInfos"] = [];
            for (let item of this.barcodeInfos)
                data["barcodeInfos"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BarcodePrintRecordDto {
        const json = this.toJSON();
        let result = new BarcodePrintRecordDto();
        result.init(json);
        return result;
    }
}

export interface IBarcodePrintRecordDto {
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    printNumber: number | undefined;
    printUserId: number | undefined;
    printTime: Date | undefined;
    material: MaterialShareDto | undefined;
    barcodeInfos: BarcodeInfoDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetBarcodePrintRecordPaginationOutput implements IPagedResultDtoOfGetBarcodePrintRecordPaginationOutput {
    totalCount: number | undefined;
    items: GetBarcodePrintRecordPaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBarcodePrintRecordPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetBarcodePrintRecordPaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBarcodePrintRecordPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBarcodePrintRecordPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetBarcodePrintRecordPaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetBarcodePrintRecordPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetBarcodePrintRecordPaginationOutput {
    totalCount: number | undefined;
    items: GetBarcodePrintRecordPaginationOutput[] | undefined;
}

export class GetBarcodePrintRecordPaginationOutput implements IGetBarcodePrintRecordPaginationOutput {
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    printNumber: number | undefined;
    printUserId: number | undefined;
    printTime: Date | undefined;
    material: MaterialShareDto | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetBarcodePrintRecordPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialPurchaseId = data["materialPurchaseId"];
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.printNumber = data["printNumber"];
            this.printUserId = data["printUserId"];
            this.printTime = data["printTime"] ? new Date(data["printTime"].toString()) : <any>undefined;
            this.material = data["material"] ? MaterialShareDto.fromJS(data["material"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetBarcodePrintRecordPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBarcodePrintRecordPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialPurchaseId"] = this.materialPurchaseId;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["printNumber"] = this.printNumber;
        data["printUserId"] = this.printUserId;
        data["printTime"] = this.printTime ? this.printTime.toISOString() : <any>undefined;
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetBarcodePrintRecordPaginationOutput {
        const json = this.toJSON();
        let result = new GetBarcodePrintRecordPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetBarcodePrintRecordPaginationOutput {
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    printNumber: number | undefined;
    printUserId: number | undefined;
    printTime: Date | undefined;
    material: MaterialShareDto | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetBarcodeInfoOutput implements IGetBarcodeInfoOutput {
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    printTime: Date | undefined;
    material: MaterialShareDto | undefined;
    materialPurchase: GetBarcodeInfoMaterialPurchaseDto | undefined;
    inventoryShareInfo: InventoryShareInfo | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetBarcodeInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialPurchaseId = data["materialPurchaseId"];
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.storageConditionName = data["storageConditionName"];
            this.temperatureRangeName = data["temperatureRangeName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.printTime = data["printTime"] ? new Date(data["printTime"].toString()) : <any>undefined;
            this.material = data["material"] ? MaterialShareDto.fromJS(data["material"]) : <any>undefined;
            this.materialPurchase = data["materialPurchase"] ? GetBarcodeInfoMaterialPurchaseDto.fromJS(data["materialPurchase"]) : <any>undefined;
            this.inventoryShareInfo = data["inventoryShareInfo"] ? InventoryShareInfo.fromJS(data["inventoryShareInfo"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetBarcodeInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBarcodeInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialPurchaseId"] = this.materialPurchaseId;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["storageConditionName"] = this.storageConditionName;
        data["temperatureRangeName"] = this.temperatureRangeName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["printTime"] = this.printTime ? this.printTime.toISOString() : <any>undefined;
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        data["materialPurchase"] = this.materialPurchase ? this.materialPurchase.toJSON() : <any>undefined;
        data["inventoryShareInfo"] = this.inventoryShareInfo ? this.inventoryShareInfo.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetBarcodeInfoOutput {
        const json = this.toJSON();
        let result = new GetBarcodeInfoOutput();
        result.init(json);
        return result;
    }
}

export interface IGetBarcodeInfoOutput {
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    printTime: Date | undefined;
    material: MaterialShareDto | undefined;
    materialPurchase: GetBarcodeInfoMaterialPurchaseDto | undefined;
    inventoryShareInfo: InventoryShareInfo | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetBarcodeInfoMaterialPurchaseDto implements IGetBarcodeInfoMaterialPurchaseDto {
    purchaseOrderNo: string | undefined;
    totalPrice: number | undefined;
    materialPurchaseState: GetBarcodeInfoMaterialPurchaseDtoMaterialPurchaseState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    materialPurchaseDetail: MaterialPurchaseDetailDto | undefined;
    id: string | undefined;

    constructor(data?: IGetBarcodeInfoMaterialPurchaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.purchaseOrderNo = data["purchaseOrderNo"];
            this.totalPrice = data["totalPrice"];
            this.materialPurchaseState = data["materialPurchaseState"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.applicantUserId = data["applicantUserId"];
            this.applicationTime = data["applicationTime"] ? new Date(data["applicationTime"].toString()) : <any>undefined;
            this.materialPurchaseDetail = data["materialPurchaseDetail"] ? MaterialPurchaseDetailDto.fromJS(data["materialPurchaseDetail"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetBarcodeInfoMaterialPurchaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBarcodeInfoMaterialPurchaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["totalPrice"] = this.totalPrice;
        data["materialPurchaseState"] = this.materialPurchaseState;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["applicantUserId"] = this.applicantUserId;
        data["applicationTime"] = this.applicationTime ? this.applicationTime.toISOString() : <any>undefined;
        data["materialPurchaseDetail"] = this.materialPurchaseDetail ? this.materialPurchaseDetail.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetBarcodeInfoMaterialPurchaseDto {
        const json = this.toJSON();
        let result = new GetBarcodeInfoMaterialPurchaseDto();
        result.init(json);
        return result;
    }
}

export interface IGetBarcodeInfoMaterialPurchaseDto {
    purchaseOrderNo: string | undefined;
    totalPrice: number | undefined;
    materialPurchaseState: GetBarcodeInfoMaterialPurchaseDtoMaterialPurchaseState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    materialPurchaseDetail: MaterialPurchaseDetailDto | undefined;
    id: string | undefined;
}

export class InventoryShareInfo implements IInventoryShareInfo {
    lastMonthInventoryNumber: number | undefined;
    thisMonthStorageNumber: number | undefined;
    thisMonthOutStorageNumber: number | undefined;
    stockNumber: number | undefined;

    constructor(data?: IInventoryShareInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lastMonthInventoryNumber = data["lastMonthInventoryNumber"];
            this.thisMonthStorageNumber = data["thisMonthStorageNumber"];
            this.thisMonthOutStorageNumber = data["thisMonthOutStorageNumber"];
            this.stockNumber = data["stockNumber"];
        }
    }

    static fromJS(data: any): InventoryShareInfo {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryShareInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastMonthInventoryNumber"] = this.lastMonthInventoryNumber;
        data["thisMonthStorageNumber"] = this.thisMonthStorageNumber;
        data["thisMonthOutStorageNumber"] = this.thisMonthOutStorageNumber;
        data["stockNumber"] = this.stockNumber;
        return data; 
    }

    clone(): InventoryShareInfo {
        const json = this.toJSON();
        let result = new InventoryShareInfo();
        result.init(json);
        return result;
    }
}

export interface IInventoryShareInfo {
    lastMonthInventoryNumber: number | undefined;
    thisMonthStorageNumber: number | undefined;
    thisMonthOutStorageNumber: number | undefined;
    stockNumber: number | undefined;
}

export class MaterialPurchaseDetailDto implements IMaterialPurchaseDetailDto {
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    price: number | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    remark: string | undefined;
    expectedArrivalDate: Date | undefined;
    arrivalState: MaterialPurchaseDetailDtoArrivalState | undefined;
    arrivalNumber: number | undefined;
    material: MaterialShareDto | undefined;
    organizationMaterialShareInfo: OrganizationMaterialShareInfo | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IMaterialPurchaseDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialPurchaseId = data["materialPurchaseId"];
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.price = data["price"];
            this.number = data["number"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.remark = data["remark"];
            this.expectedArrivalDate = data["expectedArrivalDate"] ? new Date(data["expectedArrivalDate"].toString()) : <any>undefined;
            this.arrivalState = data["arrivalState"];
            this.arrivalNumber = data["arrivalNumber"];
            this.material = data["material"] ? MaterialShareDto.fromJS(data["material"]) : <any>undefined;
            this.organizationMaterialShareInfo = data["organizationMaterialShareInfo"] ? OrganizationMaterialShareInfo.fromJS(data["organizationMaterialShareInfo"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MaterialPurchaseDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialPurchaseDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialPurchaseId"] = this.materialPurchaseId;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["price"] = this.price;
        data["number"] = this.number;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["remark"] = this.remark;
        data["expectedArrivalDate"] = this.expectedArrivalDate ? this.expectedArrivalDate.toISOString() : <any>undefined;
        data["arrivalState"] = this.arrivalState;
        data["arrivalNumber"] = this.arrivalNumber;
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        data["organizationMaterialShareInfo"] = this.organizationMaterialShareInfo ? this.organizationMaterialShareInfo.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialPurchaseDetailDto {
        const json = this.toJSON();
        let result = new MaterialPurchaseDetailDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialPurchaseDetailDto {
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    price: number | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    remark: string | undefined;
    expectedArrivalDate: Date | undefined;
    arrivalState: MaterialPurchaseDetailDtoArrivalState | undefined;
    arrivalNumber: number | undefined;
    material: MaterialShareDto | undefined;
    organizationMaterialShareInfo: OrganizationMaterialShareInfo | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class OrganizationMaterialShareInfo implements IOrganizationMaterialShareInfo {
    stock: number | undefined;
    thisMonthPurchaseNumber: number | undefined;
    thisMonthNotArrivedNumber: number | undefined;
    monthlyAverageUsageNumber: number | undefined;

    constructor(data?: IOrganizationMaterialShareInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.stock = data["stock"];
            this.thisMonthPurchaseNumber = data["thisMonthPurchaseNumber"];
            this.thisMonthNotArrivedNumber = data["thisMonthNotArrivedNumber"];
            this.monthlyAverageUsageNumber = data["monthlyAverageUsageNumber"];
        }
    }

    static fromJS(data: any): OrganizationMaterialShareInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationMaterialShareInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stock"] = this.stock;
        data["thisMonthPurchaseNumber"] = this.thisMonthPurchaseNumber;
        data["thisMonthNotArrivedNumber"] = this.thisMonthNotArrivedNumber;
        data["monthlyAverageUsageNumber"] = this.monthlyAverageUsageNumber;
        return data; 
    }

    clone(): OrganizationMaterialShareInfo {
        const json = this.toJSON();
        let result = new OrganizationMaterialShareInfo();
        result.init(json);
        return result;
    }
}

export interface IOrganizationMaterialShareInfo {
    stock: number | undefined;
    thisMonthPurchaseNumber: number | undefined;
    thisMonthNotArrivedNumber: number | undefined;
    monthlyAverageUsageNumber: number | undefined;
}

export class GetBarcodesOutput implements IGetBarcodesOutput {
    barcodeInfos: BarcodeInfo[] | undefined;

    constructor(data?: IGetBarcodesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["barcodeInfos"] && data["barcodeInfos"].constructor === Array) {
                this.barcodeInfos = [];
                for (let item of data["barcodeInfos"])
                    this.barcodeInfos.push(BarcodeInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetBarcodesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBarcodesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.barcodeInfos && this.barcodeInfos.constructor === Array) {
            data["barcodeInfos"] = [];
            for (let item of this.barcodeInfos)
                data["barcodeInfos"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetBarcodesOutput {
        const json = this.toJSON();
        let result = new GetBarcodesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetBarcodesOutput {
    barcodeInfos: BarcodeInfo[] | undefined;
}

export class BarcodeInfo implements IBarcodeInfo {
    barcode: string | undefined;
    isOutStorage: boolean | undefined;

    constructor(data?: IBarcodeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.barcode = data["barcode"];
            this.isOutStorage = data["isOutStorage"];
        }
    }

    static fromJS(data: any): BarcodeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BarcodeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["barcode"] = this.barcode;
        data["isOutStorage"] = this.isOutStorage;
        return data; 
    }

    clone(): BarcodeInfo {
        const json = this.toJSON();
        let result = new BarcodeInfo();
        result.init(json);
        return result;
    }
}

export interface IBarcodeInfo {
    barcode: string | undefined;
    isOutStorage: boolean | undefined;
}

export class ValidateBarcodeInput implements IValidateBarcodeInput {
    barcode: string | undefined;
    outInStorageType: ValidateBarcodeInputOutInStorageType | undefined;

    constructor(data?: IValidateBarcodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.barcode = data["barcode"];
            this.outInStorageType = data["outInStorageType"];
        }
    }

    static fromJS(data: any): ValidateBarcodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateBarcodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["barcode"] = this.barcode;
        data["outInStorageType"] = this.outInStorageType;
        return data; 
    }

    clone(): ValidateBarcodeInput {
        const json = this.toJSON();
        let result = new ValidateBarcodeInput();
        result.init(json);
        return result;
    }
}

export interface IValidateBarcodeInput {
    barcode: string | undefined;
    outInStorageType: ValidateBarcodeInputOutInStorageType | undefined;
}

export class ValidateBarcodeOutput implements IValidateBarcodeOutput {
    success: boolean | undefined;

    constructor(data?: IValidateBarcodeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.success = data["success"];
        }
    }

    static fromJS(data: any): ValidateBarcodeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateBarcodeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        return data; 
    }

    clone(): ValidateBarcodeOutput {
        const json = this.toJSON();
        let result = new ValidateBarcodeOutput();
        result.init(json);
        return result;
    }
}

export interface IValidateBarcodeOutput {
    success: boolean | undefined;
}

export class GetInventoryCodesOutput implements IGetInventoryCodesOutput {
    barcodes: string[] | undefined;

    constructor(data?: IGetInventoryCodesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["barcodes"] && data["barcodes"].constructor === Array) {
                this.barcodes = [];
                for (let item of data["barcodes"])
                    this.barcodes.push(item);
            }
        }
    }

    static fromJS(data: any): GetInventoryCodesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInventoryCodesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.barcodes && this.barcodes.constructor === Array) {
            data["barcodes"] = [];
            for (let item of this.barcodes)
                data["barcodes"].push(item);
        }
        return data; 
    }

    clone(): GetInventoryCodesOutput {
        const json = this.toJSON();
        let result = new GetInventoryCodesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetInventoryCodesOutput {
    barcodes: string[] | undefined;
}

export class GetEventBarcodesDto implements IGetEventBarcodesDto {
    barcode: string | undefined;
    materialId: string | undefined;
    materialName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;

    constructor(data?: IGetEventBarcodesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.barcode = data["barcode"];
            this.materialId = data["materialId"];
            this.materialName = data["materialName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEventBarcodesDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEventBarcodesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["barcode"] = this.barcode;
        data["materialId"] = this.materialId;
        data["materialName"] = this.materialName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): GetEventBarcodesDto {
        const json = this.toJSON();
        let result = new GetEventBarcodesDto();
        result.init(json);
        return result;
    }
}

export interface IGetEventBarcodesDto {
    barcode: string | undefined;
    materialId: string | undefined;
    materialName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
}

export class GetBrandForEditOutput implements IGetBrandForEditOutput {
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetBrandForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.shortName = data["shortName"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetBrandForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBrandForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetBrandForEditOutput {
        const json = this.toJSON();
        let result = new GetBrandForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetBrandForEditOutput {
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateOrUpdateBrandInput implements ICreateOrUpdateBrandInput {
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateBrandInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.shortName = data["shortName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateBrandInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateBrandInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateBrandInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateBrandInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateBrandInput {
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetBrandPaginationOutput implements IPagedResultDtoOfGetBrandPaginationOutput {
    totalCount: number | undefined;
    items: GetBrandPaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBrandPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetBrandPaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBrandPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBrandPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetBrandPaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetBrandPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetBrandPaginationOutput {
    totalCount: number | undefined;
    items: GetBrandPaginationOutput[] | undefined;
}

export class GetBrandPaginationOutput implements IGetBrandPaginationOutput {
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetBrandPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.shortName = data["shortName"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetBrandPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBrandPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetBrandPaginationOutput {
        const json = this.toJSON();
        let result = new GetBrandPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetBrandPaginationOutput {
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetBrandListOutput implements IGetBrandListOutput {
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    id: string | undefined;

    constructor(data?: IGetBrandListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.shortName = data["shortName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetBrandListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBrandListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetBrandListOutput {
        const json = this.toJSON();
        let result = new GetBrandListOutput();
        result.init(json);
        return result;
    }
}

export interface IGetBrandListOutput {
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    id: string | undefined;
}

export class BrandImportDto implements IBrandImportDto {
    rowNumber: number | undefined;
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    message: string | undefined;

    constructor(data?: IBrandImportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rowNumber = data["rowNumber"];
            this.code = data["code"];
            this.name = data["name"];
            this.shortName = data["shortName"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): BrandImportDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandImportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowNumber"] = this.rowNumber;
        data["code"] = this.code;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["message"] = this.message;
        return data; 
    }

    clone(): BrandImportDto {
        const json = this.toJSON();
        let result = new BrandImportDto();
        result.init(json);
        return result;
    }
}

export interface IBrandImportDto {
    rowNumber: number | undefined;
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    message: string | undefined;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfCacheDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfCacheDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;
}

export class CacheDto implements ICacheDto {
    name: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CacheDto {
        const json = this.toJSON();
        let result = new CacheDto();
        result.init(json);
        return result;
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDtoOfString {
        const json = this.toJSON();
        let result = new EntityDtoOfString();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime: Date | undefined;
    friends: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serverTime = data["serverTime"] ? new Date(data["serverTime"].toString()) : <any>undefined;
            if (data["friends"] && data["friends"].constructor === Array) {
                this.friends = [];
                for (let item of data["friends"])
                    this.friends.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        if (this.friends && this.friends.constructor === Array) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetUserChatFriendsWithSettingsOutput {
        const json = this.toJSON();
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: Date | undefined;
    friends: FriendDto[] | undefined;
}

export class FriendDto implements IFriendDto {
    friendUserId: number | undefined;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number | undefined;
    isOnline: boolean | undefined;
    state: FriendDtoState | undefined;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.friendUserId = data["friendUserId"];
            this.friendTenantId = data["friendTenantId"];
            this.friendUserName = data["friendUserName"];
            this.friendTenancyName = data["friendTenancyName"];
            this.friendProfilePictureId = data["friendProfilePictureId"];
            this.unreadMessageCount = data["unreadMessageCount"];
            this.isOnline = data["isOnline"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data; 
    }

    clone(): FriendDto {
        const json = this.toJSON();
        let result = new FriendDto();
        result.init(json);
        return result;
    }
}

export interface IFriendDto {
    friendUserId: number | undefined;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number | undefined;
    isOnline: boolean | undefined;
    state: FriendDtoState | undefined;
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfChatMessageDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfChatMessageDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;
}

export class ChatMessageDto implements IChatMessageDto {
    userId: number | undefined;
    tenantId: number | undefined;
    targetUserId: number | undefined;
    targetTenantId: number | undefined;
    side: ChatMessageDtoSide | undefined;
    readState: ChatMessageDtoReadState | undefined;
    receiverReadState: ChatMessageDtoReceiverReadState | undefined;
    message: string | undefined;
    creationTime: Date | undefined;
    sharedMessageId: string | undefined;
    id: number | undefined;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.targetUserId = data["targetUserId"];
            this.targetTenantId = data["targetTenantId"];
            this.side = data["side"];
            this.readState = data["readState"];
            this.receiverReadState = data["receiverReadState"];
            this.message = data["message"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = data["sharedMessageId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ChatMessageDto {
        const json = this.toJSON();
        let result = new ChatMessageDto();
        result.init(json);
        return result;
    }
}

export interface IChatMessageDto {
    userId: number | undefined;
    tenantId: number | undefined;
    targetUserId: number | undefined;
    targetTenantId: number | undefined;
    side: ChatMessageDtoSide | undefined;
    readState: ChatMessageDtoReadState | undefined;
    receiverReadState: ChatMessageDtoReceiverReadState | undefined;
    message: string | undefined;
    creationTime: Date | undefined;
    sharedMessageId: string | undefined;
    id: number | undefined;
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number | undefined;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): MarkAllUnreadMessagesOfUserAsReadInput {
        const json = this.toJSON();
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(json);
        return result;
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfSubscribableEditionComboboxItemDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isFree = data["isFree"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }

    clone(): SubscribableEditionComboboxItemDto {
        const json = this.toJSON();
        let result = new SubscribableEditionComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }

    clone(): FindUsersInput {
        const json = this.toJSON();
        let result = new FindUsersInput();
        result.init(json);
        return result;
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount: number | undefined;
    items: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfNameValueDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfNameValueDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number | undefined;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): GetDefaultEditionNameOutput {
        const json = this.toJSON();
        let result = new GetDefaultEditionNameOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class GetDataDictionaryForEditOutput implements IGetDataDictionaryForEditOutput {
    code: string | undefined;
    name: string | undefined;
    dictType: GetDataDictionaryForEditOutputDictType | undefined;
    dataDictionaryDetails: DataDictionaryDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetDataDictionaryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.dictType = data["dictType"];
            if (data["dataDictionaryDetails"] && data["dataDictionaryDetails"].constructor === Array) {
                this.dataDictionaryDetails = [];
                for (let item of data["dataDictionaryDetails"])
                    this.dataDictionaryDetails.push(DataDictionaryDetailDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetDataDictionaryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDataDictionaryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["dictType"] = this.dictType;
        if (this.dataDictionaryDetails && this.dataDictionaryDetails.constructor === Array) {
            data["dataDictionaryDetails"] = [];
            for (let item of this.dataDictionaryDetails)
                data["dataDictionaryDetails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetDataDictionaryForEditOutput {
        const json = this.toJSON();
        let result = new GetDataDictionaryForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDataDictionaryForEditOutput {
    code: string | undefined;
    name: string | undefined;
    dictType: GetDataDictionaryForEditOutputDictType | undefined;
    dataDictionaryDetails: DataDictionaryDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class DataDictionaryDetailDto implements IDataDictionaryDetailDto {
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    value: string | undefined;
    isDefault: boolean | undefined;
    sortRank: number | undefined;
    childDictType: DataDictionaryDetailDtoChildDictType | undefined;
    dataDictionaryId: string | undefined;
    isEnable: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IDataDictionaryDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.shortName = data["shortName"];
            this.value = data["value"];
            this.isDefault = data["isDefault"];
            this.sortRank = data["sortRank"];
            this.childDictType = data["childDictType"];
            this.dataDictionaryId = data["dataDictionaryId"];
            this.isEnable = data["isEnable"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DataDictionaryDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataDictionaryDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["value"] = this.value;
        data["isDefault"] = this.isDefault;
        data["sortRank"] = this.sortRank;
        data["childDictType"] = this.childDictType;
        data["dataDictionaryId"] = this.dataDictionaryId;
        data["isEnable"] = this.isEnable;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DataDictionaryDetailDto {
        const json = this.toJSON();
        let result = new DataDictionaryDetailDto();
        result.init(json);
        return result;
    }
}

export interface IDataDictionaryDetailDto {
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    value: string | undefined;
    isDefault: boolean | undefined;
    sortRank: number | undefined;
    childDictType: DataDictionaryDetailDtoChildDictType | undefined;
    dataDictionaryId: string | undefined;
    isEnable: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateOrUpdateDataDictionaryInput implements ICreateOrUpdateDataDictionaryInput {
    code: string | undefined;
    name: string | undefined;
    dictType: CreateOrUpdateDataDictionaryInputDictType | undefined;
    dataDictionaryDetails: CreateOrUpdateDataDictionaryDetailInput[] | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateDataDictionaryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.dictType = data["dictType"];
            if (data["dataDictionaryDetails"] && data["dataDictionaryDetails"].constructor === Array) {
                this.dataDictionaryDetails = [];
                for (let item of data["dataDictionaryDetails"])
                    this.dataDictionaryDetails.push(CreateOrUpdateDataDictionaryDetailInput.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateDataDictionaryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateDataDictionaryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["dictType"] = this.dictType;
        if (this.dataDictionaryDetails && this.dataDictionaryDetails.constructor === Array) {
            data["dataDictionaryDetails"] = [];
            for (let item of this.dataDictionaryDetails)
                data["dataDictionaryDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateDataDictionaryInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateDataDictionaryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateDataDictionaryInput {
    code: string | undefined;
    name: string | undefined;
    dictType: CreateOrUpdateDataDictionaryInputDictType | undefined;
    dataDictionaryDetails: CreateOrUpdateDataDictionaryDetailInput[] | undefined;
    id: string | undefined;
}

export class CreateOrUpdateDataDictionaryDetailInput implements ICreateOrUpdateDataDictionaryDetailInput {
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    value: string | undefined;
    isDefault: boolean | undefined;
    sortRank: number | undefined;
    childDictType: CreateOrUpdateDataDictionaryDetailInputChildDictType | undefined;
    isEnable: boolean | undefined;

    constructor(data?: ICreateOrUpdateDataDictionaryDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.shortName = data["shortName"];
            this.value = data["value"];
            this.isDefault = data["isDefault"];
            this.sortRank = data["sortRank"];
            this.childDictType = data["childDictType"];
            this.isEnable = data["isEnable"];
        }
    }

    static fromJS(data: any): CreateOrUpdateDataDictionaryDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateDataDictionaryDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["value"] = this.value;
        data["isDefault"] = this.isDefault;
        data["sortRank"] = this.sortRank;
        data["childDictType"] = this.childDictType;
        data["isEnable"] = this.isEnable;
        return data; 
    }

    clone(): CreateOrUpdateDataDictionaryDetailInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateDataDictionaryDetailInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateDataDictionaryDetailInput {
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    value: string | undefined;
    isDefault: boolean | undefined;
    sortRank: number | undefined;
    childDictType: CreateOrUpdateDataDictionaryDetailInputChildDictType | undefined;
    isEnable: boolean | undefined;
}

export class PagedResultDtoOfGeDataDictionaryPaginationOutput implements IPagedResultDtoOfGeDataDictionaryPaginationOutput {
    totalCount: number | undefined;
    items: GeDataDictionaryPaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGeDataDictionaryPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GeDataDictionaryPaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGeDataDictionaryPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGeDataDictionaryPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGeDataDictionaryPaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGeDataDictionaryPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGeDataDictionaryPaginationOutput {
    totalCount: number | undefined;
    items: GeDataDictionaryPaginationOutput[] | undefined;
}

export class GeDataDictionaryPaginationOutput implements IGeDataDictionaryPaginationOutput {
    code: string | undefined;
    name: string | undefined;
    dictType: GeDataDictionaryPaginationOutputDictType | undefined;
    dataDictionaryDetails: DataDictionaryDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGeDataDictionaryPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.dictType = data["dictType"];
            if (data["dataDictionaryDetails"] && data["dataDictionaryDetails"].constructor === Array) {
                this.dataDictionaryDetails = [];
                for (let item of data["dataDictionaryDetails"])
                    this.dataDictionaryDetails.push(DataDictionaryDetailDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GeDataDictionaryPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GeDataDictionaryPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["dictType"] = this.dictType;
        if (this.dataDictionaryDetails && this.dataDictionaryDetails.constructor === Array) {
            data["dataDictionaryDetails"] = [];
            for (let item of this.dataDictionaryDetails)
                data["dataDictionaryDetails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GeDataDictionaryPaginationOutput {
        const json = this.toJSON();
        let result = new GeDataDictionaryPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGeDataDictionaryPaginationOutput {
    code: string | undefined;
    name: string | undefined;
    dictType: GeDataDictionaryPaginationOutputDictType | undefined;
    dataDictionaryDetails: DataDictionaryDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class DataDictionaryDto implements IDataDictionaryDto {
    code: string | undefined;
    name: string | undefined;
    dictType: DataDictionaryDtoDictType | undefined;
    dataDictionaryDetails: DataDictionaryDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IDataDictionaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.dictType = data["dictType"];
            if (data["dataDictionaryDetails"] && data["dataDictionaryDetails"].constructor === Array) {
                this.dataDictionaryDetails = [];
                for (let item of data["dataDictionaryDetails"])
                    this.dataDictionaryDetails.push(DataDictionaryDetailDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DataDictionaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataDictionaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["dictType"] = this.dictType;
        if (this.dataDictionaryDetails && this.dataDictionaryDetails.constructor === Array) {
            data["dataDictionaryDetails"] = [];
            for (let item of this.dataDictionaryDetails)
                data["dataDictionaryDetails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DataDictionaryDto {
        const json = this.toJSON();
        let result = new DataDictionaryDto();
        result.init(json);
        return result;
    }
}

export interface IDataDictionaryDto {
    code: string | undefined;
    name: string | undefined;
    dictType: DataDictionaryDtoDictType | undefined;
    dataDictionaryDetails: DataDictionaryDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class DateToStringOutput implements IDateToStringOutput {
    dateString: string | undefined;

    constructor(data?: IDateToStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateString = data["dateString"];
        }
    }

    static fromJS(data: any): DateToStringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateToStringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateString"] = this.dateString;
        return data; 
    }

    clone(): DateToStringOutput {
        const json = this.toJSON();
        let result = new DateToStringOutput();
        result.init(json);
        return result;
    }
}

export interface IDateToStringOutput {
    dateString: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name: string | undefined;
    value: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): NameValueOfString {
        const json = this.toJSON();
        let result = new NameValueOfString();
        result.init(json);
        return result;
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class StringOutput implements IStringOutput {
    output: string | undefined;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.output = data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data; 
    }

    clone(): StringOutput {
        const json = this.toJSON();
        let result = new StringOutput();
        result.init(json);
        return result;
    }
}

export interface IStringOutput {
    output: string | undefined;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfEditionListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfEditionListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class EditionListDto implements IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    creationTime: Date | undefined;
    id: number | undefined;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): EditionListDto {
        const json = this.toJSON();
        let result = new EditionListDto();
        result.init(json);
        return result;
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    creationTime: Date | undefined;
    id: number | undefined;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition: EditionEditDto | undefined;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetEditionEditOutput {
        const json = this.toJSON();
        let result = new GetEditionEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto | undefined;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id: number | undefined;
    displayName: string;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }

    clone(): EditionEditDto {
        const json = this.toJSON();
        let result = new EditionEditDto();
        result.init(json);
        return result;
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto | undefined;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? FeatureInputTypeDto.fromJS(data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }

    clone(): FlatFeatureDto {
        const json = this.toJSON();
        let result = new FlatFeatureDto();
        result.init(json);
        return result;
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
    itemSource: LocalizableComboboxItemSourceDto | undefined;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
            this.itemSource = data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }

    clone(): FeatureInputTypeDto {
        const json = this.toJSON();
        let result = new FeatureInputTypeDto();
        result.init(json);
        return result;
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
    itemSource: LocalizableComboboxItemSourceDto | undefined;
}

export class IValueValidator implements IIValueValidator {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data; 
    }

    clone(): IValueValidator {
        const json = this.toJSON();
        let result = new IValueValidator();
        result.init(json);
        return result;
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): LocalizableComboboxItemSourceDto {
        const json = this.toJSON();
        let result = new LocalizableComboboxItemSourceDto();
        result.init(json);
        return result;
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }

    clone(): LocalizableComboboxItemDto {
        const json = this.toJSON();
        let result = new LocalizableComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class CreateOrUpdateEditionDto implements ICreateOrUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];

    constructor(data?: ICreateOrUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateOrUpdateEditionDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateEditionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class GetEnumDescriptionForEditOutput implements IGetEnumDescriptionForEditOutput {
    name: string | undefined;
    enumName: string | undefined;
    enumDescriptionItems: EnumDescriptionItemDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetEnumDescriptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.enumName = data["enumName"];
            if (data["enumDescriptionItems"] && data["enumDescriptionItems"].constructor === Array) {
                this.enumDescriptionItems = [];
                for (let item of data["enumDescriptionItems"])
                    this.enumDescriptionItems.push(EnumDescriptionItemDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetEnumDescriptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEnumDescriptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["enumName"] = this.enumName;
        if (this.enumDescriptionItems && this.enumDescriptionItems.constructor === Array) {
            data["enumDescriptionItems"] = [];
            for (let item of this.enumDescriptionItems)
                data["enumDescriptionItems"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetEnumDescriptionForEditOutput {
        const json = this.toJSON();
        let result = new GetEnumDescriptionForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetEnumDescriptionForEditOutput {
    name: string | undefined;
    enumName: string | undefined;
    enumDescriptionItems: EnumDescriptionItemDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class EnumDescriptionItemDto implements IEnumDescriptionItemDto {
    key: string | undefined;
    value: number | undefined;
    description: string | undefined;
    sortRank: number | undefined;
    enumDescriptionId: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IEnumDescriptionItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.value = data["value"];
            this.description = data["description"];
            this.sortRank = data["sortRank"];
            this.enumDescriptionId = data["enumDescriptionId"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EnumDescriptionItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnumDescriptionItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["description"] = this.description;
        data["sortRank"] = this.sortRank;
        data["enumDescriptionId"] = this.enumDescriptionId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): EnumDescriptionItemDto {
        const json = this.toJSON();
        let result = new EnumDescriptionItemDto();
        result.init(json);
        return result;
    }
}

export interface IEnumDescriptionItemDto {
    key: string | undefined;
    value: number | undefined;
    description: string | undefined;
    sortRank: number | undefined;
    enumDescriptionId: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateOrUpdateEnumDescriptionInput implements ICreateOrUpdateEnumDescriptionInput {
    name: string | undefined;
    enumName: string | undefined;
    enumDescriptionItems: CreateOrUpdateEnumDescriptionItemInput[] | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateEnumDescriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.enumName = data["enumName"];
            if (data["enumDescriptionItems"] && data["enumDescriptionItems"].constructor === Array) {
                this.enumDescriptionItems = [];
                for (let item of data["enumDescriptionItems"])
                    this.enumDescriptionItems.push(CreateOrUpdateEnumDescriptionItemInput.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateEnumDescriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateEnumDescriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["enumName"] = this.enumName;
        if (this.enumDescriptionItems && this.enumDescriptionItems.constructor === Array) {
            data["enumDescriptionItems"] = [];
            for (let item of this.enumDescriptionItems)
                data["enumDescriptionItems"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateEnumDescriptionInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateEnumDescriptionInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateEnumDescriptionInput {
    name: string | undefined;
    enumName: string | undefined;
    enumDescriptionItems: CreateOrUpdateEnumDescriptionItemInput[] | undefined;
    id: string | undefined;
}

export class CreateOrUpdateEnumDescriptionItemInput implements ICreateOrUpdateEnumDescriptionItemInput {
    key: string | undefined;
    value: number | undefined;
    description: string | undefined;
    sortRank: number | undefined;

    constructor(data?: ICreateOrUpdateEnumDescriptionItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.value = data["value"];
            this.description = data["description"];
            this.sortRank = data["sortRank"];
        }
    }

    static fromJS(data: any): CreateOrUpdateEnumDescriptionItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateEnumDescriptionItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["description"] = this.description;
        data["sortRank"] = this.sortRank;
        return data; 
    }

    clone(): CreateOrUpdateEnumDescriptionItemInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateEnumDescriptionItemInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateEnumDescriptionItemInput {
    key: string | undefined;
    value: number | undefined;
    description: string | undefined;
    sortRank: number | undefined;
}

export class PagedResultDtoOfGeEnumDescriptionPaginationOutput implements IPagedResultDtoOfGeEnumDescriptionPaginationOutput {
    totalCount: number | undefined;
    items: GeEnumDescriptionPaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGeEnumDescriptionPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GeEnumDescriptionPaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGeEnumDescriptionPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGeEnumDescriptionPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGeEnumDescriptionPaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGeEnumDescriptionPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGeEnumDescriptionPaginationOutput {
    totalCount: number | undefined;
    items: GeEnumDescriptionPaginationOutput[] | undefined;
}

export class GeEnumDescriptionPaginationOutput implements IGeEnumDescriptionPaginationOutput {
    name: string | undefined;
    enumName: string | undefined;
    enumDescriptionItems: EnumDescriptionItemDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGeEnumDescriptionPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.enumName = data["enumName"];
            if (data["enumDescriptionItems"] && data["enumDescriptionItems"].constructor === Array) {
                this.enumDescriptionItems = [];
                for (let item of data["enumDescriptionItems"])
                    this.enumDescriptionItems.push(EnumDescriptionItemDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GeEnumDescriptionPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GeEnumDescriptionPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["enumName"] = this.enumName;
        if (this.enumDescriptionItems && this.enumDescriptionItems.constructor === Array) {
            data["enumDescriptionItems"] = [];
            for (let item of this.enumDescriptionItems)
                data["enumDescriptionItems"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GeEnumDescriptionPaginationOutput {
        const json = this.toJSON();
        let result = new GeEnumDescriptionPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGeEnumDescriptionPaginationOutput {
    name: string | undefined;
    enumName: string | undefined;
    enumDescriptionItems: EnumDescriptionItemDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class EnumerationInfo implements IEnumerationInfo {
    name: string | undefined;
    enumName: string | undefined;
    enumItems: EnumItem[] | undefined;

    constructor(data?: IEnumerationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.enumName = data["enumName"];
            if (data["enumItems"] && data["enumItems"].constructor === Array) {
                this.enumItems = [];
                for (let item of data["enumItems"])
                    this.enumItems.push(EnumItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EnumerationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EnumerationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["enumName"] = this.enumName;
        if (this.enumItems && this.enumItems.constructor === Array) {
            data["enumItems"] = [];
            for (let item of this.enumItems)
                data["enumItems"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EnumerationInfo {
        const json = this.toJSON();
        let result = new EnumerationInfo();
        result.init(json);
        return result;
    }
}

export interface IEnumerationInfo {
    name: string | undefined;
    enumName: string | undefined;
    enumItems: EnumItem[] | undefined;
}

export class EnumItem implements IEnumItem {
    key: string | undefined;
    value: number | undefined;
    description: string | undefined;

    constructor(data?: IEnumItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.value = data["value"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): EnumItem {
        data = typeof data === 'object' ? data : {};
        let result = new EnumItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["description"] = this.description;
        return data; 
    }

    clone(): EnumItem {
        const json = this.toJSON();
        let result = new EnumItem();
        result.init(json);
        return result;
    }
}

export interface IEnumItem {
    key: string | undefined;
    value: number | undefined;
    description: string | undefined;
}

export class GetDashboardInfoOutput implements IGetDashboardInfoOutput {
    purchase: ThisMonthPurchaseDto | undefined;
    storage: ThisMonthStorageDto | undefined;
    outStorage: ThisMonthOutStorageDto | undefined;

    constructor(data?: IGetDashboardInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.purchase = data["purchase"] ? ThisMonthPurchaseDto.fromJS(data["purchase"]) : <any>undefined;
            this.storage = data["storage"] ? ThisMonthStorageDto.fromJS(data["storage"]) : <any>undefined;
            this.outStorage = data["outStorage"] ? ThisMonthOutStorageDto.fromJS(data["outStorage"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDashboardInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchase"] = this.purchase ? this.purchase.toJSON() : <any>undefined;
        data["storage"] = this.storage ? this.storage.toJSON() : <any>undefined;
        data["outStorage"] = this.outStorage ? this.outStorage.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDashboardInfoOutput {
        const json = this.toJSON();
        let result = new GetDashboardInfoOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDashboardInfoOutput {
    purchase: ThisMonthPurchaseDto | undefined;
    storage: ThisMonthStorageDto | undefined;
    outStorage: ThisMonthOutStorageDto | undefined;
}

export class ThisMonthPurchaseDto implements IThisMonthPurchaseDto {
    thisMonthPurchaseCount: number | undefined;
    datas: number[] | undefined;

    constructor(data?: IThisMonthPurchaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.thisMonthPurchaseCount = data["thisMonthPurchaseCount"];
            if (data["datas"] && data["datas"].constructor === Array) {
                this.datas = [];
                for (let item of data["datas"])
                    this.datas.push(item);
            }
        }
    }

    static fromJS(data: any): ThisMonthPurchaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThisMonthPurchaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thisMonthPurchaseCount"] = this.thisMonthPurchaseCount;
        if (this.datas && this.datas.constructor === Array) {
            data["datas"] = [];
            for (let item of this.datas)
                data["datas"].push(item);
        }
        return data; 
    }

    clone(): ThisMonthPurchaseDto {
        const json = this.toJSON();
        let result = new ThisMonthPurchaseDto();
        result.init(json);
        return result;
    }
}

export interface IThisMonthPurchaseDto {
    thisMonthPurchaseCount: number | undefined;
    datas: number[] | undefined;
}

export class ThisMonthStorageDto implements IThisMonthStorageDto {
    thisMonthStorageCount: number | undefined;
    datas: number[] | undefined;

    constructor(data?: IThisMonthStorageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.thisMonthStorageCount = data["thisMonthStorageCount"];
            if (data["datas"] && data["datas"].constructor === Array) {
                this.datas = [];
                for (let item of data["datas"])
                    this.datas.push(item);
            }
        }
    }

    static fromJS(data: any): ThisMonthStorageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThisMonthStorageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thisMonthStorageCount"] = this.thisMonthStorageCount;
        if (this.datas && this.datas.constructor === Array) {
            data["datas"] = [];
            for (let item of this.datas)
                data["datas"].push(item);
        }
        return data; 
    }

    clone(): ThisMonthStorageDto {
        const json = this.toJSON();
        let result = new ThisMonthStorageDto();
        result.init(json);
        return result;
    }
}

export interface IThisMonthStorageDto {
    thisMonthStorageCount: number | undefined;
    datas: number[] | undefined;
}

export class ThisMonthOutStorageDto implements IThisMonthOutStorageDto {
    thisMonthOutStorageCount: number | undefined;
    datas: number[] | undefined;

    constructor(data?: IThisMonthOutStorageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.thisMonthOutStorageCount = data["thisMonthOutStorageCount"];
            if (data["datas"] && data["datas"].constructor === Array) {
                this.datas = [];
                for (let item of data["datas"])
                    this.datas.push(item);
            }
        }
    }

    static fromJS(data: any): ThisMonthOutStorageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThisMonthOutStorageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thisMonthOutStorageCount"] = this.thisMonthOutStorageCount;
        if (this.datas && this.datas.constructor === Array) {
            data["datas"] = [];
            for (let item of this.datas)
                data["datas"].push(item);
        }
        return data; 
    }

    clone(): ThisMonthOutStorageDto {
        const json = this.toJSON();
        let result = new ThisMonthOutStorageDto();
        result.init(json);
        return result;
    }
}

export interface IThisMonthOutStorageDto {
    thisMonthOutStorageCount: number | undefined;
    datas: number[] | undefined;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): CreateFriendshipRequestInput {
        const json = this.toJSON();
        let result = new CreateFriendshipRequestInput();
        result.init(json);
        return result;
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data; 
    }

    clone(): CreateFriendshipRequestByUserNameInput {
        const json = this.toJSON();
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(json);
        return result;
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): BlockUserInput {
        const json = this.toJSON();
        let result = new BlockUserInput();
        result.init(json);
        return result;
    }
}

export interface IBlockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): UnblockUserInput {
        const json = this.toJSON();
        let result = new UnblockUserInput();
        result.init(json);
        return result;
    }
}

export interface IUnblockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): AcceptFriendshipRequestInput {
        const json = this.toJSON();
        let result = new AcceptFriendshipRequestInput();
        result.init(json);
        return result;
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class HostDashboardData implements IHostDashboardData {
    newTenantsCount: number | undefined;
    newSubscriptionAmount: number | undefined;
    dashboardPlaceholder1: number | undefined;
    dashboardPlaceholder2: number | undefined;
    incomeStatistics: IncomeStastistic[] | undefined;
    editionStatistics: TenantEdition[] | undefined;
    expiringTenants: ExpiringTenant[] | undefined;
    recentTenants: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount: number | undefined;
    maxRecentTenantsShownCount: number | undefined;
    subscriptionEndAlertDayCount: number | undefined;
    recentTenantsDayCount: number | undefined;
    subscriptionEndDateStart: Date | undefined;
    subscriptionEndDateEnd: Date | undefined;
    tenantCreationStartDate: Date | undefined;

    constructor(data?: IHostDashboardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newTenantsCount = data["newTenantsCount"];
            this.newSubscriptionAmount = data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = data["dashboardPlaceholder2"];
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [];
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics.push(IncomeStastistic.fromJS(item));
            }
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [];
                for (let item of data["editionStatistics"])
                    this.editionStatistics.push(TenantEdition.fromJS(item));
            }
            if (data["expiringTenants"] && data["expiringTenants"].constructor === Array) {
                this.expiringTenants = [];
                for (let item of data["expiringTenants"])
                    this.expiringTenants.push(ExpiringTenant.fromJS(item));
            }
            if (data["recentTenants"] && data["recentTenants"].constructor === Array) {
                this.recentTenants = [];
                for (let item of data["recentTenants"])
                    this.recentTenants.push(RecentTenant.fromJS(item));
            }
            this.maxExpiringTenantsShownCount = data["maxExpiringTenantsShownCount"];
            this.maxRecentTenantsShownCount = data["maxRecentTenantsShownCount"];
            this.subscriptionEndAlertDayCount = data["subscriptionEndAlertDayCount"];
            this.recentTenantsDayCount = data["recentTenantsDayCount"];
            this.subscriptionEndDateStart = data["subscriptionEndDateStart"] ? new Date(data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = data["subscriptionEndDateEnd"] ? new Date(data["subscriptionEndDateEnd"].toString()) : <any>undefined;
            this.tenantCreationStartDate = data["tenantCreationStartDate"] ? new Date(data["tenantCreationStartDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HostDashboardData {
        data = typeof data === 'object' ? data : {};
        let result = new HostDashboardData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        if (this.expiringTenants && this.expiringTenants.constructor === Array) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        if (this.recentTenants && this.recentTenants.constructor === Array) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): HostDashboardData {
        const json = this.toJSON();
        let result = new HostDashboardData();
        result.init(json);
        return result;
    }
}

export interface IHostDashboardData {
    newTenantsCount: number | undefined;
    newSubscriptionAmount: number | undefined;
    dashboardPlaceholder1: number | undefined;
    dashboardPlaceholder2: number | undefined;
    incomeStatistics: IncomeStastistic[] | undefined;
    editionStatistics: TenantEdition[] | undefined;
    expiringTenants: ExpiringTenant[] | undefined;
    recentTenants: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount: number | undefined;
    maxRecentTenantsShownCount: number | undefined;
    subscriptionEndAlertDayCount: number | undefined;
    recentTenantsDayCount: number | undefined;
    subscriptionEndDateStart: Date | undefined;
    subscriptionEndDateEnd: Date | undefined;
    tenantCreationStartDate: Date | undefined;
}

export class IncomeStastistic implements IIncomeStastistic {
    label: string | undefined;
    date: Date | undefined;
    amount: number | undefined;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }

    clone(): IncomeStastistic {
        const json = this.toJSON();
        let result = new IncomeStastistic();
        result.init(json);
        return result;
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: Date | undefined;
    amount: number | undefined;
}

export class TenantEdition implements ITenantEdition {
    label: string | undefined;
    value: number | undefined;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }

    clone(): TenantEdition {
        const json = this.toJSON();
        let result = new TenantEdition();
        result.init(json);
        return result;
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number | undefined;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number | undefined;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantName = data["tenantName"];
            this.remainingDayCount = data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data; 
    }

    clone(): ExpiringTenant {
        const json = this.toJSON();
        let result = new ExpiringTenant();
        result.init(json);
        return result;
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number | undefined;
}

export class RecentTenant implements IRecentTenant {
    id: number | undefined;
    name: string | undefined;
    creationTime: Date | undefined;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): RecentTenant {
        const json = this.toJSON();
        let result = new RecentTenant();
        result.init(json);
        return result;
    }
}

export interface IRecentTenant {
    id: number | undefined;
    name: string | undefined;
    creationTime: Date | undefined;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [];
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetIncomeStatisticsDataOutput {
        const json = this.toJSON();
        let result = new GetIncomeStatisticsDataOutput();
        result.init(json);
        return result;
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [];
                for (let item of data["editionStatistics"])
                    this.editionStatistics.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetEditionTenantStatisticsOutput {
        const json = this.toJSON();
        let result = new GetEditionTenantStatisticsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto | undefined;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? HostBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HostSettingsEditDto {
        const json = this.toJSON();
        let result = new HostSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timezone = data["timezone"];
            this.timezoneForComparison = data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data; 
    }

    clone(): GeneralSettingsEditDto {
        const json = this.toJSON();
        let result = new GeneralSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    smsVerificationEnabled: boolean | undefined;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = data["smsVerificationEnabled"];
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        return data; 
    }

    clone(): HostUserManagementSettingsEditDto {
        const json = this.toJSON();
        let result = new HostUserManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    smsVerificationEnabled: boolean | undefined;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }

    clone(): EmailSettingsEditDto {
        const json = this.toJSON();
        let result = new EmailSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredTenantActiveByDefault: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    defaultEditionId: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.defaultEditionId = data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }

    clone(): TenantManagementSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredTenantActiveByDefault: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    defaultEditionId: number | undefined;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings: boolean | undefined;
    passwordComplexity: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity: PasswordComplexitySetting | undefined;
    userLockOut: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin: TwoFactorLoginSettingsEditDto | undefined;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useDefaultPasswordComplexitySettings = data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }

    clone(): SecuritySettingsEditDto {
        const json = this.toJSON();
        let result = new SecuritySettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings: boolean | undefined;
    passwordComplexity: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity: PasswordComplexitySetting | undefined;
    userLockOut: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin: TwoFactorLoginSettingsEditDto | undefined;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data; 
    }

    clone(): HostBillingSettingsEditDto {
        const json = this.toJSON();
        let result = new HostBillingSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit: boolean | undefined;
    requireLowercase: boolean | undefined;
    requireNonAlphanumeric: boolean | undefined;
    requireUppercase: boolean | undefined;
    requiredLength: number | undefined;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireDigit = data["requireDigit"];
            this.requireLowercase = data["requireLowercase"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireUppercase = data["requireUppercase"];
            this.requiredLength = data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }

    clone(): PasswordComplexitySetting {
        const json = this.toJSON();
        let result = new PasswordComplexitySetting();
        result.init(json);
        return result;
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean | undefined;
    requireLowercase: boolean | undefined;
    requireNonAlphanumeric: boolean | undefined;
    requireUppercase: boolean | undefined;
    requiredLength: number | undefined;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout: number | undefined;
    defaultAccountLockoutSeconds: number | undefined;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }

    clone(): UserLockOutSettingsEditDto {
        const json = this.toJSON();
        let result = new UserLockOutSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout: number | undefined;
    defaultAccountLockoutSeconds: number | undefined;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean | undefined;
    isEnabled: boolean | undefined;
    isEmailProviderEnabled: boolean | undefined;
    isSmsProviderEnabled: boolean | undefined;
    isRememberBrowserEnabled: boolean | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabledForApplication = data["isEnabledForApplication"];
            this.isEnabled = data["isEnabled"];
            this.isEmailProviderEnabled = data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }

    clone(): TwoFactorLoginSettingsEditDto {
        const json = this.toJSON();
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean | undefined;
    isEnabled: boolean | undefined;
    isEmailProviderEnabled: boolean | undefined;
    isSmsProviderEnabled: boolean | undefined;
    isRememberBrowserEnabled: boolean | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): SendTestEmailInput {
        const json = this.toJSON();
        let result = new SendTestEmailInput();
        result.init(json);
        return result;
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class GetInspectionItemForEditOutput implements IGetInspectionItemForEditOutput {
    code: string | undefined;
    name: string | undefined;
    performanceVerificationType: GetInspectionItemForEditOutputPerformanceVerificationType | undefined;
    minReferenceRange: number | undefined;
    maxReferenceRange: number | undefined;
    referenceResult: string | undefined;
    referenceUnit: string | undefined;
    calculationFormula: string | undefined;
    deviation: number | undefined;
    remark: string | undefined;
    calculationType: GetInspectionItemForEditOutputCalculationType | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetInspectionItemForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.performanceVerificationType = data["performanceVerificationType"];
            this.minReferenceRange = data["minReferenceRange"];
            this.maxReferenceRange = data["maxReferenceRange"];
            this.referenceResult = data["referenceResult"];
            this.referenceUnit = data["referenceUnit"];
            this.calculationFormula = data["calculationFormula"];
            this.deviation = data["deviation"];
            this.remark = data["remark"];
            this.calculationType = data["calculationType"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetInspectionItemForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInspectionItemForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["performanceVerificationType"] = this.performanceVerificationType;
        data["minReferenceRange"] = this.minReferenceRange;
        data["maxReferenceRange"] = this.maxReferenceRange;
        data["referenceResult"] = this.referenceResult;
        data["referenceUnit"] = this.referenceUnit;
        data["calculationFormula"] = this.calculationFormula;
        data["deviation"] = this.deviation;
        data["remark"] = this.remark;
        data["calculationType"] = this.calculationType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetInspectionItemForEditOutput {
        const json = this.toJSON();
        let result = new GetInspectionItemForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetInspectionItemForEditOutput {
    code: string | undefined;
    name: string | undefined;
    performanceVerificationType: GetInspectionItemForEditOutputPerformanceVerificationType | undefined;
    minReferenceRange: number | undefined;
    maxReferenceRange: number | undefined;
    referenceResult: string | undefined;
    referenceUnit: string | undefined;
    calculationFormula: string | undefined;
    deviation: number | undefined;
    remark: string | undefined;
    calculationType: GetInspectionItemForEditOutputCalculationType | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateOrUpdateInspectionItemInput implements ICreateOrUpdateInspectionItemInput {
    code: string | undefined;
    name: string | undefined;
    performanceVerificationType: CreateOrUpdateInspectionItemInputPerformanceVerificationType | undefined;
    minReferenceRange: number | undefined;
    maxReferenceRange: number | undefined;
    referenceResult: string | undefined;
    referenceUnit: string | undefined;
    calculationFormula: string | undefined;
    deviation: number | undefined;
    remark: string | undefined;
    calculationType: CreateOrUpdateInspectionItemInputCalculationType | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateInspectionItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.performanceVerificationType = data["performanceVerificationType"];
            this.minReferenceRange = data["minReferenceRange"];
            this.maxReferenceRange = data["maxReferenceRange"];
            this.referenceResult = data["referenceResult"];
            this.referenceUnit = data["referenceUnit"];
            this.calculationFormula = data["calculationFormula"];
            this.deviation = data["deviation"];
            this.remark = data["remark"];
            this.calculationType = data["calculationType"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateInspectionItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateInspectionItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["performanceVerificationType"] = this.performanceVerificationType;
        data["minReferenceRange"] = this.minReferenceRange;
        data["maxReferenceRange"] = this.maxReferenceRange;
        data["referenceResult"] = this.referenceResult;
        data["referenceUnit"] = this.referenceUnit;
        data["calculationFormula"] = this.calculationFormula;
        data["deviation"] = this.deviation;
        data["remark"] = this.remark;
        data["calculationType"] = this.calculationType;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateInspectionItemInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateInspectionItemInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateInspectionItemInput {
    code: string | undefined;
    name: string | undefined;
    performanceVerificationType: CreateOrUpdateInspectionItemInputPerformanceVerificationType | undefined;
    minReferenceRange: number | undefined;
    maxReferenceRange: number | undefined;
    referenceResult: string | undefined;
    referenceUnit: string | undefined;
    calculationFormula: string | undefined;
    deviation: number | undefined;
    remark: string | undefined;
    calculationType: CreateOrUpdateInspectionItemInputCalculationType | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetInspectionItemPaginationOutput implements IPagedResultDtoOfGetInspectionItemPaginationOutput {
    totalCount: number | undefined;
    items: GetInspectionItemPaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetInspectionItemPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetInspectionItemPaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetInspectionItemPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetInspectionItemPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetInspectionItemPaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetInspectionItemPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetInspectionItemPaginationOutput {
    totalCount: number | undefined;
    items: GetInspectionItemPaginationOutput[] | undefined;
}

export class GetInspectionItemPaginationOutput implements IGetInspectionItemPaginationOutput {
    code: string | undefined;
    name: string | undefined;
    performanceVerificationType: GetInspectionItemPaginationOutputPerformanceVerificationType | undefined;
    minReferenceRange: number | undefined;
    maxReferenceRange: number | undefined;
    referenceResult: string | undefined;
    referenceUnit: string | undefined;
    calculationFormula: string | undefined;
    deviation: number | undefined;
    remark: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetInspectionItemPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.performanceVerificationType = data["performanceVerificationType"];
            this.minReferenceRange = data["minReferenceRange"];
            this.maxReferenceRange = data["maxReferenceRange"];
            this.referenceResult = data["referenceResult"];
            this.referenceUnit = data["referenceUnit"];
            this.calculationFormula = data["calculationFormula"];
            this.deviation = data["deviation"];
            this.remark = data["remark"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetInspectionItemPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInspectionItemPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["performanceVerificationType"] = this.performanceVerificationType;
        data["minReferenceRange"] = this.minReferenceRange;
        data["maxReferenceRange"] = this.maxReferenceRange;
        data["referenceResult"] = this.referenceResult;
        data["referenceUnit"] = this.referenceUnit;
        data["calculationFormula"] = this.calculationFormula;
        data["deviation"] = this.deviation;
        data["remark"] = this.remark;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetInspectionItemPaginationOutput {
        const json = this.toJSON();
        let result = new GetInspectionItemPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetInspectionItemPaginationOutput {
    code: string | undefined;
    name: string | undefined;
    performanceVerificationType: GetInspectionItemPaginationOutputPerformanceVerificationType | undefined;
    minReferenceRange: number | undefined;
    maxReferenceRange: number | undefined;
    referenceResult: string | undefined;
    referenceUnit: string | undefined;
    calculationFormula: string | undefined;
    deviation: number | undefined;
    remark: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetInspectionItemListOutput implements IGetInspectionItemListOutput {
    code: string | undefined;
    name: string | undefined;
    id: string | undefined;

    constructor(data?: IGetInspectionItemListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetInspectionItemListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInspectionItemListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetInspectionItemListOutput {
        const json = this.toJSON();
        let result = new GetInspectionItemListOutput();
        result.init(json);
        return result;
    }
}

export interface IGetInspectionItemListOutput {
    code: string | undefined;
    name: string | undefined;
    id: string | undefined;
}

export class InstallDto implements IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto | undefined;
    billInfo: HostBillingSettingsEditDto | undefined;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.connectionString = data["connectionString"];
            this.adminPassword = data["adminPassword"];
            this.webSiteUrl = data["webSiteUrl"];
            this.serverUrl = data["serverUrl"];
            this.defaultLanguage = data["defaultLanguage"];
            this.smtpSettings = data["smtpSettings"] ? EmailSettingsEditDto.fromJS(data["smtpSettings"]) : <any>undefined;
            this.billInfo = data["billInfo"] ? HostBillingSettingsEditDto.fromJS(data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data; 
    }

    clone(): InstallDto {
        const json = this.toJSON();
        let result = new InstallDto();
        result.init(json);
        return result;
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto | undefined;
    billInfo: HostBillingSettingsEditDto | undefined;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.webSiteUrl = data["webSiteUrl"];
            this.serverSiteUrl = data["serverSiteUrl"];
            if (data["languages"] && data["languages"].constructor === Array) {
                this.languages = [];
                for (let item of data["languages"])
                    this.languages.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (this.languages && this.languages.constructor === Array) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AppSettingsJsonDto {
        const json = this.toJSON();
        let result = new AppSettingsJsonDto();
        result.init(json);
        return result;
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;
}

export class NameValue implements INameValue {
    name: string | undefined;
    value: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): NameValue {
        const json = this.toJSON();
        let result = new NameValue();
        result.init(json);
        return result;
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist: boolean | undefined;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isDatabaseExist = data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data; 
    }

    clone(): CheckDatabaseOutput {
        const json = this.toJSON();
        let result = new CheckDatabaseOutput();
        result.init(json);
        return result;
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean | undefined;
}

export class GetInstrumentForEditOutput implements IGetInstrumentForEditOutput {
    code: string | undefined;
    name: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    shortName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetInstrumentForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.shortName = data["shortName"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetInstrumentForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInstrumentForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["shortName"] = this.shortName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetInstrumentForEditOutput {
        const json = this.toJSON();
        let result = new GetInstrumentForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetInstrumentForEditOutput {
    code: string | undefined;
    name: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    shortName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateOrUpdateInstrumentInput implements ICreateOrUpdateInstrumentInput {
    code: string | undefined;
    name: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    shortName: string | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateInstrumentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.shortName = data["shortName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateInstrumentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateInstrumentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["shortName"] = this.shortName;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateInstrumentInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateInstrumentInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateInstrumentInput {
    code: string | undefined;
    name: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    shortName: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetInstrumentPaginationOutput implements IPagedResultDtoOfGetInstrumentPaginationOutput {
    totalCount: number | undefined;
    items: GetInstrumentPaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetInstrumentPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetInstrumentPaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetInstrumentPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetInstrumentPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetInstrumentPaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetInstrumentPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetInstrumentPaginationOutput {
    totalCount: number | undefined;
    items: GetInstrumentPaginationOutput[] | undefined;
}

export class GetInstrumentPaginationOutput implements IGetInstrumentPaginationOutput {
    code: string | undefined;
    name: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    shortName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetInstrumentPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.shortName = data["shortName"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetInstrumentPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInstrumentPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["shortName"] = this.shortName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetInstrumentPaginationOutput {
        const json = this.toJSON();
        let result = new GetInstrumentPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetInstrumentPaginationOutput {
    code: string | undefined;
    name: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    shortName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetInstrumentListOutput implements IGetInstrumentListOutput {
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    id: string | undefined;

    constructor(data?: IGetInstrumentListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.shortName = data["shortName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetInstrumentListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInstrumentListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetInstrumentListOutput {
        const json = this.toJSON();
        let result = new GetInstrumentListOutput();
        result.init(json);
        return result;
    }
}

export interface IGetInstrumentListOutput {
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    id: string | undefined;
}

export class InvoiceDto implements IInvoiceDto {
    amount: number | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: Date | undefined;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.invoiceDate = data["invoiceDate"] ? new Date(data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = data["tenantLegalName"];
            if (data["tenantAddress"] && data["tenantAddress"].constructor === Array) {
                this.tenantAddress = [];
                for (let item of data["tenantAddress"])
                    this.tenantAddress.push(item);
            }
            this.tenantTaxNo = data["tenantTaxNo"];
            this.hostLegalName = data["hostLegalName"];
            if (data["hostAddress"] && data["hostAddress"].constructor === Array) {
                this.hostAddress = [];
                for (let item of data["hostAddress"])
                    this.hostAddress.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (this.tenantAddress && this.tenantAddress.constructor === Array) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (this.hostAddress && this.hostAddress.constructor === Array) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data; 
    }

    clone(): InvoiceDto {
        const json = this.toJSON();
        let result = new InvoiceDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDto {
    amount: number | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: Date | undefined;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId: number | undefined;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionPaymentId = data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data; 
    }

    clone(): CreateInvoiceDto {
        const json = this.toJSON();
        let result = new CreateInvoiceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number | undefined;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultLanguageName = data["defaultLanguageName"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetLanguagesOutput {
        const json = this.toJSON();
        let result = new GetLanguagesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDisabled = data["isDisabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ApplicationLanguageListDto {
        const json = this.toJSON();
        let result = new ApplicationLanguageListDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto | undefined;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : <any>undefined;
            if (data["languageNames"] && data["languageNames"].constructor === Array) {
                this.languageNames = [];
                for (let item of data["languageNames"])
                    this.languageNames.push(ComboboxItemDto.fromJS(item));
            }
            if (data["flags"] && data["flags"].constructor === Array) {
                this.flags = [];
                for (let item of data["flags"])
                    this.flags.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (this.languageNames && this.languageNames.constructor === Array) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (this.flags && this.flags.constructor === Array) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetLanguageForEditOutput {
        const json = this.toJSON();
        let result = new GetLanguageForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto | undefined;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean | undefined;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): ApplicationLanguageEditDto {
        const json = this.toJSON();
        let result = new ApplicationLanguageEditDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean | undefined;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }

    clone(): ComboboxItemDto {
        const json = this.toJSON();
        let result = new ComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateLanguageInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateLanguageInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): SetDefaultLanguageInput {
        const json = this.toJSON();
        let result = new SetDefaultLanguageInput();
        result.init(json);
        return result;
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount: number | undefined;
    items: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfLanguageTextListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number | undefined;
    items: LanguageTextListDto[] | undefined;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.baseValue = data["baseValue"];
            this.targetValue = data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }

    clone(): LanguageTextListDto {
        const json = this.toJSON();
        let result = new LanguageTextListDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
            this.sourceName = data["sourceName"];
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }

    clone(): UpdateLanguageTextInput {
        const json = this.toJSON();
        let result = new UpdateLanguageTextInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class GetMaterialForEditOutput implements IGetMaterialForEditOutput {
    systemMaterialCode: string | undefined;
    hospitalMaterialCode: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    specification: string | undefined;
    storageConditionId: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeId: string | undefined;
    temperatureRangeName: string | undefined;
    materialTypeId: string | undefined;
    materialTypeName: string | undefined;
    brandId: string | undefined;
    brandName: string | undefined;
    price: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    minUnitId: string | undefined;
    minUnitName: string | undefined;
    unitConvertRate: number | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    supplierId: string | undefined;
    supplierName: string | undefined;
    deliveryCompanyId: string | undefined;
    deliveryCompanyName: string | undefined;
    invoicingCompanyId: string | undefined;
    invoicingCompanyName: string | undefined;
    isRegistrationCertificate: boolean | undefined;
    registrationCertificateNo: string | undefined;
    registrationCertificateFilePath: string | undefined;
    expiryDate: Date | undefined;
    outBoxExpiryDate: number | undefined;
    instrumentId: string | undefined;
    instrumentName: string | undefined;
    arrivalDateSetting: string | undefined;
    isDisabled: boolean | undefined;
    disabledDate: Date | undefined;
    disabledReasonId: string | undefined;
    disabledReasonName: string | undefined;
    vendorMaterialCode: string | undefined;
    isStopPurchase: boolean | undefined;
    isAutoGenerateUniqueCode: boolean | undefined;
    isEnableVendorMaterialCode: boolean | undefined;
    isEnableOpenLabel: boolean | undefined;
    isHavePpCertificate: boolean | undefined;
    isPublicReagent: boolean | undefined;
    isCombinationReagent: boolean | undefined;
    combinationReagentProportion: string | undefined;
    isInventoryAlert: boolean | undefined;
    alertMaterialNumber: number | undefined;
    alertMinMaterialNumber: number | undefined;
    isAvailableDayAlert: boolean | undefined;
    alertAvailableDay: number | undefined;
    alertMinAvailableDay: number | undefined;
    isAutoPurchaseCalculate: boolean | undefined;
    monthPurchaseUpperLimit: number | undefined;
    isDefaultPurchaseNumber: boolean | undefined;
    defaultPurchaseNumber: number | undefined;
    unitConvertSetting: string | undefined;
    isPerformanceVerification: boolean | undefined;
    methodologyId: string | undefined;
    methodologyName: string | undefined;
    materialOutInStorages: MaterialOutInStorageDto[] | undefined;
    organizationMaterials: OrganizationMaterialDto[] | undefined;
    performanceVerificationMaterials: PerformanceVerificationMaterialDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetMaterialForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.systemMaterialCode = data["systemMaterialCode"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.name = data["name"];
            this.shortName = data["shortName"];
            this.specification = data["specification"];
            this.storageConditionId = data["storageConditionId"];
            this.storageConditionName = data["storageConditionName"];
            this.temperatureRangeId = data["temperatureRangeId"];
            this.temperatureRangeName = data["temperatureRangeName"];
            this.materialTypeId = data["materialTypeId"];
            this.materialTypeName = data["materialTypeName"];
            this.brandId = data["brandId"];
            this.brandName = data["brandName"];
            this.price = data["price"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.minUnitId = data["minUnitId"];
            this.minUnitName = data["minUnitName"];
            this.unitConvertRate = data["unitConvertRate"];
            this.manufacturerId = data["manufacturerId"];
            this.manufacturerName = data["manufacturerName"];
            this.supplierId = data["supplierId"];
            this.supplierName = data["supplierName"];
            this.deliveryCompanyId = data["deliveryCompanyId"];
            this.deliveryCompanyName = data["deliveryCompanyName"];
            this.invoicingCompanyId = data["invoicingCompanyId"];
            this.invoicingCompanyName = data["invoicingCompanyName"];
            this.isRegistrationCertificate = data["isRegistrationCertificate"];
            this.registrationCertificateNo = data["registrationCertificateNo"];
            this.registrationCertificateFilePath = data["registrationCertificateFilePath"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.outBoxExpiryDate = data["outBoxExpiryDate"];
            this.instrumentId = data["instrumentId"];
            this.instrumentName = data["instrumentName"];
            this.arrivalDateSetting = data["arrivalDateSetting"];
            this.isDisabled = data["isDisabled"];
            this.disabledDate = data["disabledDate"] ? new Date(data["disabledDate"].toString()) : <any>undefined;
            this.disabledReasonId = data["disabledReasonId"];
            this.disabledReasonName = data["disabledReasonName"];
            this.vendorMaterialCode = data["vendorMaterialCode"];
            this.isStopPurchase = data["isStopPurchase"];
            this.isAutoGenerateUniqueCode = data["isAutoGenerateUniqueCode"];
            this.isEnableVendorMaterialCode = data["isEnableVendorMaterialCode"];
            this.isEnableOpenLabel = data["isEnableOpenLabel"];
            this.isHavePpCertificate = data["isHavePpCertificate"];
            this.isPublicReagent = data["isPublicReagent"];
            this.isCombinationReagent = data["isCombinationReagent"];
            this.combinationReagentProportion = data["combinationReagentProportion"];
            this.isInventoryAlert = data["isInventoryAlert"];
            this.alertMaterialNumber = data["alertMaterialNumber"];
            this.alertMinMaterialNumber = data["alertMinMaterialNumber"];
            this.isAvailableDayAlert = data["isAvailableDayAlert"];
            this.alertAvailableDay = data["alertAvailableDay"];
            this.alertMinAvailableDay = data["alertMinAvailableDay"];
            this.isAutoPurchaseCalculate = data["isAutoPurchaseCalculate"];
            this.monthPurchaseUpperLimit = data["monthPurchaseUpperLimit"];
            this.isDefaultPurchaseNumber = data["isDefaultPurchaseNumber"];
            this.defaultPurchaseNumber = data["defaultPurchaseNumber"];
            this.unitConvertSetting = data["unitConvertSetting"];
            this.isPerformanceVerification = data["isPerformanceVerification"];
            this.methodologyId = data["methodologyId"];
            this.methodologyName = data["methodologyName"];
            if (data["materialOutInStorages"] && data["materialOutInStorages"].constructor === Array) {
                this.materialOutInStorages = [];
                for (let item of data["materialOutInStorages"])
                    this.materialOutInStorages.push(MaterialOutInStorageDto.fromJS(item));
            }
            if (data["organizationMaterials"] && data["organizationMaterials"].constructor === Array) {
                this.organizationMaterials = [];
                for (let item of data["organizationMaterials"])
                    this.organizationMaterials.push(OrganizationMaterialDto.fromJS(item));
            }
            if (data["performanceVerificationMaterials"] && data["performanceVerificationMaterials"].constructor === Array) {
                this.performanceVerificationMaterials = [];
                for (let item of data["performanceVerificationMaterials"])
                    this.performanceVerificationMaterials.push(PerformanceVerificationMaterialDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetMaterialForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemMaterialCode"] = this.systemMaterialCode;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["specification"] = this.specification;
        data["storageConditionId"] = this.storageConditionId;
        data["storageConditionName"] = this.storageConditionName;
        data["temperatureRangeId"] = this.temperatureRangeId;
        data["temperatureRangeName"] = this.temperatureRangeName;
        data["materialTypeId"] = this.materialTypeId;
        data["materialTypeName"] = this.materialTypeName;
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        data["price"] = this.price;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["minUnitId"] = this.minUnitId;
        data["minUnitName"] = this.minUnitName;
        data["unitConvertRate"] = this.unitConvertRate;
        data["manufacturerId"] = this.manufacturerId;
        data["manufacturerName"] = this.manufacturerName;
        data["supplierId"] = this.supplierId;
        data["supplierName"] = this.supplierName;
        data["deliveryCompanyId"] = this.deliveryCompanyId;
        data["deliveryCompanyName"] = this.deliveryCompanyName;
        data["invoicingCompanyId"] = this.invoicingCompanyId;
        data["invoicingCompanyName"] = this.invoicingCompanyName;
        data["isRegistrationCertificate"] = this.isRegistrationCertificate;
        data["registrationCertificateNo"] = this.registrationCertificateNo;
        data["registrationCertificateFilePath"] = this.registrationCertificateFilePath;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["outBoxExpiryDate"] = this.outBoxExpiryDate;
        data["instrumentId"] = this.instrumentId;
        data["instrumentName"] = this.instrumentName;
        data["arrivalDateSetting"] = this.arrivalDateSetting;
        data["isDisabled"] = this.isDisabled;
        data["disabledDate"] = this.disabledDate ? this.disabledDate.toISOString() : <any>undefined;
        data["disabledReasonId"] = this.disabledReasonId;
        data["disabledReasonName"] = this.disabledReasonName;
        data["vendorMaterialCode"] = this.vendorMaterialCode;
        data["isStopPurchase"] = this.isStopPurchase;
        data["isAutoGenerateUniqueCode"] = this.isAutoGenerateUniqueCode;
        data["isEnableVendorMaterialCode"] = this.isEnableVendorMaterialCode;
        data["isEnableOpenLabel"] = this.isEnableOpenLabel;
        data["isHavePpCertificate"] = this.isHavePpCertificate;
        data["isPublicReagent"] = this.isPublicReagent;
        data["isCombinationReagent"] = this.isCombinationReagent;
        data["combinationReagentProportion"] = this.combinationReagentProportion;
        data["isInventoryAlert"] = this.isInventoryAlert;
        data["alertMaterialNumber"] = this.alertMaterialNumber;
        data["alertMinMaterialNumber"] = this.alertMinMaterialNumber;
        data["isAvailableDayAlert"] = this.isAvailableDayAlert;
        data["alertAvailableDay"] = this.alertAvailableDay;
        data["alertMinAvailableDay"] = this.alertMinAvailableDay;
        data["isAutoPurchaseCalculate"] = this.isAutoPurchaseCalculate;
        data["monthPurchaseUpperLimit"] = this.monthPurchaseUpperLimit;
        data["isDefaultPurchaseNumber"] = this.isDefaultPurchaseNumber;
        data["defaultPurchaseNumber"] = this.defaultPurchaseNumber;
        data["unitConvertSetting"] = this.unitConvertSetting;
        data["isPerformanceVerification"] = this.isPerformanceVerification;
        data["methodologyId"] = this.methodologyId;
        data["methodologyName"] = this.methodologyName;
        if (this.materialOutInStorages && this.materialOutInStorages.constructor === Array) {
            data["materialOutInStorages"] = [];
            for (let item of this.materialOutInStorages)
                data["materialOutInStorages"].push(item.toJSON());
        }
        if (this.organizationMaterials && this.organizationMaterials.constructor === Array) {
            data["organizationMaterials"] = [];
            for (let item of this.organizationMaterials)
                data["organizationMaterials"].push(item.toJSON());
        }
        if (this.performanceVerificationMaterials && this.performanceVerificationMaterials.constructor === Array) {
            data["performanceVerificationMaterials"] = [];
            for (let item of this.performanceVerificationMaterials)
                data["performanceVerificationMaterials"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetMaterialForEditOutput {
        const json = this.toJSON();
        let result = new GetMaterialForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMaterialForEditOutput {
    systemMaterialCode: string | undefined;
    hospitalMaterialCode: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    specification: string | undefined;
    storageConditionId: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeId: string | undefined;
    temperatureRangeName: string | undefined;
    materialTypeId: string | undefined;
    materialTypeName: string | undefined;
    brandId: string | undefined;
    brandName: string | undefined;
    price: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    minUnitId: string | undefined;
    minUnitName: string | undefined;
    unitConvertRate: number | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    supplierId: string | undefined;
    supplierName: string | undefined;
    deliveryCompanyId: string | undefined;
    deliveryCompanyName: string | undefined;
    invoicingCompanyId: string | undefined;
    invoicingCompanyName: string | undefined;
    isRegistrationCertificate: boolean | undefined;
    registrationCertificateNo: string | undefined;
    registrationCertificateFilePath: string | undefined;
    expiryDate: Date | undefined;
    outBoxExpiryDate: number | undefined;
    instrumentId: string | undefined;
    instrumentName: string | undefined;
    arrivalDateSetting: string | undefined;
    isDisabled: boolean | undefined;
    disabledDate: Date | undefined;
    disabledReasonId: string | undefined;
    disabledReasonName: string | undefined;
    vendorMaterialCode: string | undefined;
    isStopPurchase: boolean | undefined;
    isAutoGenerateUniqueCode: boolean | undefined;
    isEnableVendorMaterialCode: boolean | undefined;
    isEnableOpenLabel: boolean | undefined;
    isHavePpCertificate: boolean | undefined;
    isPublicReagent: boolean | undefined;
    isCombinationReagent: boolean | undefined;
    combinationReagentProportion: string | undefined;
    isInventoryAlert: boolean | undefined;
    alertMaterialNumber: number | undefined;
    alertMinMaterialNumber: number | undefined;
    isAvailableDayAlert: boolean | undefined;
    alertAvailableDay: number | undefined;
    alertMinAvailableDay: number | undefined;
    isAutoPurchaseCalculate: boolean | undefined;
    monthPurchaseUpperLimit: number | undefined;
    isDefaultPurchaseNumber: boolean | undefined;
    defaultPurchaseNumber: number | undefined;
    unitConvertSetting: string | undefined;
    isPerformanceVerification: boolean | undefined;
    methodologyId: string | undefined;
    methodologyName: string | undefined;
    materialOutInStorages: MaterialOutInStorageDto[] | undefined;
    organizationMaterials: OrganizationMaterialDto[] | undefined;
    performanceVerificationMaterials: PerformanceVerificationMaterialDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class MaterialOutInStorageDto implements IMaterialOutInStorageDto {
    warehouseGradeType: MaterialOutInStorageDtoWarehouseGradeType | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    outInStorageType: MaterialOutInStorageDtoOutInStorageType | undefined;

    constructor(data?: IMaterialOutInStorageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.warehouseGradeType = data["warehouseGradeType"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.outInStorageType = data["outInStorageType"];
        }
    }

    static fromJS(data: any): MaterialOutInStorageDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialOutInStorageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["warehouseGradeType"] = this.warehouseGradeType;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["outInStorageType"] = this.outInStorageType;
        return data; 
    }

    clone(): MaterialOutInStorageDto {
        const json = this.toJSON();
        let result = new MaterialOutInStorageDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialOutInStorageDto {
    warehouseGradeType: MaterialOutInStorageDtoWarehouseGradeType | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    outInStorageType: MaterialOutInStorageDtoOutInStorageType | undefined;
}

export class PerformanceVerificationMaterialDto implements IPerformanceVerificationMaterialDto {
    inspectionItemId: string | undefined;
    inspectionItemName: string | undefined;
    performanceVerificationType: PerformanceVerificationMaterialDtoPerformanceVerificationType | undefined;
    minReferenceRange: number | undefined;
    maxReferenceRange: number | undefined;
    referenceResult: string | undefined;
    referenceUnit: string | undefined;
    calculationFormula: string | undefined;
    deviation: number | undefined;

    constructor(data?: IPerformanceVerificationMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inspectionItemId = data["inspectionItemId"];
            this.inspectionItemName = data["inspectionItemName"];
            this.performanceVerificationType = data["performanceVerificationType"];
            this.minReferenceRange = data["minReferenceRange"];
            this.maxReferenceRange = data["maxReferenceRange"];
            this.referenceResult = data["referenceResult"];
            this.referenceUnit = data["referenceUnit"];
            this.calculationFormula = data["calculationFormula"];
            this.deviation = data["deviation"];
        }
    }

    static fromJS(data: any): PerformanceVerificationMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformanceVerificationMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inspectionItemId"] = this.inspectionItemId;
        data["inspectionItemName"] = this.inspectionItemName;
        data["performanceVerificationType"] = this.performanceVerificationType;
        data["minReferenceRange"] = this.minReferenceRange;
        data["maxReferenceRange"] = this.maxReferenceRange;
        data["referenceResult"] = this.referenceResult;
        data["referenceUnit"] = this.referenceUnit;
        data["calculationFormula"] = this.calculationFormula;
        data["deviation"] = this.deviation;
        return data; 
    }

    clone(): PerformanceVerificationMaterialDto {
        const json = this.toJSON();
        let result = new PerformanceVerificationMaterialDto();
        result.init(json);
        return result;
    }
}

export interface IPerformanceVerificationMaterialDto {
    inspectionItemId: string | undefined;
    inspectionItemName: string | undefined;
    performanceVerificationType: PerformanceVerificationMaterialDtoPerformanceVerificationType | undefined;
    minReferenceRange: number | undefined;
    maxReferenceRange: number | undefined;
    referenceResult: string | undefined;
    referenceUnit: string | undefined;
    calculationFormula: string | undefined;
    deviation: number | undefined;
}

export class CreateOrUpdateMaterialInput implements ICreateOrUpdateMaterialInput {
    systemMaterialCode: string | undefined;
    hospitalMaterialCode: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    specification: string | undefined;
    storageConditionId: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeId: string | undefined;
    temperatureRangeName: string | undefined;
    materialTypeId: string | undefined;
    materialTypeName: string | undefined;
    brandId: string | undefined;
    brandName: string | undefined;
    price: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    minUnitId: string | undefined;
    minUnitName: string | undefined;
    unitConvertRate: number | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    supplierId: string | undefined;
    supplierName: string | undefined;
    deliveryCompanyId: string | undefined;
    deliveryCompanyName: string | undefined;
    invoicingCompanyId: string | undefined;
    invoicingCompanyName: string | undefined;
    isRegistrationCertificate: boolean | undefined;
    registrationCertificateNo: string | undefined;
    registrationCertificateFilePath: string | undefined;
    expiryDate: Date | undefined;
    outBoxExpiryDate: number | undefined;
    instrumentId: string | undefined;
    instrumentName: string | undefined;
    arrivalDateSetting: string | undefined;
    isDisabled: boolean | undefined;
    disabledDate: Date | undefined;
    disabledReasonId: string | undefined;
    disabledReasonName: string | undefined;
    vendorMaterialCode: string | undefined;
    isStopPurchase: boolean | undefined;
    isAutoGenerateUniqueCode: boolean | undefined;
    isEnableVendorMaterialCode: boolean | undefined;
    isEnableOpenLabel: boolean | undefined;
    isHavePpCertificate: boolean | undefined;
    isPublicReagent: boolean | undefined;
    isCombinationReagent: boolean | undefined;
    combinationReagentProportion: string | undefined;
    isInventoryAlert: boolean | undefined;
    alertMaterialNumber: number | undefined;
    alertMinMaterialNumber: number | undefined;
    isAvailableDayAlert: boolean | undefined;
    alertAvailableDay: number | undefined;
    alertMinAvailableDay: number | undefined;
    isAutoPurchaseCalculate: boolean | undefined;
    monthPurchaseUpperLimit: number | undefined;
    isDefaultPurchaseNumber: boolean | undefined;
    defaultPurchaseNumber: number | undefined;
    unitConvertSetting: string | undefined;
    isPerformanceVerification: boolean | undefined;
    methodologyId: string | undefined;
    methodologyName: string | undefined;
    materialOutInStorages: MaterialOutInStorageDto[] | undefined;
    organizationMaterials: OrganizationMaterialDto[] | undefined;
    performanceVerificationMaterials: PerformanceVerificationMaterialDto[] | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateMaterialInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.systemMaterialCode = data["systemMaterialCode"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.name = data["name"];
            this.shortName = data["shortName"];
            this.specification = data["specification"];
            this.storageConditionId = data["storageConditionId"];
            this.storageConditionName = data["storageConditionName"];
            this.temperatureRangeId = data["temperatureRangeId"];
            this.temperatureRangeName = data["temperatureRangeName"];
            this.materialTypeId = data["materialTypeId"];
            this.materialTypeName = data["materialTypeName"];
            this.brandId = data["brandId"];
            this.brandName = data["brandName"];
            this.price = data["price"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.minUnitId = data["minUnitId"];
            this.minUnitName = data["minUnitName"];
            this.unitConvertRate = data["unitConvertRate"];
            this.manufacturerId = data["manufacturerId"];
            this.manufacturerName = data["manufacturerName"];
            this.supplierId = data["supplierId"];
            this.supplierName = data["supplierName"];
            this.deliveryCompanyId = data["deliveryCompanyId"];
            this.deliveryCompanyName = data["deliveryCompanyName"];
            this.invoicingCompanyId = data["invoicingCompanyId"];
            this.invoicingCompanyName = data["invoicingCompanyName"];
            this.isRegistrationCertificate = data["isRegistrationCertificate"];
            this.registrationCertificateNo = data["registrationCertificateNo"];
            this.registrationCertificateFilePath = data["registrationCertificateFilePath"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.outBoxExpiryDate = data["outBoxExpiryDate"];
            this.instrumentId = data["instrumentId"];
            this.instrumentName = data["instrumentName"];
            this.arrivalDateSetting = data["arrivalDateSetting"];
            this.isDisabled = data["isDisabled"];
            this.disabledDate = data["disabledDate"] ? new Date(data["disabledDate"].toString()) : <any>undefined;
            this.disabledReasonId = data["disabledReasonId"];
            this.disabledReasonName = data["disabledReasonName"];
            this.vendorMaterialCode = data["vendorMaterialCode"];
            this.isStopPurchase = data["isStopPurchase"];
            this.isAutoGenerateUniqueCode = data["isAutoGenerateUniqueCode"];
            this.isEnableVendorMaterialCode = data["isEnableVendorMaterialCode"];
            this.isEnableOpenLabel = data["isEnableOpenLabel"];
            this.isHavePpCertificate = data["isHavePpCertificate"];
            this.isPublicReagent = data["isPublicReagent"];
            this.isCombinationReagent = data["isCombinationReagent"];
            this.combinationReagentProportion = data["combinationReagentProportion"];
            this.isInventoryAlert = data["isInventoryAlert"];
            this.alertMaterialNumber = data["alertMaterialNumber"];
            this.alertMinMaterialNumber = data["alertMinMaterialNumber"];
            this.isAvailableDayAlert = data["isAvailableDayAlert"];
            this.alertAvailableDay = data["alertAvailableDay"];
            this.alertMinAvailableDay = data["alertMinAvailableDay"];
            this.isAutoPurchaseCalculate = data["isAutoPurchaseCalculate"];
            this.monthPurchaseUpperLimit = data["monthPurchaseUpperLimit"];
            this.isDefaultPurchaseNumber = data["isDefaultPurchaseNumber"];
            this.defaultPurchaseNumber = data["defaultPurchaseNumber"];
            this.unitConvertSetting = data["unitConvertSetting"];
            this.isPerformanceVerification = data["isPerformanceVerification"];
            this.methodologyId = data["methodologyId"];
            this.methodologyName = data["methodologyName"];
            if (data["materialOutInStorages"] && data["materialOutInStorages"].constructor === Array) {
                this.materialOutInStorages = [];
                for (let item of data["materialOutInStorages"])
                    this.materialOutInStorages.push(MaterialOutInStorageDto.fromJS(item));
            }
            if (data["organizationMaterials"] && data["organizationMaterials"].constructor === Array) {
                this.organizationMaterials = [];
                for (let item of data["organizationMaterials"])
                    this.organizationMaterials.push(OrganizationMaterialDto.fromJS(item));
            }
            if (data["performanceVerificationMaterials"] && data["performanceVerificationMaterials"].constructor === Array) {
                this.performanceVerificationMaterials = [];
                for (let item of data["performanceVerificationMaterials"])
                    this.performanceVerificationMaterials.push(PerformanceVerificationMaterialDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateMaterialInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMaterialInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemMaterialCode"] = this.systemMaterialCode;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["specification"] = this.specification;
        data["storageConditionId"] = this.storageConditionId;
        data["storageConditionName"] = this.storageConditionName;
        data["temperatureRangeId"] = this.temperatureRangeId;
        data["temperatureRangeName"] = this.temperatureRangeName;
        data["materialTypeId"] = this.materialTypeId;
        data["materialTypeName"] = this.materialTypeName;
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        data["price"] = this.price;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["minUnitId"] = this.minUnitId;
        data["minUnitName"] = this.minUnitName;
        data["unitConvertRate"] = this.unitConvertRate;
        data["manufacturerId"] = this.manufacturerId;
        data["manufacturerName"] = this.manufacturerName;
        data["supplierId"] = this.supplierId;
        data["supplierName"] = this.supplierName;
        data["deliveryCompanyId"] = this.deliveryCompanyId;
        data["deliveryCompanyName"] = this.deliveryCompanyName;
        data["invoicingCompanyId"] = this.invoicingCompanyId;
        data["invoicingCompanyName"] = this.invoicingCompanyName;
        data["isRegistrationCertificate"] = this.isRegistrationCertificate;
        data["registrationCertificateNo"] = this.registrationCertificateNo;
        data["registrationCertificateFilePath"] = this.registrationCertificateFilePath;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["outBoxExpiryDate"] = this.outBoxExpiryDate;
        data["instrumentId"] = this.instrumentId;
        data["instrumentName"] = this.instrumentName;
        data["arrivalDateSetting"] = this.arrivalDateSetting;
        data["isDisabled"] = this.isDisabled;
        data["disabledDate"] = this.disabledDate ? this.disabledDate.toISOString() : <any>undefined;
        data["disabledReasonId"] = this.disabledReasonId;
        data["disabledReasonName"] = this.disabledReasonName;
        data["vendorMaterialCode"] = this.vendorMaterialCode;
        data["isStopPurchase"] = this.isStopPurchase;
        data["isAutoGenerateUniqueCode"] = this.isAutoGenerateUniqueCode;
        data["isEnableVendorMaterialCode"] = this.isEnableVendorMaterialCode;
        data["isEnableOpenLabel"] = this.isEnableOpenLabel;
        data["isHavePpCertificate"] = this.isHavePpCertificate;
        data["isPublicReagent"] = this.isPublicReagent;
        data["isCombinationReagent"] = this.isCombinationReagent;
        data["combinationReagentProportion"] = this.combinationReagentProportion;
        data["isInventoryAlert"] = this.isInventoryAlert;
        data["alertMaterialNumber"] = this.alertMaterialNumber;
        data["alertMinMaterialNumber"] = this.alertMinMaterialNumber;
        data["isAvailableDayAlert"] = this.isAvailableDayAlert;
        data["alertAvailableDay"] = this.alertAvailableDay;
        data["alertMinAvailableDay"] = this.alertMinAvailableDay;
        data["isAutoPurchaseCalculate"] = this.isAutoPurchaseCalculate;
        data["monthPurchaseUpperLimit"] = this.monthPurchaseUpperLimit;
        data["isDefaultPurchaseNumber"] = this.isDefaultPurchaseNumber;
        data["defaultPurchaseNumber"] = this.defaultPurchaseNumber;
        data["unitConvertSetting"] = this.unitConvertSetting;
        data["isPerformanceVerification"] = this.isPerformanceVerification;
        data["methodologyId"] = this.methodologyId;
        data["methodologyName"] = this.methodologyName;
        if (this.materialOutInStorages && this.materialOutInStorages.constructor === Array) {
            data["materialOutInStorages"] = [];
            for (let item of this.materialOutInStorages)
                data["materialOutInStorages"].push(item.toJSON());
        }
        if (this.organizationMaterials && this.organizationMaterials.constructor === Array) {
            data["organizationMaterials"] = [];
            for (let item of this.organizationMaterials)
                data["organizationMaterials"].push(item.toJSON());
        }
        if (this.performanceVerificationMaterials && this.performanceVerificationMaterials.constructor === Array) {
            data["performanceVerificationMaterials"] = [];
            for (let item of this.performanceVerificationMaterials)
                data["performanceVerificationMaterials"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateMaterialInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateMaterialInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMaterialInput {
    systemMaterialCode: string | undefined;
    hospitalMaterialCode: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    specification: string | undefined;
    storageConditionId: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeId: string | undefined;
    temperatureRangeName: string | undefined;
    materialTypeId: string | undefined;
    materialTypeName: string | undefined;
    brandId: string | undefined;
    brandName: string | undefined;
    price: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    minUnitId: string | undefined;
    minUnitName: string | undefined;
    unitConvertRate: number | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    supplierId: string | undefined;
    supplierName: string | undefined;
    deliveryCompanyId: string | undefined;
    deliveryCompanyName: string | undefined;
    invoicingCompanyId: string | undefined;
    invoicingCompanyName: string | undefined;
    isRegistrationCertificate: boolean | undefined;
    registrationCertificateNo: string | undefined;
    registrationCertificateFilePath: string | undefined;
    expiryDate: Date | undefined;
    outBoxExpiryDate: number | undefined;
    instrumentId: string | undefined;
    instrumentName: string | undefined;
    arrivalDateSetting: string | undefined;
    isDisabled: boolean | undefined;
    disabledDate: Date | undefined;
    disabledReasonId: string | undefined;
    disabledReasonName: string | undefined;
    vendorMaterialCode: string | undefined;
    isStopPurchase: boolean | undefined;
    isAutoGenerateUniqueCode: boolean | undefined;
    isEnableVendorMaterialCode: boolean | undefined;
    isEnableOpenLabel: boolean | undefined;
    isHavePpCertificate: boolean | undefined;
    isPublicReagent: boolean | undefined;
    isCombinationReagent: boolean | undefined;
    combinationReagentProportion: string | undefined;
    isInventoryAlert: boolean | undefined;
    alertMaterialNumber: number | undefined;
    alertMinMaterialNumber: number | undefined;
    isAvailableDayAlert: boolean | undefined;
    alertAvailableDay: number | undefined;
    alertMinAvailableDay: number | undefined;
    isAutoPurchaseCalculate: boolean | undefined;
    monthPurchaseUpperLimit: number | undefined;
    isDefaultPurchaseNumber: boolean | undefined;
    defaultPurchaseNumber: number | undefined;
    unitConvertSetting: string | undefined;
    isPerformanceVerification: boolean | undefined;
    methodologyId: string | undefined;
    methodologyName: string | undefined;
    materialOutInStorages: MaterialOutInStorageDto[] | undefined;
    organizationMaterials: OrganizationMaterialDto[] | undefined;
    performanceVerificationMaterials: PerformanceVerificationMaterialDto[] | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetMaterialPaginationOutput implements IPagedResultDtoOfGetMaterialPaginationOutput {
    totalCount: number | undefined;
    items: GetMaterialPaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMaterialPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetMaterialPaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMaterialPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMaterialPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetMaterialPaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetMaterialPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetMaterialPaginationOutput {
    totalCount: number | undefined;
    items: GetMaterialPaginationOutput[] | undefined;
}

export class GetMaterialPaginationOutput implements IGetMaterialPaginationOutput {
    id: string | undefined;
    systemMaterialCode: string | undefined;
    hospitalMaterialCode: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    specification: string | undefined;
    storageConditionId: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeId: string | undefined;
    temperatureRangeName: string | undefined;
    materialTypeId: string | undefined;
    materialTypeName: string | undefined;
    brandId: string | undefined;
    brandName: string | undefined;
    price: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    minUnitId: string | undefined;
    minUnitName: string | undefined;
    unitConvertRate: number | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    supplierId: string | undefined;
    supplierName: string | undefined;
    deliveryCompanyId: string | undefined;
    deliveryCompanyName: string | undefined;
    invoicingCompanyId: string | undefined;
    invoicingCompanyName: string | undefined;
    isRegistrationCertificate: boolean | undefined;
    registrationCertificateNo: string | undefined;
    registrationCertificateFilePath: string | undefined;
    expiryDate: Date | undefined;
    outBoxExpiryDate: number | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    instrumentId: string | undefined;
    instrumentName: string | undefined;
    arrivalDateSetting: string | undefined;
    isDisabled: boolean | undefined;
    disabledDate: Date | undefined;
    disabledReasonId: string | undefined;
    disabledReasonName: string | undefined;
    vendorMaterialCode: string | undefined;
    isStopPurchase: boolean | undefined;
    isAutoGenerateUniqueCode: boolean | undefined;
    isEnableVendorMaterialCode: boolean | undefined;
    isEnableOpenLabel: boolean | undefined;
    isHavePpCertificate: boolean | undefined;
    isPublicReagent: boolean | undefined;
    isCombinationReagent: boolean | undefined;
    combinationReagentProportion: string | undefined;
    isInventoryAlert: boolean | undefined;
    alertMaterialNumber: number | undefined;
    alertMinMaterialNumber: number | undefined;
    isAvailableDayAlert: boolean | undefined;
    alertAvailableDay: number | undefined;
    alertMinAvailableDay: number | undefined;
    isAutoPurchaseCalculate: boolean | undefined;
    monthPurchaseUpperLimit: number | undefined;
    isDefaultPurchaseNumber: boolean | undefined;
    defaultPurchaseNumber: number | undefined;
    unitConvertSetting: string | undefined;
    methodologyId: string | undefined;
    methodologyName: string | undefined;
    organizationMaterialShareInfo: OrganizationMaterialShareInfo | undefined;
    materialOutInStorageInfo: MaterialOutInStorageInfo | undefined;
    organizationMaterials: OrganizationMaterialDto[] | undefined;

    constructor(data?: IGetMaterialPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.systemMaterialCode = data["systemMaterialCode"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.name = data["name"];
            this.shortName = data["shortName"];
            this.specification = data["specification"];
            this.storageConditionId = data["storageConditionId"];
            this.storageConditionName = data["storageConditionName"];
            this.temperatureRangeId = data["temperatureRangeId"];
            this.temperatureRangeName = data["temperatureRangeName"];
            this.materialTypeId = data["materialTypeId"];
            this.materialTypeName = data["materialTypeName"];
            this.brandId = data["brandId"];
            this.brandName = data["brandName"];
            this.price = data["price"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.minUnitId = data["minUnitId"];
            this.minUnitName = data["minUnitName"];
            this.unitConvertRate = data["unitConvertRate"];
            this.manufacturerId = data["manufacturerId"];
            this.manufacturerName = data["manufacturerName"];
            this.supplierId = data["supplierId"];
            this.supplierName = data["supplierName"];
            this.deliveryCompanyId = data["deliveryCompanyId"];
            this.deliveryCompanyName = data["deliveryCompanyName"];
            this.invoicingCompanyId = data["invoicingCompanyId"];
            this.invoicingCompanyName = data["invoicingCompanyName"];
            this.isRegistrationCertificate = data["isRegistrationCertificate"];
            this.registrationCertificateNo = data["registrationCertificateNo"];
            this.registrationCertificateFilePath = data["registrationCertificateFilePath"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.outBoxExpiryDate = data["outBoxExpiryDate"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.instrumentId = data["instrumentId"];
            this.instrumentName = data["instrumentName"];
            this.arrivalDateSetting = data["arrivalDateSetting"];
            this.isDisabled = data["isDisabled"];
            this.disabledDate = data["disabledDate"] ? new Date(data["disabledDate"].toString()) : <any>undefined;
            this.disabledReasonId = data["disabledReasonId"];
            this.disabledReasonName = data["disabledReasonName"];
            this.vendorMaterialCode = data["vendorMaterialCode"];
            this.isStopPurchase = data["isStopPurchase"];
            this.isAutoGenerateUniqueCode = data["isAutoGenerateUniqueCode"];
            this.isEnableVendorMaterialCode = data["isEnableVendorMaterialCode"];
            this.isEnableOpenLabel = data["isEnableOpenLabel"];
            this.isHavePpCertificate = data["isHavePpCertificate"];
            this.isPublicReagent = data["isPublicReagent"];
            this.isCombinationReagent = data["isCombinationReagent"];
            this.combinationReagentProportion = data["combinationReagentProportion"];
            this.isInventoryAlert = data["isInventoryAlert"];
            this.alertMaterialNumber = data["alertMaterialNumber"];
            this.alertMinMaterialNumber = data["alertMinMaterialNumber"];
            this.isAvailableDayAlert = data["isAvailableDayAlert"];
            this.alertAvailableDay = data["alertAvailableDay"];
            this.alertMinAvailableDay = data["alertMinAvailableDay"];
            this.isAutoPurchaseCalculate = data["isAutoPurchaseCalculate"];
            this.monthPurchaseUpperLimit = data["monthPurchaseUpperLimit"];
            this.isDefaultPurchaseNumber = data["isDefaultPurchaseNumber"];
            this.defaultPurchaseNumber = data["defaultPurchaseNumber"];
            this.unitConvertSetting = data["unitConvertSetting"];
            this.methodologyId = data["methodologyId"];
            this.methodologyName = data["methodologyName"];
            this.organizationMaterialShareInfo = data["organizationMaterialShareInfo"] ? OrganizationMaterialShareInfo.fromJS(data["organizationMaterialShareInfo"]) : <any>undefined;
            this.materialOutInStorageInfo = data["materialOutInStorageInfo"] ? MaterialOutInStorageInfo.fromJS(data["materialOutInStorageInfo"]) : <any>undefined;
            if (data["organizationMaterials"] && data["organizationMaterials"].constructor === Array) {
                this.organizationMaterials = [];
                for (let item of data["organizationMaterials"])
                    this.organizationMaterials.push(OrganizationMaterialDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMaterialPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["systemMaterialCode"] = this.systemMaterialCode;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["specification"] = this.specification;
        data["storageConditionId"] = this.storageConditionId;
        data["storageConditionName"] = this.storageConditionName;
        data["temperatureRangeId"] = this.temperatureRangeId;
        data["temperatureRangeName"] = this.temperatureRangeName;
        data["materialTypeId"] = this.materialTypeId;
        data["materialTypeName"] = this.materialTypeName;
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        data["price"] = this.price;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["minUnitId"] = this.minUnitId;
        data["minUnitName"] = this.minUnitName;
        data["unitConvertRate"] = this.unitConvertRate;
        data["manufacturerId"] = this.manufacturerId;
        data["manufacturerName"] = this.manufacturerName;
        data["supplierId"] = this.supplierId;
        data["supplierName"] = this.supplierName;
        data["deliveryCompanyId"] = this.deliveryCompanyId;
        data["deliveryCompanyName"] = this.deliveryCompanyName;
        data["invoicingCompanyId"] = this.invoicingCompanyId;
        data["invoicingCompanyName"] = this.invoicingCompanyName;
        data["isRegistrationCertificate"] = this.isRegistrationCertificate;
        data["registrationCertificateNo"] = this.registrationCertificateNo;
        data["registrationCertificateFilePath"] = this.registrationCertificateFilePath;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["outBoxExpiryDate"] = this.outBoxExpiryDate;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["instrumentId"] = this.instrumentId;
        data["instrumentName"] = this.instrumentName;
        data["arrivalDateSetting"] = this.arrivalDateSetting;
        data["isDisabled"] = this.isDisabled;
        data["disabledDate"] = this.disabledDate ? this.disabledDate.toISOString() : <any>undefined;
        data["disabledReasonId"] = this.disabledReasonId;
        data["disabledReasonName"] = this.disabledReasonName;
        data["vendorMaterialCode"] = this.vendorMaterialCode;
        data["isStopPurchase"] = this.isStopPurchase;
        data["isAutoGenerateUniqueCode"] = this.isAutoGenerateUniqueCode;
        data["isEnableVendorMaterialCode"] = this.isEnableVendorMaterialCode;
        data["isEnableOpenLabel"] = this.isEnableOpenLabel;
        data["isHavePpCertificate"] = this.isHavePpCertificate;
        data["isPublicReagent"] = this.isPublicReagent;
        data["isCombinationReagent"] = this.isCombinationReagent;
        data["combinationReagentProportion"] = this.combinationReagentProportion;
        data["isInventoryAlert"] = this.isInventoryAlert;
        data["alertMaterialNumber"] = this.alertMaterialNumber;
        data["alertMinMaterialNumber"] = this.alertMinMaterialNumber;
        data["isAvailableDayAlert"] = this.isAvailableDayAlert;
        data["alertAvailableDay"] = this.alertAvailableDay;
        data["alertMinAvailableDay"] = this.alertMinAvailableDay;
        data["isAutoPurchaseCalculate"] = this.isAutoPurchaseCalculate;
        data["monthPurchaseUpperLimit"] = this.monthPurchaseUpperLimit;
        data["isDefaultPurchaseNumber"] = this.isDefaultPurchaseNumber;
        data["defaultPurchaseNumber"] = this.defaultPurchaseNumber;
        data["unitConvertSetting"] = this.unitConvertSetting;
        data["methodologyId"] = this.methodologyId;
        data["methodologyName"] = this.methodologyName;
        data["organizationMaterialShareInfo"] = this.organizationMaterialShareInfo ? this.organizationMaterialShareInfo.toJSON() : <any>undefined;
        data["materialOutInStorageInfo"] = this.materialOutInStorageInfo ? this.materialOutInStorageInfo.toJSON() : <any>undefined;
        if (this.organizationMaterials && this.organizationMaterials.constructor === Array) {
            data["organizationMaterials"] = [];
            for (let item of this.organizationMaterials)
                data["organizationMaterials"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetMaterialPaginationOutput {
        const json = this.toJSON();
        let result = new GetMaterialPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMaterialPaginationOutput {
    id: string | undefined;
    systemMaterialCode: string | undefined;
    hospitalMaterialCode: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    specification: string | undefined;
    storageConditionId: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeId: string | undefined;
    temperatureRangeName: string | undefined;
    materialTypeId: string | undefined;
    materialTypeName: string | undefined;
    brandId: string | undefined;
    brandName: string | undefined;
    price: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    minUnitId: string | undefined;
    minUnitName: string | undefined;
    unitConvertRate: number | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    supplierId: string | undefined;
    supplierName: string | undefined;
    deliveryCompanyId: string | undefined;
    deliveryCompanyName: string | undefined;
    invoicingCompanyId: string | undefined;
    invoicingCompanyName: string | undefined;
    isRegistrationCertificate: boolean | undefined;
    registrationCertificateNo: string | undefined;
    registrationCertificateFilePath: string | undefined;
    expiryDate: Date | undefined;
    outBoxExpiryDate: number | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    instrumentId: string | undefined;
    instrumentName: string | undefined;
    arrivalDateSetting: string | undefined;
    isDisabled: boolean | undefined;
    disabledDate: Date | undefined;
    disabledReasonId: string | undefined;
    disabledReasonName: string | undefined;
    vendorMaterialCode: string | undefined;
    isStopPurchase: boolean | undefined;
    isAutoGenerateUniqueCode: boolean | undefined;
    isEnableVendorMaterialCode: boolean | undefined;
    isEnableOpenLabel: boolean | undefined;
    isHavePpCertificate: boolean | undefined;
    isPublicReagent: boolean | undefined;
    isCombinationReagent: boolean | undefined;
    combinationReagentProportion: string | undefined;
    isInventoryAlert: boolean | undefined;
    alertMaterialNumber: number | undefined;
    alertMinMaterialNumber: number | undefined;
    isAvailableDayAlert: boolean | undefined;
    alertAvailableDay: number | undefined;
    alertMinAvailableDay: number | undefined;
    isAutoPurchaseCalculate: boolean | undefined;
    monthPurchaseUpperLimit: number | undefined;
    isDefaultPurchaseNumber: boolean | undefined;
    defaultPurchaseNumber: number | undefined;
    unitConvertSetting: string | undefined;
    methodologyId: string | undefined;
    methodologyName: string | undefined;
    organizationMaterialShareInfo: OrganizationMaterialShareInfo | undefined;
    materialOutInStorageInfo: MaterialOutInStorageInfo | undefined;
    organizationMaterials: OrganizationMaterialDto[] | undefined;
}

export class MaterialOutInStorageInfo implements IMaterialOutInStorageInfo {
    unitId: string | undefined;
    unitName: string | undefined;
    isAutoOutInStorage: boolean | undefined;

    constructor(data?: IMaterialOutInStorageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.isAutoOutInStorage = data["isAutoOutInStorage"];
        }
    }

    static fromJS(data: any): MaterialOutInStorageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialOutInStorageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["isAutoOutInStorage"] = this.isAutoOutInStorage;
        return data; 
    }

    clone(): MaterialOutInStorageInfo {
        const json = this.toJSON();
        let result = new MaterialOutInStorageInfo();
        result.init(json);
        return result;
    }
}

export interface IMaterialOutInStorageInfo {
    unitId: string | undefined;
    unitName: string | undefined;
    isAutoOutInStorage: boolean | undefined;
}

export class MaterialImportDto implements IMaterialImportDto {
    rowNumber: number | undefined;
    systemMaterialCode: string | undefined;
    hospitalMaterialCode: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    specification: string | undefined;
    storageConditionId: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeId: string | undefined;
    temperatureRangeName: string | undefined;
    materialTypeId: string | undefined;
    materialTypeName: string | undefined;
    brandId: string | undefined;
    brandName: string | undefined;
    price: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    minUnitId: string | undefined;
    minUnitName: string | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    supplierId: string | undefined;
    supplierName: string | undefined;
    deliveryCompanyId: string | undefined;
    deliveryCompanyName: string | undefined;
    invoicingCompanyId: string | undefined;
    invoicingCompanyName: string | undefined;
    isRegistrationCertificate: boolean | undefined;
    registrationCertificateNo: string | undefined;
    expiryDate: Date | undefined;
    outBoxExpiryDate: number | undefined;
    instrumentId: string | undefined;
    instrumentName: string | undefined;
    arrivalDateSetting: string | undefined;
    isDisabled: boolean | undefined;
    disabledDate: Date | undefined;
    disabledReasonId: string | undefined;
    disabledReasonName: string | undefined;
    vendorMaterialCode: string | undefined;
    isStopPurchase: boolean | undefined;
    isAutoGenerateUniqueCode: boolean | undefined;
    isEnableVendorMaterialCode: boolean | undefined;
    isEnableOpenLabel: boolean | undefined;
    isHavePpCertificate: boolean | undefined;
    isPublicReagent: boolean | undefined;
    isCombinationReagent: boolean | undefined;
    combinationReagentProportion: string | undefined;
    isInventoryAlert: boolean | undefined;
    alertMaterialNumber: number | undefined;
    alertMinMaterialNumber: number | undefined;
    isAvailableDayAlert: boolean | undefined;
    alertAvailableDay: number | undefined;
    alertMinAvailableDay: number | undefined;
    isAutoPurchaseCalculate: boolean | undefined;
    monthPurchaseUpperLimit: number | undefined;
    isDefaultPurchaseNumber: boolean | undefined;
    defaultPurchaseNumber: number | undefined;
    departmentNames: string | undefined;
    methodologyName: string | undefined;
    message: string | undefined;

    constructor(data?: IMaterialImportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rowNumber = data["rowNumber"];
            this.systemMaterialCode = data["systemMaterialCode"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.name = data["name"];
            this.shortName = data["shortName"];
            this.specification = data["specification"];
            this.storageConditionId = data["storageConditionId"];
            this.storageConditionName = data["storageConditionName"];
            this.temperatureRangeId = data["temperatureRangeId"];
            this.temperatureRangeName = data["temperatureRangeName"];
            this.materialTypeId = data["materialTypeId"];
            this.materialTypeName = data["materialTypeName"];
            this.brandId = data["brandId"];
            this.brandName = data["brandName"];
            this.price = data["price"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.minUnitId = data["minUnitId"];
            this.minUnitName = data["minUnitName"];
            this.manufacturerId = data["manufacturerId"];
            this.manufacturerName = data["manufacturerName"];
            this.supplierId = data["supplierId"];
            this.supplierName = data["supplierName"];
            this.deliveryCompanyId = data["deliveryCompanyId"];
            this.deliveryCompanyName = data["deliveryCompanyName"];
            this.invoicingCompanyId = data["invoicingCompanyId"];
            this.invoicingCompanyName = data["invoicingCompanyName"];
            this.isRegistrationCertificate = data["isRegistrationCertificate"];
            this.registrationCertificateNo = data["registrationCertificateNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.outBoxExpiryDate = data["outBoxExpiryDate"];
            this.instrumentId = data["instrumentId"];
            this.instrumentName = data["instrumentName"];
            this.arrivalDateSetting = data["arrivalDateSetting"];
            this.isDisabled = data["isDisabled"];
            this.disabledDate = data["disabledDate"] ? new Date(data["disabledDate"].toString()) : <any>undefined;
            this.disabledReasonId = data["disabledReasonId"];
            this.disabledReasonName = data["disabledReasonName"];
            this.vendorMaterialCode = data["vendorMaterialCode"];
            this.isStopPurchase = data["isStopPurchase"];
            this.isAutoGenerateUniqueCode = data["isAutoGenerateUniqueCode"];
            this.isEnableVendorMaterialCode = data["isEnableVendorMaterialCode"];
            this.isEnableOpenLabel = data["isEnableOpenLabel"];
            this.isHavePpCertificate = data["isHavePpCertificate"];
            this.isPublicReagent = data["isPublicReagent"];
            this.isCombinationReagent = data["isCombinationReagent"];
            this.combinationReagentProportion = data["combinationReagentProportion"];
            this.isInventoryAlert = data["isInventoryAlert"];
            this.alertMaterialNumber = data["alertMaterialNumber"];
            this.alertMinMaterialNumber = data["alertMinMaterialNumber"];
            this.isAvailableDayAlert = data["isAvailableDayAlert"];
            this.alertAvailableDay = data["alertAvailableDay"];
            this.alertMinAvailableDay = data["alertMinAvailableDay"];
            this.isAutoPurchaseCalculate = data["isAutoPurchaseCalculate"];
            this.monthPurchaseUpperLimit = data["monthPurchaseUpperLimit"];
            this.isDefaultPurchaseNumber = data["isDefaultPurchaseNumber"];
            this.defaultPurchaseNumber = data["defaultPurchaseNumber"];
            this.departmentNames = data["departmentNames"];
            this.methodologyName = data["methodologyName"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): MaterialImportDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialImportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowNumber"] = this.rowNumber;
        data["systemMaterialCode"] = this.systemMaterialCode;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["specification"] = this.specification;
        data["storageConditionId"] = this.storageConditionId;
        data["storageConditionName"] = this.storageConditionName;
        data["temperatureRangeId"] = this.temperatureRangeId;
        data["temperatureRangeName"] = this.temperatureRangeName;
        data["materialTypeId"] = this.materialTypeId;
        data["materialTypeName"] = this.materialTypeName;
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        data["price"] = this.price;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["minUnitId"] = this.minUnitId;
        data["minUnitName"] = this.minUnitName;
        data["manufacturerId"] = this.manufacturerId;
        data["manufacturerName"] = this.manufacturerName;
        data["supplierId"] = this.supplierId;
        data["supplierName"] = this.supplierName;
        data["deliveryCompanyId"] = this.deliveryCompanyId;
        data["deliveryCompanyName"] = this.deliveryCompanyName;
        data["invoicingCompanyId"] = this.invoicingCompanyId;
        data["invoicingCompanyName"] = this.invoicingCompanyName;
        data["isRegistrationCertificate"] = this.isRegistrationCertificate;
        data["registrationCertificateNo"] = this.registrationCertificateNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["outBoxExpiryDate"] = this.outBoxExpiryDate;
        data["instrumentId"] = this.instrumentId;
        data["instrumentName"] = this.instrumentName;
        data["arrivalDateSetting"] = this.arrivalDateSetting;
        data["isDisabled"] = this.isDisabled;
        data["disabledDate"] = this.disabledDate ? this.disabledDate.toISOString() : <any>undefined;
        data["disabledReasonId"] = this.disabledReasonId;
        data["disabledReasonName"] = this.disabledReasonName;
        data["vendorMaterialCode"] = this.vendorMaterialCode;
        data["isStopPurchase"] = this.isStopPurchase;
        data["isAutoGenerateUniqueCode"] = this.isAutoGenerateUniqueCode;
        data["isEnableVendorMaterialCode"] = this.isEnableVendorMaterialCode;
        data["isEnableOpenLabel"] = this.isEnableOpenLabel;
        data["isHavePpCertificate"] = this.isHavePpCertificate;
        data["isPublicReagent"] = this.isPublicReagent;
        data["isCombinationReagent"] = this.isCombinationReagent;
        data["combinationReagentProportion"] = this.combinationReagentProportion;
        data["isInventoryAlert"] = this.isInventoryAlert;
        data["alertMaterialNumber"] = this.alertMaterialNumber;
        data["alertMinMaterialNumber"] = this.alertMinMaterialNumber;
        data["isAvailableDayAlert"] = this.isAvailableDayAlert;
        data["alertAvailableDay"] = this.alertAvailableDay;
        data["alertMinAvailableDay"] = this.alertMinAvailableDay;
        data["isAutoPurchaseCalculate"] = this.isAutoPurchaseCalculate;
        data["monthPurchaseUpperLimit"] = this.monthPurchaseUpperLimit;
        data["isDefaultPurchaseNumber"] = this.isDefaultPurchaseNumber;
        data["defaultPurchaseNumber"] = this.defaultPurchaseNumber;
        data["departmentNames"] = this.departmentNames;
        data["methodologyName"] = this.methodologyName;
        data["message"] = this.message;
        return data; 
    }

    clone(): MaterialImportDto {
        const json = this.toJSON();
        let result = new MaterialImportDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialImportDto {
    rowNumber: number | undefined;
    systemMaterialCode: string | undefined;
    hospitalMaterialCode: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    specification: string | undefined;
    storageConditionId: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeId: string | undefined;
    temperatureRangeName: string | undefined;
    materialTypeId: string | undefined;
    materialTypeName: string | undefined;
    brandId: string | undefined;
    brandName: string | undefined;
    price: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    minUnitId: string | undefined;
    minUnitName: string | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    supplierId: string | undefined;
    supplierName: string | undefined;
    deliveryCompanyId: string | undefined;
    deliveryCompanyName: string | undefined;
    invoicingCompanyId: string | undefined;
    invoicingCompanyName: string | undefined;
    isRegistrationCertificate: boolean | undefined;
    registrationCertificateNo: string | undefined;
    expiryDate: Date | undefined;
    outBoxExpiryDate: number | undefined;
    instrumentId: string | undefined;
    instrumentName: string | undefined;
    arrivalDateSetting: string | undefined;
    isDisabled: boolean | undefined;
    disabledDate: Date | undefined;
    disabledReasonId: string | undefined;
    disabledReasonName: string | undefined;
    vendorMaterialCode: string | undefined;
    isStopPurchase: boolean | undefined;
    isAutoGenerateUniqueCode: boolean | undefined;
    isEnableVendorMaterialCode: boolean | undefined;
    isEnableOpenLabel: boolean | undefined;
    isHavePpCertificate: boolean | undefined;
    isPublicReagent: boolean | undefined;
    isCombinationReagent: boolean | undefined;
    combinationReagentProportion: string | undefined;
    isInventoryAlert: boolean | undefined;
    alertMaterialNumber: number | undefined;
    alertMinMaterialNumber: number | undefined;
    isAvailableDayAlert: boolean | undefined;
    alertAvailableDay: number | undefined;
    alertMinAvailableDay: number | undefined;
    isAutoPurchaseCalculate: boolean | undefined;
    monthPurchaseUpperLimit: number | undefined;
    isDefaultPurchaseNumber: boolean | undefined;
    defaultPurchaseNumber: number | undefined;
    departmentNames: string | undefined;
    methodologyName: string | undefined;
    message: string | undefined;
}

export class GetMaterialInventoryForEditOutput implements IGetMaterialInventoryForEditOutput {
    inventoryOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    inventoryApprovalState: GetMaterialInventoryForEditOutputInventoryApprovalState | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    materialInventoryDetails: MaterialInventoryDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetMaterialInventoryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inventoryOrderNo = data["inventoryOrderNo"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.inventoryApprovalState = data["inventoryApprovalState"];
            this.applicantUserId = data["applicantUserId"];
            this.applicationTime = data["applicationTime"] ? new Date(data["applicationTime"].toString()) : <any>undefined;
            if (data["materialInventoryDetails"] && data["materialInventoryDetails"].constructor === Array) {
                this.materialInventoryDetails = [];
                for (let item of data["materialInventoryDetails"])
                    this.materialInventoryDetails.push(MaterialInventoryDetailDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetMaterialInventoryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialInventoryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryOrderNo"] = this.inventoryOrderNo;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["inventoryApprovalState"] = this.inventoryApprovalState;
        data["applicantUserId"] = this.applicantUserId;
        data["applicationTime"] = this.applicationTime ? this.applicationTime.toISOString() : <any>undefined;
        if (this.materialInventoryDetails && this.materialInventoryDetails.constructor === Array) {
            data["materialInventoryDetails"] = [];
            for (let item of this.materialInventoryDetails)
                data["materialInventoryDetails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetMaterialInventoryForEditOutput {
        const json = this.toJSON();
        let result = new GetMaterialInventoryForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMaterialInventoryForEditOutput {
    inventoryOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    inventoryApprovalState: GetMaterialInventoryForEditOutputInventoryApprovalState | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    materialInventoryDetails: MaterialInventoryDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class MaterialInventoryDetailDto implements IMaterialInventoryDetailDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    materialInventoryId: string | undefined;
    material: MaterialShareDto | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IMaterialInventoryDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.number = data["number"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.materialInventoryId = data["materialInventoryId"];
            this.material = data["material"] ? MaterialShareDto.fromJS(data["material"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MaterialInventoryDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialInventoryDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["materialInventoryId"] = this.materialInventoryId;
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialInventoryDetailDto {
        const json = this.toJSON();
        let result = new MaterialInventoryDetailDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialInventoryDetailDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    materialInventoryId: string | undefined;
    material: MaterialShareDto | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateOrUpdateMaterialInventoryInput implements ICreateOrUpdateMaterialInventoryInput {
    inventoryOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    inventoryApprovalState: CreateOrUpdateMaterialInventoryInputInventoryApprovalState | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    materialInventoryDetails: CreateOrUpdateMaterialInventoryDetailInput[] | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateMaterialInventoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inventoryOrderNo = data["inventoryOrderNo"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.inventoryApprovalState = data["inventoryApprovalState"];
            this.applicantUserId = data["applicantUserId"];
            this.applicationTime = data["applicationTime"] ? new Date(data["applicationTime"].toString()) : <any>undefined;
            if (data["materialInventoryDetails"] && data["materialInventoryDetails"].constructor === Array) {
                this.materialInventoryDetails = [];
                for (let item of data["materialInventoryDetails"])
                    this.materialInventoryDetails.push(CreateOrUpdateMaterialInventoryDetailInput.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateMaterialInventoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMaterialInventoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryOrderNo"] = this.inventoryOrderNo;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["inventoryApprovalState"] = this.inventoryApprovalState;
        data["applicantUserId"] = this.applicantUserId;
        data["applicationTime"] = this.applicationTime ? this.applicationTime.toISOString() : <any>undefined;
        if (this.materialInventoryDetails && this.materialInventoryDetails.constructor === Array) {
            data["materialInventoryDetails"] = [];
            for (let item of this.materialInventoryDetails)
                data["materialInventoryDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateMaterialInventoryInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateMaterialInventoryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMaterialInventoryInput {
    inventoryOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    inventoryApprovalState: CreateOrUpdateMaterialInventoryInputInventoryApprovalState | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    materialInventoryDetails: CreateOrUpdateMaterialInventoryDetailInput[] | undefined;
    id: string | undefined;
}

export class CreateOrUpdateMaterialInventoryDetailInput implements ICreateOrUpdateMaterialInventoryDetailInput {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateMaterialInventoryDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.number = data["number"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateMaterialInventoryDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMaterialInventoryDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateMaterialInventoryDetailInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateMaterialInventoryDetailInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMaterialInventoryDetailInput {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    id: string | undefined;
}

export class CreateOrUpdateMaterialInventoryOutput implements ICreateOrUpdateMaterialInventoryOutput {
    inventoryOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    inventoryApprovalState: CreateOrUpdateMaterialInventoryOutputInventoryApprovalState | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    materialInventoryDetails: MaterialInventoryDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateMaterialInventoryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inventoryOrderNo = data["inventoryOrderNo"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.inventoryApprovalState = data["inventoryApprovalState"];
            this.applicantUserId = data["applicantUserId"];
            this.applicationTime = data["applicationTime"] ? new Date(data["applicationTime"].toString()) : <any>undefined;
            if (data["materialInventoryDetails"] && data["materialInventoryDetails"].constructor === Array) {
                this.materialInventoryDetails = [];
                for (let item of data["materialInventoryDetails"])
                    this.materialInventoryDetails.push(MaterialInventoryDetailDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateMaterialInventoryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMaterialInventoryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryOrderNo"] = this.inventoryOrderNo;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["inventoryApprovalState"] = this.inventoryApprovalState;
        data["applicantUserId"] = this.applicantUserId;
        data["applicationTime"] = this.applicationTime ? this.applicationTime.toISOString() : <any>undefined;
        if (this.materialInventoryDetails && this.materialInventoryDetails.constructor === Array) {
            data["materialInventoryDetails"] = [];
            for (let item of this.materialInventoryDetails)
                data["materialInventoryDetails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateMaterialInventoryOutput {
        const json = this.toJSON();
        let result = new CreateOrUpdateMaterialInventoryOutput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMaterialInventoryOutput {
    inventoryOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    inventoryApprovalState: CreateOrUpdateMaterialInventoryOutputInventoryApprovalState | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    materialInventoryDetails: MaterialInventoryDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetMaterialInventoryPaginationOutput implements IPagedResultDtoOfGetMaterialInventoryPaginationOutput {
    totalCount: number | undefined;
    items: GetMaterialInventoryPaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMaterialInventoryPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetMaterialInventoryPaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMaterialInventoryPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMaterialInventoryPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetMaterialInventoryPaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetMaterialInventoryPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetMaterialInventoryPaginationOutput {
    totalCount: number | undefined;
    items: GetMaterialInventoryPaginationOutput[] | undefined;
}

export class GetMaterialInventoryPaginationOutput implements IGetMaterialInventoryPaginationOutput {
    inventoryOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    inventoryApprovalState: GetMaterialInventoryPaginationOutputInventoryApprovalState | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    materialInventoryDetails: MaterialInventoryDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetMaterialInventoryPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inventoryOrderNo = data["inventoryOrderNo"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.inventoryApprovalState = data["inventoryApprovalState"];
            this.applicantUserId = data["applicantUserId"];
            this.applicationTime = data["applicationTime"] ? new Date(data["applicationTime"].toString()) : <any>undefined;
            if (data["materialInventoryDetails"] && data["materialInventoryDetails"].constructor === Array) {
                this.materialInventoryDetails = [];
                for (let item of data["materialInventoryDetails"])
                    this.materialInventoryDetails.push(MaterialInventoryDetailDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetMaterialInventoryPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialInventoryPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryOrderNo"] = this.inventoryOrderNo;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["inventoryApprovalState"] = this.inventoryApprovalState;
        data["applicantUserId"] = this.applicantUserId;
        data["applicationTime"] = this.applicationTime ? this.applicationTime.toISOString() : <any>undefined;
        if (this.materialInventoryDetails && this.materialInventoryDetails.constructor === Array) {
            data["materialInventoryDetails"] = [];
            for (let item of this.materialInventoryDetails)
                data["materialInventoryDetails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetMaterialInventoryPaginationOutput {
        const json = this.toJSON();
        let result = new GetMaterialInventoryPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMaterialInventoryPaginationOutput {
    inventoryOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    inventoryApprovalState: GetMaterialInventoryPaginationOutputInventoryApprovalState | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    materialInventoryDetails: MaterialInventoryDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetInventoryRecordDto implements IGetInventoryRecordDto {
    inventoryRecordId: string | undefined;
    inventoryOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    inventoryApprovalState: GetInventoryRecordDtoInventoryApprovalState | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    details: GetInventoryRecordDetailDto[] | undefined;
    id: string | undefined;

    constructor(data?: IGetInventoryRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inventoryRecordId = data["inventoryRecordId"];
            this.inventoryOrderNo = data["inventoryOrderNo"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.inventoryApprovalState = data["inventoryApprovalState"];
            this.applicantUserId = data["applicantUserId"];
            this.applicationTime = data["applicationTime"] ? new Date(data["applicationTime"].toString()) : <any>undefined;
            if (data["details"] && data["details"].constructor === Array) {
                this.details = [];
                for (let item of data["details"])
                    this.details.push(GetInventoryRecordDetailDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetInventoryRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetInventoryRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryRecordId"] = this.inventoryRecordId;
        data["inventoryOrderNo"] = this.inventoryOrderNo;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["inventoryApprovalState"] = this.inventoryApprovalState;
        data["applicantUserId"] = this.applicantUserId;
        data["applicationTime"] = this.applicationTime ? this.applicationTime.toISOString() : <any>undefined;
        if (this.details && this.details.constructor === Array) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): GetInventoryRecordDto {
        const json = this.toJSON();
        let result = new GetInventoryRecordDto();
        result.init(json);
        return result;
    }
}

export interface IGetInventoryRecordDto {
    inventoryRecordId: string | undefined;
    inventoryOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    inventoryApprovalState: GetInventoryRecordDtoInventoryApprovalState | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    details: GetInventoryRecordDetailDto[] | undefined;
    id: string | undefined;
}

export class GetInventoryRecordDetailDto implements IGetInventoryRecordDetailDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    actualNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    barcodes: string[] | undefined;

    constructor(data?: IGetInventoryRecordDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.number = data["number"];
            this.actualNumber = data["actualNumber"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            if (data["barcodes"] && data["barcodes"].constructor === Array) {
                this.barcodes = [];
                for (let item of data["barcodes"])
                    this.barcodes.push(item);
            }
        }
    }

    static fromJS(data: any): GetInventoryRecordDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetInventoryRecordDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["actualNumber"] = this.actualNumber;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        if (this.barcodes && this.barcodes.constructor === Array) {
            data["barcodes"] = [];
            for (let item of this.barcodes)
                data["barcodes"].push(item);
        }
        return data; 
    }

    clone(): GetInventoryRecordDetailDto {
        const json = this.toJSON();
        let result = new GetInventoryRecordDetailDto();
        result.init(json);
        return result;
    }
}

export interface IGetInventoryRecordDetailDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    actualNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    barcodes: string[] | undefined;
}

export class CreateInventoryRecordInput implements ICreateInventoryRecordInput {
    inventoryRecord: CreateInventoryRecordDto | undefined;

    constructor(data?: ICreateInventoryRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inventoryRecord = data["inventoryRecord"] ? CreateInventoryRecordDto.fromJS(data["inventoryRecord"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateInventoryRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInventoryRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryRecord"] = this.inventoryRecord ? this.inventoryRecord.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateInventoryRecordInput {
        const json = this.toJSON();
        let result = new CreateInventoryRecordInput();
        result.init(json);
        return result;
    }
}

export interface ICreateInventoryRecordInput {
    inventoryRecord: CreateInventoryRecordDto | undefined;
}

export class CreateInventoryRecordDto implements ICreateInventoryRecordDto {
    materialInventoryId: string | undefined;
    inventoryOrderNo: string | undefined;
    inventoryUserId: number | undefined;
    isFinished: boolean | undefined;
    inventoryRecordDetails: CreateInventoryRecordDetailDto[] | undefined;
    id: string | undefined;

    constructor(data?: ICreateInventoryRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialInventoryId = data["materialInventoryId"];
            this.inventoryOrderNo = data["inventoryOrderNo"];
            this.inventoryUserId = data["inventoryUserId"];
            this.isFinished = data["isFinished"];
            if (data["inventoryRecordDetails"] && data["inventoryRecordDetails"].constructor === Array) {
                this.inventoryRecordDetails = [];
                for (let item of data["inventoryRecordDetails"])
                    this.inventoryRecordDetails.push(CreateInventoryRecordDetailDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateInventoryRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInventoryRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialInventoryId"] = this.materialInventoryId;
        data["inventoryOrderNo"] = this.inventoryOrderNo;
        data["inventoryUserId"] = this.inventoryUserId;
        data["isFinished"] = this.isFinished;
        if (this.inventoryRecordDetails && this.inventoryRecordDetails.constructor === Array) {
            data["inventoryRecordDetails"] = [];
            for (let item of this.inventoryRecordDetails)
                data["inventoryRecordDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateInventoryRecordDto {
        const json = this.toJSON();
        let result = new CreateInventoryRecordDto();
        result.init(json);
        return result;
    }
}

export interface ICreateInventoryRecordDto {
    materialInventoryId: string | undefined;
    inventoryOrderNo: string | undefined;
    inventoryUserId: number | undefined;
    isFinished: boolean | undefined;
    inventoryRecordDetails: CreateInventoryRecordDetailDto[] | undefined;
    id: string | undefined;
}

export class CreateInventoryRecordDetailDto implements ICreateInventoryRecordDetailDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    actualNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    barcodes: string[] | undefined;
    id: string | undefined;

    constructor(data?: ICreateInventoryRecordDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.number = data["number"];
            this.actualNumber = data["actualNumber"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            if (data["barcodes"] && data["barcodes"].constructor === Array) {
                this.barcodes = [];
                for (let item of data["barcodes"])
                    this.barcodes.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateInventoryRecordDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInventoryRecordDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["actualNumber"] = this.actualNumber;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        if (this.barcodes && this.barcodes.constructor === Array) {
            data["barcodes"] = [];
            for (let item of this.barcodes)
                data["barcodes"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateInventoryRecordDetailDto {
        const json = this.toJSON();
        let result = new CreateInventoryRecordDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICreateInventoryRecordDetailDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    actualNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    barcodes: string[] | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetInventoryRecordPaginationOutput implements IPagedResultDtoOfGetInventoryRecordPaginationOutput {
    totalCount: number | undefined;
    items: GetInventoryRecordPaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetInventoryRecordPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetInventoryRecordPaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetInventoryRecordPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetInventoryRecordPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetInventoryRecordPaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetInventoryRecordPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetInventoryRecordPaginationOutput {
    totalCount: number | undefined;
    items: GetInventoryRecordPaginationOutput[] | undefined;
}

export class GetInventoryRecordPaginationOutput implements IGetInventoryRecordPaginationOutput {
    materialInventoryId: string | undefined;
    inventoryOrderNo: string | undefined;
    inventoryUserId: number | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    actualNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    isHandle: boolean | undefined;
    inventoryShareInfo: InventoryShareInfo | undefined;
    id: string | undefined;

    constructor(data?: IGetInventoryRecordPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialInventoryId = data["materialInventoryId"];
            this.inventoryOrderNo = data["inventoryOrderNo"];
            this.inventoryUserId = data["inventoryUserId"];
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.number = data["number"];
            this.actualNumber = data["actualNumber"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.isHandle = data["isHandle"];
            this.inventoryShareInfo = data["inventoryShareInfo"] ? InventoryShareInfo.fromJS(data["inventoryShareInfo"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetInventoryRecordPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInventoryRecordPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialInventoryId"] = this.materialInventoryId;
        data["inventoryOrderNo"] = this.inventoryOrderNo;
        data["inventoryUserId"] = this.inventoryUserId;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["actualNumber"] = this.actualNumber;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["isHandle"] = this.isHandle;
        data["inventoryShareInfo"] = this.inventoryShareInfo ? this.inventoryShareInfo.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetInventoryRecordPaginationOutput {
        const json = this.toJSON();
        let result = new GetInventoryRecordPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetInventoryRecordPaginationOutput {
    materialInventoryId: string | undefined;
    inventoryOrderNo: string | undefined;
    inventoryUserId: number | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    actualNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    isHandle: boolean | undefined;
    inventoryShareInfo: InventoryShareInfo | undefined;
    id: string | undefined;
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id: string | undefined;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDtoOfGuid {
        const json = this.toJSON();
        let result = new EntityDtoOfGuid();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfGuid {
    id: string | undefined;
}

export class GetMaterialOutStorageForEditOutput implements IGetMaterialOutStorageForEditOutput {
    materialRequestId: string | undefined;
    requestOrderNo: string | undefined;
    outStorageOrderNo: string | undefined;
    outStorageApprovalState: GetMaterialOutStorageForEditOutputOutStorageApprovalState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    outStorageType: GetMaterialOutStorageForEditOutputOutStorageType | undefined;
    outStorageUserId: number | undefined;
    outStorageTime: Date | undefined;
    materialOutStorageDetails: MaterialOutStorageDetailDto[] | undefined;
    k3OutStorageOrderNo: string | undefined;
    isSyncK3: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetMaterialOutStorageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialRequestId = data["materialRequestId"];
            this.requestOrderNo = data["requestOrderNo"];
            this.outStorageOrderNo = data["outStorageOrderNo"];
            this.outStorageApprovalState = data["outStorageApprovalState"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.outStorageType = data["outStorageType"];
            this.outStorageUserId = data["outStorageUserId"];
            this.outStorageTime = data["outStorageTime"] ? new Date(data["outStorageTime"].toString()) : <any>undefined;
            if (data["materialOutStorageDetails"] && data["materialOutStorageDetails"].constructor === Array) {
                this.materialOutStorageDetails = [];
                for (let item of data["materialOutStorageDetails"])
                    this.materialOutStorageDetails.push(MaterialOutStorageDetailDto.fromJS(item));
            }
            this.k3OutStorageOrderNo = data["k3OutStorageOrderNo"];
            this.isSyncK3 = data["isSyncK3"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetMaterialOutStorageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialOutStorageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialRequestId"] = this.materialRequestId;
        data["requestOrderNo"] = this.requestOrderNo;
        data["outStorageOrderNo"] = this.outStorageOrderNo;
        data["outStorageApprovalState"] = this.outStorageApprovalState;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["outStorageType"] = this.outStorageType;
        data["outStorageUserId"] = this.outStorageUserId;
        data["outStorageTime"] = this.outStorageTime ? this.outStorageTime.toISOString() : <any>undefined;
        if (this.materialOutStorageDetails && this.materialOutStorageDetails.constructor === Array) {
            data["materialOutStorageDetails"] = [];
            for (let item of this.materialOutStorageDetails)
                data["materialOutStorageDetails"].push(item.toJSON());
        }
        data["k3OutStorageOrderNo"] = this.k3OutStorageOrderNo;
        data["isSyncK3"] = this.isSyncK3;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetMaterialOutStorageForEditOutput {
        const json = this.toJSON();
        let result = new GetMaterialOutStorageForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMaterialOutStorageForEditOutput {
    materialRequestId: string | undefined;
    requestOrderNo: string | undefined;
    outStorageOrderNo: string | undefined;
    outStorageApprovalState: GetMaterialOutStorageForEditOutputOutStorageApprovalState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    outStorageType: GetMaterialOutStorageForEditOutputOutStorageType | undefined;
    outStorageUserId: number | undefined;
    outStorageTime: Date | undefined;
    materialOutStorageDetails: MaterialOutStorageDetailDto[] | undefined;
    k3OutStorageOrderNo: string | undefined;
    isSyncK3: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class MaterialOutStorageDetailDto implements IMaterialOutStorageDetailDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    material: MaterialShareDto | undefined;

    constructor(data?: IMaterialOutStorageDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.number = data["number"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.material = data["material"] ? MaterialShareDto.fromJS(data["material"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MaterialOutStorageDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialOutStorageDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        return data; 
    }

    clone(): MaterialOutStorageDetailDto {
        const json = this.toJSON();
        let result = new MaterialOutStorageDetailDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialOutStorageDetailDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    material: MaterialShareDto | undefined;
}

export class CreateOrUpdateMaterialOutStorageInput implements ICreateOrUpdateMaterialOutStorageInput {
    materialRequestId: string | undefined;
    requestOrderNo: string | undefined;
    outStorageOrderNo: string | undefined;
    outStorageApprovalState: CreateOrUpdateMaterialOutStorageInputOutStorageApprovalState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    outStorageType: CreateOrUpdateMaterialOutStorageInputOutStorageType | undefined;
    outStorageUserId: number | undefined;
    outStorageTime: Date | undefined;
    materialOutStorageDetails: CreateOrUpdateMaterialOutStorageDetailInput[] | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateMaterialOutStorageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialRequestId = data["materialRequestId"];
            this.requestOrderNo = data["requestOrderNo"];
            this.outStorageOrderNo = data["outStorageOrderNo"];
            this.outStorageApprovalState = data["outStorageApprovalState"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.outStorageType = data["outStorageType"];
            this.outStorageUserId = data["outStorageUserId"];
            this.outStorageTime = data["outStorageTime"] ? new Date(data["outStorageTime"].toString()) : <any>undefined;
            if (data["materialOutStorageDetails"] && data["materialOutStorageDetails"].constructor === Array) {
                this.materialOutStorageDetails = [];
                for (let item of data["materialOutStorageDetails"])
                    this.materialOutStorageDetails.push(CreateOrUpdateMaterialOutStorageDetailInput.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateMaterialOutStorageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMaterialOutStorageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialRequestId"] = this.materialRequestId;
        data["requestOrderNo"] = this.requestOrderNo;
        data["outStorageOrderNo"] = this.outStorageOrderNo;
        data["outStorageApprovalState"] = this.outStorageApprovalState;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["outStorageType"] = this.outStorageType;
        data["outStorageUserId"] = this.outStorageUserId;
        data["outStorageTime"] = this.outStorageTime ? this.outStorageTime.toISOString() : <any>undefined;
        if (this.materialOutStorageDetails && this.materialOutStorageDetails.constructor === Array) {
            data["materialOutStorageDetails"] = [];
            for (let item of this.materialOutStorageDetails)
                data["materialOutStorageDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateMaterialOutStorageInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateMaterialOutStorageInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMaterialOutStorageInput {
    materialRequestId: string | undefined;
    requestOrderNo: string | undefined;
    outStorageOrderNo: string | undefined;
    outStorageApprovalState: CreateOrUpdateMaterialOutStorageInputOutStorageApprovalState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    outStorageType: CreateOrUpdateMaterialOutStorageInputOutStorageType | undefined;
    outStorageUserId: number | undefined;
    outStorageTime: Date | undefined;
    materialOutStorageDetails: CreateOrUpdateMaterialOutStorageDetailInput[] | undefined;
    id: string | undefined;
}

export class CreateOrUpdateMaterialOutStorageDetailInput implements ICreateOrUpdateMaterialOutStorageDetailInput {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    barcodes: string[] | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateMaterialOutStorageDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.number = data["number"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            if (data["barcodes"] && data["barcodes"].constructor === Array) {
                this.barcodes = [];
                for (let item of data["barcodes"])
                    this.barcodes.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateMaterialOutStorageDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMaterialOutStorageDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        if (this.barcodes && this.barcodes.constructor === Array) {
            data["barcodes"] = [];
            for (let item of this.barcodes)
                data["barcodes"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateMaterialOutStorageDetailInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateMaterialOutStorageDetailInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMaterialOutStorageDetailInput {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    barcodes: string[] | undefined;
    id: string | undefined;
}

export class MaterialOutStorage implements IMaterialOutStorage {
    materialRequestId: string | undefined;
    requestOrderNo: string | undefined;
    outStorageOrderNo: string | undefined;
    outStorageApprovalState: MaterialOutStorageOutStorageApprovalState | undefined;
    outStorageType: MaterialOutStorageOutStorageType | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    outStorageUserId: number | undefined;
    outStorageTime: Date | undefined;
    materialOutStorageDetails: MaterialOutStorageDetail[] | undefined;
    k3OutStorageOrderNo: string | undefined;
    isSyncK3: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    domainEvents: IEventData[] | undefined;
    id: string | undefined;

    constructor(data?: IMaterialOutStorage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialRequestId = data["materialRequestId"];
            this.requestOrderNo = data["requestOrderNo"];
            this.outStorageOrderNo = data["outStorageOrderNo"];
            this.outStorageApprovalState = data["outStorageApprovalState"];
            this.outStorageType = data["outStorageType"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.outStorageUserId = data["outStorageUserId"];
            this.outStorageTime = data["outStorageTime"] ? new Date(data["outStorageTime"].toString()) : <any>undefined;
            if (data["materialOutStorageDetails"] && data["materialOutStorageDetails"].constructor === Array) {
                this.materialOutStorageDetails = [];
                for (let item of data["materialOutStorageDetails"])
                    this.materialOutStorageDetails.push(MaterialOutStorageDetail.fromJS(item));
            }
            this.k3OutStorageOrderNo = data["k3OutStorageOrderNo"];
            this.isSyncK3 = data["isSyncK3"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            if (data["domainEvents"] && data["domainEvents"].constructor === Array) {
                this.domainEvents = [];
                for (let item of data["domainEvents"])
                    this.domainEvents.push(IEventData.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MaterialOutStorage {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialOutStorage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialRequestId"] = this.materialRequestId;
        data["requestOrderNo"] = this.requestOrderNo;
        data["outStorageOrderNo"] = this.outStorageOrderNo;
        data["outStorageApprovalState"] = this.outStorageApprovalState;
        data["outStorageType"] = this.outStorageType;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["outStorageUserId"] = this.outStorageUserId;
        data["outStorageTime"] = this.outStorageTime ? this.outStorageTime.toISOString() : <any>undefined;
        if (this.materialOutStorageDetails && this.materialOutStorageDetails.constructor === Array) {
            data["materialOutStorageDetails"] = [];
            for (let item of this.materialOutStorageDetails)
                data["materialOutStorageDetails"].push(item.toJSON());
        }
        data["k3OutStorageOrderNo"] = this.k3OutStorageOrderNo;
        data["isSyncK3"] = this.isSyncK3;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        if (this.domainEvents && this.domainEvents.constructor === Array) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialOutStorage {
        const json = this.toJSON();
        let result = new MaterialOutStorage();
        result.init(json);
        return result;
    }
}

export interface IMaterialOutStorage {
    materialRequestId: string | undefined;
    requestOrderNo: string | undefined;
    outStorageOrderNo: string | undefined;
    outStorageApprovalState: MaterialOutStorageOutStorageApprovalState | undefined;
    outStorageType: MaterialOutStorageOutStorageType | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    outStorageUserId: number | undefined;
    outStorageTime: Date | undefined;
    materialOutStorageDetails: MaterialOutStorageDetail[] | undefined;
    k3OutStorageOrderNo: string | undefined;
    isSyncK3: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    domainEvents: IEventData[] | undefined;
    id: string | undefined;
}

export class MaterialOutStorageDetail implements IMaterialOutStorageDetail {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    materialOutStorageId: string | undefined;
    materialOutStorage: MaterialOutStorage | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IMaterialOutStorageDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.number = data["number"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.materialOutStorageId = data["materialOutStorageId"];
            this.materialOutStorage = data["materialOutStorage"] ? MaterialOutStorage.fromJS(data["materialOutStorage"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MaterialOutStorageDetail {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialOutStorageDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["materialOutStorageId"] = this.materialOutStorageId;
        data["materialOutStorage"] = this.materialOutStorage ? this.materialOutStorage.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialOutStorageDetail {
        const json = this.toJSON();
        let result = new MaterialOutStorageDetail();
        result.init(json);
        return result;
    }
}

export interface IMaterialOutStorageDetail {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    materialOutStorageId: string | undefined;
    materialOutStorage: MaterialOutStorage | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class IEventData implements IIEventData {
    eventTime: Date | undefined;
    eventSource: any | undefined;

    constructor(data?: IIEventData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.eventTime = data["eventTime"] ? new Date(data["eventTime"].toString()) : <any>undefined;
            this.eventSource = data["eventSource"];
        }
    }

    static fromJS(data: any): IEventData {
        data = typeof data === 'object' ? data : {};
        let result = new IEventData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventTime"] = this.eventTime ? this.eventTime.toISOString() : <any>undefined;
        data["eventSource"] = this.eventSource;
        return data; 
    }

    clone(): IEventData {
        const json = this.toJSON();
        let result = new IEventData();
        result.init(json);
        return result;
    }
}

export interface IIEventData {
    eventTime: Date | undefined;
    eventSource: any | undefined;
}

export class PagedResultDtoOfGetMaterialOutStoragePaginationOutput implements IPagedResultDtoOfGetMaterialOutStoragePaginationOutput {
    totalCount: number | undefined;
    items: GetMaterialOutStoragePaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMaterialOutStoragePaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetMaterialOutStoragePaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMaterialOutStoragePaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMaterialOutStoragePaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetMaterialOutStoragePaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetMaterialOutStoragePaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetMaterialOutStoragePaginationOutput {
    totalCount: number | undefined;
    items: GetMaterialOutStoragePaginationOutput[] | undefined;
}

export class GetMaterialOutStoragePaginationOutput implements IGetMaterialOutStoragePaginationOutput {
    materialRequestId: string | undefined;
    requestOrderNo: string | undefined;
    outStorageOrderNo: string | undefined;
    outStorageApprovalState: GetMaterialOutStoragePaginationOutputOutStorageApprovalState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    outStorageType: GetMaterialOutStoragePaginationOutputOutStorageType | undefined;
    outStorageUserId: number | undefined;
    outStorageTime: Date | undefined;
    materialOutStorageDetails: MaterialOutStorageDetailDto[] | undefined;
    k3OutStorageOrderNo: string | undefined;
    isSyncK3: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetMaterialOutStoragePaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialRequestId = data["materialRequestId"];
            this.requestOrderNo = data["requestOrderNo"];
            this.outStorageOrderNo = data["outStorageOrderNo"];
            this.outStorageApprovalState = data["outStorageApprovalState"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.outStorageType = data["outStorageType"];
            this.outStorageUserId = data["outStorageUserId"];
            this.outStorageTime = data["outStorageTime"] ? new Date(data["outStorageTime"].toString()) : <any>undefined;
            if (data["materialOutStorageDetails"] && data["materialOutStorageDetails"].constructor === Array) {
                this.materialOutStorageDetails = [];
                for (let item of data["materialOutStorageDetails"])
                    this.materialOutStorageDetails.push(MaterialOutStorageDetailDto.fromJS(item));
            }
            this.k3OutStorageOrderNo = data["k3OutStorageOrderNo"];
            this.isSyncK3 = data["isSyncK3"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetMaterialOutStoragePaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialOutStoragePaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialRequestId"] = this.materialRequestId;
        data["requestOrderNo"] = this.requestOrderNo;
        data["outStorageOrderNo"] = this.outStorageOrderNo;
        data["outStorageApprovalState"] = this.outStorageApprovalState;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["outStorageType"] = this.outStorageType;
        data["outStorageUserId"] = this.outStorageUserId;
        data["outStorageTime"] = this.outStorageTime ? this.outStorageTime.toISOString() : <any>undefined;
        if (this.materialOutStorageDetails && this.materialOutStorageDetails.constructor === Array) {
            data["materialOutStorageDetails"] = [];
            for (let item of this.materialOutStorageDetails)
                data["materialOutStorageDetails"].push(item.toJSON());
        }
        data["k3OutStorageOrderNo"] = this.k3OutStorageOrderNo;
        data["isSyncK3"] = this.isSyncK3;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetMaterialOutStoragePaginationOutput {
        const json = this.toJSON();
        let result = new GetMaterialOutStoragePaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMaterialOutStoragePaginationOutput {
    materialRequestId: string | undefined;
    requestOrderNo: string | undefined;
    outStorageOrderNo: string | undefined;
    outStorageApprovalState: GetMaterialOutStoragePaginationOutputOutStorageApprovalState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    outStorageType: GetMaterialOutStoragePaginationOutputOutStorageType | undefined;
    outStorageUserId: number | undefined;
    outStorageTime: Date | undefined;
    materialOutStorageDetails: MaterialOutStorageDetailDto[] | undefined;
    k3OutStorageOrderNo: string | undefined;
    isSyncK3: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetMaterialOutStoragePaginationInput implements IGetMaterialOutStoragePaginationInput {
    startDate: Date | undefined;
    endDate: Date | undefined;
    requestOrderNo: string | undefined;
    outStorageOrderNo: string | undefined;
    userId: number | undefined;
    accountOrName: string | undefined;
    instrumentId: string | undefined;
    brandId: string | undefined;
    organizationId: number | undefined;
    materialTypeId: string | undefined;
    storageLocationId: string | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetMaterialOutStoragePaginationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            this.requestOrderNo = data["requestOrderNo"];
            this.outStorageOrderNo = data["outStorageOrderNo"];
            this.userId = data["userId"];
            this.accountOrName = data["accountOrName"];
            this.instrumentId = data["instrumentId"];
            this.brandId = data["brandId"];
            this.organizationId = data["organizationId"];
            this.materialTypeId = data["materialTypeId"];
            this.storageLocationId = data["storageLocationId"];
            this.filter = data["filter"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetMaterialOutStoragePaginationInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialOutStoragePaginationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["requestOrderNo"] = this.requestOrderNo;
        data["outStorageOrderNo"] = this.outStorageOrderNo;
        data["userId"] = this.userId;
        data["accountOrName"] = this.accountOrName;
        data["instrumentId"] = this.instrumentId;
        data["brandId"] = this.brandId;
        data["organizationId"] = this.organizationId;
        data["materialTypeId"] = this.materialTypeId;
        data["storageLocationId"] = this.storageLocationId;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetMaterialOutStoragePaginationInput {
        const json = this.toJSON();
        let result = new GetMaterialOutStoragePaginationInput();
        result.init(json);
        return result;
    }
}

export interface IGetMaterialOutStoragePaginationInput {
    startDate: Date | undefined;
    endDate: Date | undefined;
    requestOrderNo: string | undefined;
    outStorageOrderNo: string | undefined;
    userId: number | undefined;
    accountOrName: string | undefined;
    instrumentId: string | undefined;
    brandId: string | undefined;
    organizationId: number | undefined;
    materialTypeId: string | undefined;
    storageLocationId: string | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class SumQualtityPagedResultDtoOfXGetMaterialOutStoragePaginationOutput implements ISumQualtityPagedResultDtoOfXGetMaterialOutStoragePaginationOutput {
    sumQualtity: number | undefined;
    totalCount: number | undefined;
    items: XGetMaterialOutStoragePaginationOutput[] | undefined;

    constructor(data?: ISumQualtityPagedResultDtoOfXGetMaterialOutStoragePaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sumQualtity = data["sumQualtity"];
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(XGetMaterialOutStoragePaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SumQualtityPagedResultDtoOfXGetMaterialOutStoragePaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SumQualtityPagedResultDtoOfXGetMaterialOutStoragePaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sumQualtity"] = this.sumQualtity;
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SumQualtityPagedResultDtoOfXGetMaterialOutStoragePaginationOutput {
        const json = this.toJSON();
        let result = new SumQualtityPagedResultDtoOfXGetMaterialOutStoragePaginationOutput();
        result.init(json);
        return result;
    }
}

export interface ISumQualtityPagedResultDtoOfXGetMaterialOutStoragePaginationOutput {
    sumQualtity: number | undefined;
    totalCount: number | undefined;
    items: XGetMaterialOutStoragePaginationOutput[] | undefined;
}

export class XGetMaterialOutStoragePaginationOutput implements IXGetMaterialOutStoragePaginationOutput {
    materialOutStorage: XGetMaterialOutStoragePaginationMaterialOutStorageDto | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    material: MaterialShareDto | undefined;

    constructor(data?: IXGetMaterialOutStoragePaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialOutStorage = data["materialOutStorage"] ? XGetMaterialOutStoragePaginationMaterialOutStorageDto.fromJS(data["materialOutStorage"]) : <any>undefined;
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.number = data["number"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.material = data["material"] ? MaterialShareDto.fromJS(data["material"]) : <any>undefined;
        }
    }

    static fromJS(data: any): XGetMaterialOutStoragePaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new XGetMaterialOutStoragePaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialOutStorage"] = this.materialOutStorage ? this.materialOutStorage.toJSON() : <any>undefined;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        return data; 
    }

    clone(): XGetMaterialOutStoragePaginationOutput {
        const json = this.toJSON();
        let result = new XGetMaterialOutStoragePaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IXGetMaterialOutStoragePaginationOutput {
    materialOutStorage: XGetMaterialOutStoragePaginationMaterialOutStorageDto | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    material: MaterialShareDto | undefined;
}

export class XGetMaterialOutStoragePaginationMaterialOutStorageDto implements IXGetMaterialOutStoragePaginationMaterialOutStorageDto {
    materialRequestId: string | undefined;
    requestOrderNo: string | undefined;
    outStorageOrderNo: string | undefined;
    outStorageApprovalState: XGetMaterialOutStoragePaginationMaterialOutStorageDtoOutStorageApprovalState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    outStorageType: XGetMaterialOutStoragePaginationMaterialOutStorageDtoOutStorageType | undefined;
    outStorageUserId: number | undefined;
    outStorageTime: Date | undefined;
    materialOutStorageDetails: MaterialOutStorageDetailDto[] | undefined;
    k3OutStorageOrderNo: string | undefined;
    isSyncK3: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IXGetMaterialOutStoragePaginationMaterialOutStorageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialRequestId = data["materialRequestId"];
            this.requestOrderNo = data["requestOrderNo"];
            this.outStorageOrderNo = data["outStorageOrderNo"];
            this.outStorageApprovalState = data["outStorageApprovalState"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.outStorageType = data["outStorageType"];
            this.outStorageUserId = data["outStorageUserId"];
            this.outStorageTime = data["outStorageTime"] ? new Date(data["outStorageTime"].toString()) : <any>undefined;
            if (data["materialOutStorageDetails"] && data["materialOutStorageDetails"].constructor === Array) {
                this.materialOutStorageDetails = [];
                for (let item of data["materialOutStorageDetails"])
                    this.materialOutStorageDetails.push(MaterialOutStorageDetailDto.fromJS(item));
            }
            this.k3OutStorageOrderNo = data["k3OutStorageOrderNo"];
            this.isSyncK3 = data["isSyncK3"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): XGetMaterialOutStoragePaginationMaterialOutStorageDto {
        data = typeof data === 'object' ? data : {};
        let result = new XGetMaterialOutStoragePaginationMaterialOutStorageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialRequestId"] = this.materialRequestId;
        data["requestOrderNo"] = this.requestOrderNo;
        data["outStorageOrderNo"] = this.outStorageOrderNo;
        data["outStorageApprovalState"] = this.outStorageApprovalState;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["outStorageType"] = this.outStorageType;
        data["outStorageUserId"] = this.outStorageUserId;
        data["outStorageTime"] = this.outStorageTime ? this.outStorageTime.toISOString() : <any>undefined;
        if (this.materialOutStorageDetails && this.materialOutStorageDetails.constructor === Array) {
            data["materialOutStorageDetails"] = [];
            for (let item of this.materialOutStorageDetails)
                data["materialOutStorageDetails"].push(item.toJSON());
        }
        data["k3OutStorageOrderNo"] = this.k3OutStorageOrderNo;
        data["isSyncK3"] = this.isSyncK3;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): XGetMaterialOutStoragePaginationMaterialOutStorageDto {
        const json = this.toJSON();
        let result = new XGetMaterialOutStoragePaginationMaterialOutStorageDto();
        result.init(json);
        return result;
    }
}

export interface IXGetMaterialOutStoragePaginationMaterialOutStorageDto {
    materialRequestId: string | undefined;
    requestOrderNo: string | undefined;
    outStorageOrderNo: string | undefined;
    outStorageApprovalState: XGetMaterialOutStoragePaginationMaterialOutStorageDtoOutStorageApprovalState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    outStorageType: XGetMaterialOutStoragePaginationMaterialOutStorageDtoOutStorageType | undefined;
    outStorageUserId: number | undefined;
    outStorageTime: Date | undefined;
    materialOutStorageDetails: MaterialOutStorageDetailDto[] | undefined;
    k3OutStorageOrderNo: string | undefined;
    isSyncK3: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ValidateMaterialExpiryDateInput implements IValidateMaterialExpiryDateInput {
    materialId: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;

    constructor(data?: IValidateMaterialExpiryDateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ValidateMaterialExpiryDateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateMaterialExpiryDateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): ValidateMaterialExpiryDateInput {
        const json = this.toJSON();
        let result = new ValidateMaterialExpiryDateInput();
        result.init(json);
        return result;
    }
}

export interface IValidateMaterialExpiryDateInput {
    materialId: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
}

export class ValidateMaterialExpiryDateOutput implements IValidateMaterialExpiryDateOutput {
    success: boolean | undefined;

    constructor(data?: IValidateMaterialExpiryDateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.success = data["success"];
        }
    }

    static fromJS(data: any): ValidateMaterialExpiryDateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateMaterialExpiryDateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        return data; 
    }

    clone(): ValidateMaterialExpiryDateOutput {
        const json = this.toJSON();
        let result = new ValidateMaterialExpiryDateOutput();
        result.init(json);
        return result;
    }
}

export interface IValidateMaterialExpiryDateOutput {
    success: boolean | undefined;
}

export class GetMaterialPurchaseForEditOutput implements IGetMaterialPurchaseForEditOutput {
    purchaseOrderNo: string | undefined;
    totalPrice: number | undefined;
    materialPurchaseState: GetMaterialPurchaseForEditOutputMaterialPurchaseState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    isSyncK3: boolean | undefined;
    k3PurchaseOrderNo: string | undefined;
    materialPurchaseDetails: MaterialPurchaseDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetMaterialPurchaseForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.purchaseOrderNo = data["purchaseOrderNo"];
            this.totalPrice = data["totalPrice"];
            this.materialPurchaseState = data["materialPurchaseState"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.applicantUserId = data["applicantUserId"];
            this.applicationTime = data["applicationTime"] ? new Date(data["applicationTime"].toString()) : <any>undefined;
            this.isSyncK3 = data["isSyncK3"];
            this.k3PurchaseOrderNo = data["k3PurchaseOrderNo"];
            if (data["materialPurchaseDetails"] && data["materialPurchaseDetails"].constructor === Array) {
                this.materialPurchaseDetails = [];
                for (let item of data["materialPurchaseDetails"])
                    this.materialPurchaseDetails.push(MaterialPurchaseDetailDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetMaterialPurchaseForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialPurchaseForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["totalPrice"] = this.totalPrice;
        data["materialPurchaseState"] = this.materialPurchaseState;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["applicantUserId"] = this.applicantUserId;
        data["applicationTime"] = this.applicationTime ? this.applicationTime.toISOString() : <any>undefined;
        data["isSyncK3"] = this.isSyncK3;
        data["k3PurchaseOrderNo"] = this.k3PurchaseOrderNo;
        if (this.materialPurchaseDetails && this.materialPurchaseDetails.constructor === Array) {
            data["materialPurchaseDetails"] = [];
            for (let item of this.materialPurchaseDetails)
                data["materialPurchaseDetails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetMaterialPurchaseForEditOutput {
        const json = this.toJSON();
        let result = new GetMaterialPurchaseForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMaterialPurchaseForEditOutput {
    purchaseOrderNo: string | undefined;
    totalPrice: number | undefined;
    materialPurchaseState: GetMaterialPurchaseForEditOutputMaterialPurchaseState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    isSyncK3: boolean | undefined;
    k3PurchaseOrderNo: string | undefined;
    materialPurchaseDetails: MaterialPurchaseDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateOrUpdateMaterialPurchaseInput implements ICreateOrUpdateMaterialPurchaseInput {
    purchase: CreateOrUpdateMaterialPurchaseDto | undefined;
    nextApprovalUser: NextHandleUsersDto | undefined;

    constructor(data?: ICreateOrUpdateMaterialPurchaseInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.purchase = data["purchase"] ? CreateOrUpdateMaterialPurchaseDto.fromJS(data["purchase"]) : <any>undefined;
            this.nextApprovalUser = data["nextApprovalUser"] ? NextHandleUsersDto.fromJS(data["nextApprovalUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrUpdateMaterialPurchaseInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMaterialPurchaseInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchase"] = this.purchase ? this.purchase.toJSON() : <any>undefined;
        data["nextApprovalUser"] = this.nextApprovalUser ? this.nextApprovalUser.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateMaterialPurchaseInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateMaterialPurchaseInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMaterialPurchaseInput {
    purchase: CreateOrUpdateMaterialPurchaseDto | undefined;
    nextApprovalUser: NextHandleUsersDto | undefined;
}

export class CreateOrUpdateMaterialPurchaseDto implements ICreateOrUpdateMaterialPurchaseDto {
    purchaseOrderNo: string | undefined;
    totalPrice: number | undefined;
    materialPurchaseState: CreateOrUpdateMaterialPurchaseDtoMaterialPurchaseState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    materialPurchaseDetails: CreateOrUpdateMaterialPurchaseDetailDto[] | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateMaterialPurchaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.purchaseOrderNo = data["purchaseOrderNo"];
            this.totalPrice = data["totalPrice"];
            this.materialPurchaseState = data["materialPurchaseState"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.applicantUserId = data["applicantUserId"];
            this.applicationTime = data["applicationTime"] ? new Date(data["applicationTime"].toString()) : <any>undefined;
            if (data["materialPurchaseDetails"] && data["materialPurchaseDetails"].constructor === Array) {
                this.materialPurchaseDetails = [];
                for (let item of data["materialPurchaseDetails"])
                    this.materialPurchaseDetails.push(CreateOrUpdateMaterialPurchaseDetailDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateMaterialPurchaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMaterialPurchaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["totalPrice"] = this.totalPrice;
        data["materialPurchaseState"] = this.materialPurchaseState;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["applicantUserId"] = this.applicantUserId;
        data["applicationTime"] = this.applicationTime ? this.applicationTime.toISOString() : <any>undefined;
        if (this.materialPurchaseDetails && this.materialPurchaseDetails.constructor === Array) {
            data["materialPurchaseDetails"] = [];
            for (let item of this.materialPurchaseDetails)
                data["materialPurchaseDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateMaterialPurchaseDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateMaterialPurchaseDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMaterialPurchaseDto {
    purchaseOrderNo: string | undefined;
    totalPrice: number | undefined;
    materialPurchaseState: CreateOrUpdateMaterialPurchaseDtoMaterialPurchaseState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    materialPurchaseDetails: CreateOrUpdateMaterialPurchaseDetailDto[] | undefined;
    id: string | undefined;
}

export class NextHandleUsersDto implements INextHandleUsersDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    roleId: number | undefined;
    approvalGradeType: NextHandleUsersDtoApprovalGradeType | undefined;
    id: number | undefined;

    constructor(data?: INextHandleUsersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.roleId = data["roleId"];
            this.approvalGradeType = data["approvalGradeType"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): NextHandleUsersDto {
        data = typeof data === 'object' ? data : {};
        let result = new NextHandleUsersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["roleId"] = this.roleId;
        data["approvalGradeType"] = this.approvalGradeType;
        data["id"] = this.id;
        return data; 
    }

    clone(): NextHandleUsersDto {
        const json = this.toJSON();
        let result = new NextHandleUsersDto();
        result.init(json);
        return result;
    }
}

export interface INextHandleUsersDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    roleId: number | undefined;
    approvalGradeType: NextHandleUsersDtoApprovalGradeType | undefined;
    id: number | undefined;
}

export class CreateOrUpdateMaterialPurchaseDetailDto implements ICreateOrUpdateMaterialPurchaseDetailDto {
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    price: number | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    remark: string | undefined;
    expectedArrivalDate: Date | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateMaterialPurchaseDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialPurchaseId = data["materialPurchaseId"];
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.price = data["price"];
            this.number = data["number"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.remark = data["remark"];
            this.expectedArrivalDate = data["expectedArrivalDate"] ? new Date(data["expectedArrivalDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateMaterialPurchaseDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMaterialPurchaseDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialPurchaseId"] = this.materialPurchaseId;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["price"] = this.price;
        data["number"] = this.number;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["remark"] = this.remark;
        data["expectedArrivalDate"] = this.expectedArrivalDate ? this.expectedArrivalDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateMaterialPurchaseDetailDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateMaterialPurchaseDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMaterialPurchaseDetailDto {
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    price: number | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    remark: string | undefined;
    expectedArrivalDate: Date | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetMaterialPurchasePaginationOutput implements IPagedResultDtoOfGetMaterialPurchasePaginationOutput {
    totalCount: number | undefined;
    items: GetMaterialPurchasePaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMaterialPurchasePaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetMaterialPurchasePaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMaterialPurchasePaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMaterialPurchasePaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetMaterialPurchasePaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetMaterialPurchasePaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetMaterialPurchasePaginationOutput {
    totalCount: number | undefined;
    items: GetMaterialPurchasePaginationOutput[] | undefined;
}

export class GetMaterialPurchasePaginationOutput implements IGetMaterialPurchasePaginationOutput {
    purchaseOrderNo: string | undefined;
    totalPrice: number | undefined;
    materialPurchaseState: GetMaterialPurchasePaginationOutputMaterialPurchaseState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    isSyncK3: boolean | undefined;
    k3PurchaseOrderNo: string | undefined;
    materialPurchaseDetails: MaterialPurchaseDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetMaterialPurchasePaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.purchaseOrderNo = data["purchaseOrderNo"];
            this.totalPrice = data["totalPrice"];
            this.materialPurchaseState = data["materialPurchaseState"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.applicantUserId = data["applicantUserId"];
            this.applicationTime = data["applicationTime"] ? new Date(data["applicationTime"].toString()) : <any>undefined;
            this.isSyncK3 = data["isSyncK3"];
            this.k3PurchaseOrderNo = data["k3PurchaseOrderNo"];
            if (data["materialPurchaseDetails"] && data["materialPurchaseDetails"].constructor === Array) {
                this.materialPurchaseDetails = [];
                for (let item of data["materialPurchaseDetails"])
                    this.materialPurchaseDetails.push(MaterialPurchaseDetailDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetMaterialPurchasePaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialPurchasePaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["totalPrice"] = this.totalPrice;
        data["materialPurchaseState"] = this.materialPurchaseState;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["applicantUserId"] = this.applicantUserId;
        data["applicationTime"] = this.applicationTime ? this.applicationTime.toISOString() : <any>undefined;
        data["isSyncK3"] = this.isSyncK3;
        data["k3PurchaseOrderNo"] = this.k3PurchaseOrderNo;
        if (this.materialPurchaseDetails && this.materialPurchaseDetails.constructor === Array) {
            data["materialPurchaseDetails"] = [];
            for (let item of this.materialPurchaseDetails)
                data["materialPurchaseDetails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetMaterialPurchasePaginationOutput {
        const json = this.toJSON();
        let result = new GetMaterialPurchasePaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMaterialPurchasePaginationOutput {
    purchaseOrderNo: string | undefined;
    totalPrice: number | undefined;
    materialPurchaseState: GetMaterialPurchasePaginationOutputMaterialPurchaseState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    isSyncK3: boolean | undefined;
    k3PurchaseOrderNo: string | undefined;
    materialPurchaseDetails: MaterialPurchaseDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class WaitingForPurchaseApprovalListInput implements IWaitingForPurchaseApprovalListInput {
    startDate: Date | undefined;
    endDate: Date | undefined;
    purchaseOrderNo: string | undefined;
    userId: number | undefined;
    instrumentId: string | undefined;
    brandId: string | undefined;
    organizationId: number | undefined;
    materialTypeId: string | undefined;
    storageLocationId: string | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IWaitingForPurchaseApprovalListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            this.purchaseOrderNo = data["purchaseOrderNo"];
            this.userId = data["userId"];
            this.instrumentId = data["instrumentId"];
            this.brandId = data["brandId"];
            this.organizationId = data["organizationId"];
            this.materialTypeId = data["materialTypeId"];
            this.storageLocationId = data["storageLocationId"];
            this.filter = data["filter"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): WaitingForPurchaseApprovalListInput {
        data = typeof data === 'object' ? data : {};
        let result = new WaitingForPurchaseApprovalListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["userId"] = this.userId;
        data["instrumentId"] = this.instrumentId;
        data["brandId"] = this.brandId;
        data["organizationId"] = this.organizationId;
        data["materialTypeId"] = this.materialTypeId;
        data["storageLocationId"] = this.storageLocationId;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): WaitingForPurchaseApprovalListInput {
        const json = this.toJSON();
        let result = new WaitingForPurchaseApprovalListInput();
        result.init(json);
        return result;
    }
}

export interface IWaitingForPurchaseApprovalListInput {
    startDate: Date | undefined;
    endDate: Date | undefined;
    purchaseOrderNo: string | undefined;
    userId: number | undefined;
    instrumentId: string | undefined;
    brandId: string | undefined;
    organizationId: number | undefined;
    materialTypeId: string | undefined;
    storageLocationId: string | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfWaitingForPurchaseApprovalListOutput implements IPagedResultDtoOfWaitingForPurchaseApprovalListOutput {
    totalCount: number | undefined;
    items: WaitingForPurchaseApprovalListOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfWaitingForPurchaseApprovalListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(WaitingForPurchaseApprovalListOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWaitingForPurchaseApprovalListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWaitingForPurchaseApprovalListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfWaitingForPurchaseApprovalListOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfWaitingForPurchaseApprovalListOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfWaitingForPurchaseApprovalListOutput {
    totalCount: number | undefined;
    items: WaitingForPurchaseApprovalListOutput[] | undefined;
}

export class WaitingForPurchaseApprovalListOutput implements IWaitingForPurchaseApprovalListOutput {
    purchaseOrderNo: string | undefined;
    materialPurchaseState: WaitingForPurchaseApprovalListOutputMaterialPurchaseState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    materialPurchaseDetails: WaitingForPurchaseApprovalListDetailOutput[] | undefined;
    id: string | undefined;

    constructor(data?: IWaitingForPurchaseApprovalListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.purchaseOrderNo = data["purchaseOrderNo"];
            this.materialPurchaseState = data["materialPurchaseState"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.applicantUserId = data["applicantUserId"];
            this.applicationTime = data["applicationTime"] ? new Date(data["applicationTime"].toString()) : <any>undefined;
            if (data["materialPurchaseDetails"] && data["materialPurchaseDetails"].constructor === Array) {
                this.materialPurchaseDetails = [];
                for (let item of data["materialPurchaseDetails"])
                    this.materialPurchaseDetails.push(WaitingForPurchaseApprovalListDetailOutput.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WaitingForPurchaseApprovalListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WaitingForPurchaseApprovalListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["materialPurchaseState"] = this.materialPurchaseState;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["applicantUserId"] = this.applicantUserId;
        data["applicationTime"] = this.applicationTime ? this.applicationTime.toISOString() : <any>undefined;
        if (this.materialPurchaseDetails && this.materialPurchaseDetails.constructor === Array) {
            data["materialPurchaseDetails"] = [];
            for (let item of this.materialPurchaseDetails)
                data["materialPurchaseDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): WaitingForPurchaseApprovalListOutput {
        const json = this.toJSON();
        let result = new WaitingForPurchaseApprovalListOutput();
        result.init(json);
        return result;
    }
}

export interface IWaitingForPurchaseApprovalListOutput {
    purchaseOrderNo: string | undefined;
    materialPurchaseState: WaitingForPurchaseApprovalListOutputMaterialPurchaseState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    materialPurchaseDetails: WaitingForPurchaseApprovalListDetailOutput[] | undefined;
    id: string | undefined;
}

export class WaitingForPurchaseApprovalListDetailOutput implements IWaitingForPurchaseApprovalListDetailOutput {
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    price: number | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    remark: string | undefined;
    expectedArrivalDate: Date | undefined;
    material: MaterialShareDto | undefined;

    constructor(data?: IWaitingForPurchaseApprovalListDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialPurchaseId = data["materialPurchaseId"];
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.price = data["price"];
            this.number = data["number"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.remark = data["remark"];
            this.expectedArrivalDate = data["expectedArrivalDate"] ? new Date(data["expectedArrivalDate"].toString()) : <any>undefined;
            this.material = data["material"] ? MaterialShareDto.fromJS(data["material"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WaitingForPurchaseApprovalListDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WaitingForPurchaseApprovalListDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialPurchaseId"] = this.materialPurchaseId;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["price"] = this.price;
        data["number"] = this.number;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["remark"] = this.remark;
        data["expectedArrivalDate"] = this.expectedArrivalDate ? this.expectedArrivalDate.toISOString() : <any>undefined;
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        return data; 
    }

    clone(): WaitingForPurchaseApprovalListDetailOutput {
        const json = this.toJSON();
        let result = new WaitingForPurchaseApprovalListDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IWaitingForPurchaseApprovalListDetailOutput {
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    price: number | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    remark: string | undefined;
    expectedArrivalDate: Date | undefined;
    material: MaterialShareDto | undefined;
}

export class WaitingForAcceptanceListInput implements IWaitingForAcceptanceListInput {
    startDate: Date | undefined;
    endDate: Date | undefined;
    purchaseOrderNo: string | undefined;
    isPrint: boolean | undefined;
    instrumentId: string | undefined;
    brandId: string | undefined;
    organizationId: number | undefined;
    materialTypeId: string | undefined;
    storageLocationId: string | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IWaitingForAcceptanceListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            this.purchaseOrderNo = data["purchaseOrderNo"];
            this.isPrint = data["isPrint"];
            this.instrumentId = data["instrumentId"];
            this.brandId = data["brandId"];
            this.organizationId = data["organizationId"];
            this.materialTypeId = data["materialTypeId"];
            this.storageLocationId = data["storageLocationId"];
            this.filter = data["filter"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): WaitingForAcceptanceListInput {
        data = typeof data === 'object' ? data : {};
        let result = new WaitingForAcceptanceListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["isPrint"] = this.isPrint;
        data["instrumentId"] = this.instrumentId;
        data["brandId"] = this.brandId;
        data["organizationId"] = this.organizationId;
        data["materialTypeId"] = this.materialTypeId;
        data["storageLocationId"] = this.storageLocationId;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): WaitingForAcceptanceListInput {
        const json = this.toJSON();
        let result = new WaitingForAcceptanceListInput();
        result.init(json);
        return result;
    }
}

export interface IWaitingForAcceptanceListInput {
    startDate: Date | undefined;
    endDate: Date | undefined;
    purchaseOrderNo: string | undefined;
    isPrint: boolean | undefined;
    instrumentId: string | undefined;
    brandId: string | undefined;
    organizationId: number | undefined;
    materialTypeId: string | undefined;
    storageLocationId: string | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfWaitingForAcceptanceListOutput implements IPagedResultDtoOfWaitingForAcceptanceListOutput {
    totalCount: number | undefined;
    items: WaitingForAcceptanceListOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfWaitingForAcceptanceListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(WaitingForAcceptanceListOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWaitingForAcceptanceListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWaitingForAcceptanceListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfWaitingForAcceptanceListOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfWaitingForAcceptanceListOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfWaitingForAcceptanceListOutput {
    totalCount: number | undefined;
    items: WaitingForAcceptanceListOutput[] | undefined;
}

export class WaitingForAcceptanceListOutput implements IWaitingForAcceptanceListOutput {
    purchase: WaitingForAcceptanceMaterialPurchaseDto | undefined;
    materialOutInStorageInfo: MaterialOutInStorageInfo | undefined;
    printedCount: number | undefined;
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    price: number | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    remark: string | undefined;
    expectedArrivalDate: Date | undefined;
    arrivalState: WaitingForAcceptanceListOutputArrivalState | undefined;
    arrivalNumber: number | undefined;
    material: MaterialShareDto | undefined;
    organizationMaterialShareInfo: OrganizationMaterialShareInfo | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IWaitingForAcceptanceListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.purchase = data["purchase"] ? WaitingForAcceptanceMaterialPurchaseDto.fromJS(data["purchase"]) : <any>undefined;
            this.materialOutInStorageInfo = data["materialOutInStorageInfo"] ? MaterialOutInStorageInfo.fromJS(data["materialOutInStorageInfo"]) : <any>undefined;
            this.printedCount = data["printedCount"];
            this.materialPurchaseId = data["materialPurchaseId"];
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.price = data["price"];
            this.number = data["number"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.remark = data["remark"];
            this.expectedArrivalDate = data["expectedArrivalDate"] ? new Date(data["expectedArrivalDate"].toString()) : <any>undefined;
            this.arrivalState = data["arrivalState"];
            this.arrivalNumber = data["arrivalNumber"];
            this.material = data["material"] ? MaterialShareDto.fromJS(data["material"]) : <any>undefined;
            this.organizationMaterialShareInfo = data["organizationMaterialShareInfo"] ? OrganizationMaterialShareInfo.fromJS(data["organizationMaterialShareInfo"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WaitingForAcceptanceListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WaitingForAcceptanceListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchase"] = this.purchase ? this.purchase.toJSON() : <any>undefined;
        data["materialOutInStorageInfo"] = this.materialOutInStorageInfo ? this.materialOutInStorageInfo.toJSON() : <any>undefined;
        data["printedCount"] = this.printedCount;
        data["materialPurchaseId"] = this.materialPurchaseId;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["price"] = this.price;
        data["number"] = this.number;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["remark"] = this.remark;
        data["expectedArrivalDate"] = this.expectedArrivalDate ? this.expectedArrivalDate.toISOString() : <any>undefined;
        data["arrivalState"] = this.arrivalState;
        data["arrivalNumber"] = this.arrivalNumber;
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        data["organizationMaterialShareInfo"] = this.organizationMaterialShareInfo ? this.organizationMaterialShareInfo.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WaitingForAcceptanceListOutput {
        const json = this.toJSON();
        let result = new WaitingForAcceptanceListOutput();
        result.init(json);
        return result;
    }
}

export interface IWaitingForAcceptanceListOutput {
    purchase: WaitingForAcceptanceMaterialPurchaseDto | undefined;
    materialOutInStorageInfo: MaterialOutInStorageInfo | undefined;
    printedCount: number | undefined;
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    price: number | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    remark: string | undefined;
    expectedArrivalDate: Date | undefined;
    arrivalState: WaitingForAcceptanceListOutputArrivalState | undefined;
    arrivalNumber: number | undefined;
    material: MaterialShareDto | undefined;
    organizationMaterialShareInfo: OrganizationMaterialShareInfo | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class WaitingForAcceptanceMaterialPurchaseDto implements IWaitingForAcceptanceMaterialPurchaseDto {
    purchaseOrderNo: string | undefined;
    totalPrice: number | undefined;
    materialPurchaseState: WaitingForAcceptanceMaterialPurchaseDtoMaterialPurchaseState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IWaitingForAcceptanceMaterialPurchaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.purchaseOrderNo = data["purchaseOrderNo"];
            this.totalPrice = data["totalPrice"];
            this.materialPurchaseState = data["materialPurchaseState"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.applicantUserId = data["applicantUserId"];
            this.applicationTime = data["applicationTime"] ? new Date(data["applicationTime"].toString()) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WaitingForAcceptanceMaterialPurchaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WaitingForAcceptanceMaterialPurchaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["totalPrice"] = this.totalPrice;
        data["materialPurchaseState"] = this.materialPurchaseState;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["applicantUserId"] = this.applicantUserId;
        data["applicationTime"] = this.applicationTime ? this.applicationTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WaitingForAcceptanceMaterialPurchaseDto {
        const json = this.toJSON();
        let result = new WaitingForAcceptanceMaterialPurchaseDto();
        result.init(json);
        return result;
    }
}

export interface IWaitingForAcceptanceMaterialPurchaseDto {
    purchaseOrderNo: string | undefined;
    totalPrice: number | undefined;
    materialPurchaseState: WaitingForAcceptanceMaterialPurchaseDtoMaterialPurchaseState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    applicantUserId: number | undefined;
    applicationTime: Date | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class PurchaseOrderImportOutput implements IPurchaseOrderImportOutput {
    errorInfos: PurchaseOrderImportDto[] | undefined;
    materials: PurchaseOrderImportMaterial[] | undefined;

    constructor(data?: IPurchaseOrderImportOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["errorInfos"] && data["errorInfos"].constructor === Array) {
                this.errorInfos = [];
                for (let item of data["errorInfos"])
                    this.errorInfos.push(PurchaseOrderImportDto.fromJS(item));
            }
            if (data["materials"] && data["materials"].constructor === Array) {
                this.materials = [];
                for (let item of data["materials"])
                    this.materials.push(PurchaseOrderImportMaterial.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PurchaseOrderImportOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOrderImportOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errorInfos && this.errorInfos.constructor === Array) {
            data["errorInfos"] = [];
            for (let item of this.errorInfos)
                data["errorInfos"].push(item.toJSON());
        }
        if (this.materials && this.materials.constructor === Array) {
            data["materials"] = [];
            for (let item of this.materials)
                data["materials"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PurchaseOrderImportOutput {
        const json = this.toJSON();
        let result = new PurchaseOrderImportOutput();
        result.init(json);
        return result;
    }
}

export interface IPurchaseOrderImportOutput {
    errorInfos: PurchaseOrderImportDto[] | undefined;
    materials: PurchaseOrderImportMaterial[] | undefined;
}

export class PurchaseOrderImportDto implements IPurchaseOrderImportDto {
    rowNumber: number | undefined;
    organizationUnitName: string | undefined;
    applicantUserAccount: string | undefined;
    applicationTime: Date | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    number: number | undefined;
    remark: string | undefined;
    message: string | undefined;

    constructor(data?: IPurchaseOrderImportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rowNumber = data["rowNumber"];
            this.organizationUnitName = data["organizationUnitName"];
            this.applicantUserAccount = data["applicantUserAccount"];
            this.applicationTime = data["applicationTime"] ? new Date(data["applicationTime"].toString()) : <any>undefined;
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.number = data["number"];
            this.remark = data["remark"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): PurchaseOrderImportDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOrderImportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowNumber"] = this.rowNumber;
        data["organizationUnitName"] = this.organizationUnitName;
        data["applicantUserAccount"] = this.applicantUserAccount;
        data["applicationTime"] = this.applicationTime ? this.applicationTime.toISOString() : <any>undefined;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["number"] = this.number;
        data["remark"] = this.remark;
        data["message"] = this.message;
        return data; 
    }

    clone(): PurchaseOrderImportDto {
        const json = this.toJSON();
        let result = new PurchaseOrderImportDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseOrderImportDto {
    rowNumber: number | undefined;
    organizationUnitName: string | undefined;
    applicantUserAccount: string | undefined;
    applicationTime: Date | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    number: number | undefined;
    remark: string | undefined;
    message: string | undefined;
}

export class PurchaseOrderImportMaterial implements IPurchaseOrderImportMaterial {
    remark: string | undefined;
    number: number | undefined;
    message: string | undefined;
    systemMaterialCode: string | undefined;
    hospitalMaterialCode: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    specification: string | undefined;
    storageConditionId: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeId: string | undefined;
    temperatureRangeName: string | undefined;
    materialTypeId: string | undefined;
    materialTypeName: string | undefined;
    brandId: string | undefined;
    brandName: string | undefined;
    price: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    minUnitId: string | undefined;
    minUnitName: string | undefined;
    unitConvertRate: number | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    supplierId: string | undefined;
    supplierName: string | undefined;
    deliveryCompanyId: string | undefined;
    deliveryCompanyName: string | undefined;
    invoicingCompanyId: string | undefined;
    invoicingCompanyName: string | undefined;
    isRegistrationCertificate: boolean | undefined;
    registrationCertificateNo: string | undefined;
    registrationCertificateFilePath: string | undefined;
    expiryDate: Date | undefined;
    outBoxExpiryDate: number | undefined;
    instrumentId: string | undefined;
    instrumentName: string | undefined;
    arrivalDateSetting: string | undefined;
    isDisabled: boolean | undefined;
    disabledDate: Date | undefined;
    disabledReasonId: string | undefined;
    disabledReasonName: string | undefined;
    vendorMaterialCode: string | undefined;
    isStopPurchase: boolean | undefined;
    isAutoGenerateUniqueCode: boolean | undefined;
    isEnableVendorMaterialCode: boolean | undefined;
    isEnableOpenLabel: boolean | undefined;
    isHavePpCertificate: boolean | undefined;
    isPublicReagent: boolean | undefined;
    isCombinationReagent: boolean | undefined;
    combinationReagentProportion: string | undefined;
    isInventoryAlert: boolean | undefined;
    alertMaterialNumber: number | undefined;
    alertMinMaterialNumber: number | undefined;
    isAvailableDayAlert: boolean | undefined;
    alertAvailableDay: number | undefined;
    alertMinAvailableDay: number | undefined;
    isAutoPurchaseCalculate: boolean | undefined;
    monthPurchaseUpperLimit: number | undefined;
    isDefaultPurchaseNumber: boolean | undefined;
    defaultPurchaseNumber: number | undefined;
    unitConvertSetting: string | undefined;
    isPerformanceVerification: boolean | undefined;
    methodologyId: string | undefined;
    methodologyName: string | undefined;
    materialOutInStorages: MaterialOutInStorageDto[] | undefined;
    organizationMaterials: OrganizationMaterialDto[] | undefined;
    performanceVerificationMaterials: PerformanceVerificationMaterialDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IPurchaseOrderImportMaterial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.remark = data["remark"];
            this.number = data["number"];
            this.message = data["message"];
            this.systemMaterialCode = data["systemMaterialCode"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.name = data["name"];
            this.shortName = data["shortName"];
            this.specification = data["specification"];
            this.storageConditionId = data["storageConditionId"];
            this.storageConditionName = data["storageConditionName"];
            this.temperatureRangeId = data["temperatureRangeId"];
            this.temperatureRangeName = data["temperatureRangeName"];
            this.materialTypeId = data["materialTypeId"];
            this.materialTypeName = data["materialTypeName"];
            this.brandId = data["brandId"];
            this.brandName = data["brandName"];
            this.price = data["price"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.minUnitId = data["minUnitId"];
            this.minUnitName = data["minUnitName"];
            this.unitConvertRate = data["unitConvertRate"];
            this.manufacturerId = data["manufacturerId"];
            this.manufacturerName = data["manufacturerName"];
            this.supplierId = data["supplierId"];
            this.supplierName = data["supplierName"];
            this.deliveryCompanyId = data["deliveryCompanyId"];
            this.deliveryCompanyName = data["deliveryCompanyName"];
            this.invoicingCompanyId = data["invoicingCompanyId"];
            this.invoicingCompanyName = data["invoicingCompanyName"];
            this.isRegistrationCertificate = data["isRegistrationCertificate"];
            this.registrationCertificateNo = data["registrationCertificateNo"];
            this.registrationCertificateFilePath = data["registrationCertificateFilePath"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.outBoxExpiryDate = data["outBoxExpiryDate"];
            this.instrumentId = data["instrumentId"];
            this.instrumentName = data["instrumentName"];
            this.arrivalDateSetting = data["arrivalDateSetting"];
            this.isDisabled = data["isDisabled"];
            this.disabledDate = data["disabledDate"] ? new Date(data["disabledDate"].toString()) : <any>undefined;
            this.disabledReasonId = data["disabledReasonId"];
            this.disabledReasonName = data["disabledReasonName"];
            this.vendorMaterialCode = data["vendorMaterialCode"];
            this.isStopPurchase = data["isStopPurchase"];
            this.isAutoGenerateUniqueCode = data["isAutoGenerateUniqueCode"];
            this.isEnableVendorMaterialCode = data["isEnableVendorMaterialCode"];
            this.isEnableOpenLabel = data["isEnableOpenLabel"];
            this.isHavePpCertificate = data["isHavePpCertificate"];
            this.isPublicReagent = data["isPublicReagent"];
            this.isCombinationReagent = data["isCombinationReagent"];
            this.combinationReagentProportion = data["combinationReagentProportion"];
            this.isInventoryAlert = data["isInventoryAlert"];
            this.alertMaterialNumber = data["alertMaterialNumber"];
            this.alertMinMaterialNumber = data["alertMinMaterialNumber"];
            this.isAvailableDayAlert = data["isAvailableDayAlert"];
            this.alertAvailableDay = data["alertAvailableDay"];
            this.alertMinAvailableDay = data["alertMinAvailableDay"];
            this.isAutoPurchaseCalculate = data["isAutoPurchaseCalculate"];
            this.monthPurchaseUpperLimit = data["monthPurchaseUpperLimit"];
            this.isDefaultPurchaseNumber = data["isDefaultPurchaseNumber"];
            this.defaultPurchaseNumber = data["defaultPurchaseNumber"];
            this.unitConvertSetting = data["unitConvertSetting"];
            this.isPerformanceVerification = data["isPerformanceVerification"];
            this.methodologyId = data["methodologyId"];
            this.methodologyName = data["methodologyName"];
            if (data["materialOutInStorages"] && data["materialOutInStorages"].constructor === Array) {
                this.materialOutInStorages = [];
                for (let item of data["materialOutInStorages"])
                    this.materialOutInStorages.push(MaterialOutInStorageDto.fromJS(item));
            }
            if (data["organizationMaterials"] && data["organizationMaterials"].constructor === Array) {
                this.organizationMaterials = [];
                for (let item of data["organizationMaterials"])
                    this.organizationMaterials.push(OrganizationMaterialDto.fromJS(item));
            }
            if (data["performanceVerificationMaterials"] && data["performanceVerificationMaterials"].constructor === Array) {
                this.performanceVerificationMaterials = [];
                for (let item of data["performanceVerificationMaterials"])
                    this.performanceVerificationMaterials.push(PerformanceVerificationMaterialDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PurchaseOrderImportMaterial {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOrderImportMaterial();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["remark"] = this.remark;
        data["number"] = this.number;
        data["message"] = this.message;
        data["systemMaterialCode"] = this.systemMaterialCode;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["specification"] = this.specification;
        data["storageConditionId"] = this.storageConditionId;
        data["storageConditionName"] = this.storageConditionName;
        data["temperatureRangeId"] = this.temperatureRangeId;
        data["temperatureRangeName"] = this.temperatureRangeName;
        data["materialTypeId"] = this.materialTypeId;
        data["materialTypeName"] = this.materialTypeName;
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        data["price"] = this.price;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["minUnitId"] = this.minUnitId;
        data["minUnitName"] = this.minUnitName;
        data["unitConvertRate"] = this.unitConvertRate;
        data["manufacturerId"] = this.manufacturerId;
        data["manufacturerName"] = this.manufacturerName;
        data["supplierId"] = this.supplierId;
        data["supplierName"] = this.supplierName;
        data["deliveryCompanyId"] = this.deliveryCompanyId;
        data["deliveryCompanyName"] = this.deliveryCompanyName;
        data["invoicingCompanyId"] = this.invoicingCompanyId;
        data["invoicingCompanyName"] = this.invoicingCompanyName;
        data["isRegistrationCertificate"] = this.isRegistrationCertificate;
        data["registrationCertificateNo"] = this.registrationCertificateNo;
        data["registrationCertificateFilePath"] = this.registrationCertificateFilePath;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["outBoxExpiryDate"] = this.outBoxExpiryDate;
        data["instrumentId"] = this.instrumentId;
        data["instrumentName"] = this.instrumentName;
        data["arrivalDateSetting"] = this.arrivalDateSetting;
        data["isDisabled"] = this.isDisabled;
        data["disabledDate"] = this.disabledDate ? this.disabledDate.toISOString() : <any>undefined;
        data["disabledReasonId"] = this.disabledReasonId;
        data["disabledReasonName"] = this.disabledReasonName;
        data["vendorMaterialCode"] = this.vendorMaterialCode;
        data["isStopPurchase"] = this.isStopPurchase;
        data["isAutoGenerateUniqueCode"] = this.isAutoGenerateUniqueCode;
        data["isEnableVendorMaterialCode"] = this.isEnableVendorMaterialCode;
        data["isEnableOpenLabel"] = this.isEnableOpenLabel;
        data["isHavePpCertificate"] = this.isHavePpCertificate;
        data["isPublicReagent"] = this.isPublicReagent;
        data["isCombinationReagent"] = this.isCombinationReagent;
        data["combinationReagentProportion"] = this.combinationReagentProportion;
        data["isInventoryAlert"] = this.isInventoryAlert;
        data["alertMaterialNumber"] = this.alertMaterialNumber;
        data["alertMinMaterialNumber"] = this.alertMinMaterialNumber;
        data["isAvailableDayAlert"] = this.isAvailableDayAlert;
        data["alertAvailableDay"] = this.alertAvailableDay;
        data["alertMinAvailableDay"] = this.alertMinAvailableDay;
        data["isAutoPurchaseCalculate"] = this.isAutoPurchaseCalculate;
        data["monthPurchaseUpperLimit"] = this.monthPurchaseUpperLimit;
        data["isDefaultPurchaseNumber"] = this.isDefaultPurchaseNumber;
        data["defaultPurchaseNumber"] = this.defaultPurchaseNumber;
        data["unitConvertSetting"] = this.unitConvertSetting;
        data["isPerformanceVerification"] = this.isPerformanceVerification;
        data["methodologyId"] = this.methodologyId;
        data["methodologyName"] = this.methodologyName;
        if (this.materialOutInStorages && this.materialOutInStorages.constructor === Array) {
            data["materialOutInStorages"] = [];
            for (let item of this.materialOutInStorages)
                data["materialOutInStorages"].push(item.toJSON());
        }
        if (this.organizationMaterials && this.organizationMaterials.constructor === Array) {
            data["organizationMaterials"] = [];
            for (let item of this.organizationMaterials)
                data["organizationMaterials"].push(item.toJSON());
        }
        if (this.performanceVerificationMaterials && this.performanceVerificationMaterials.constructor === Array) {
            data["performanceVerificationMaterials"] = [];
            for (let item of this.performanceVerificationMaterials)
                data["performanceVerificationMaterials"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PurchaseOrderImportMaterial {
        const json = this.toJSON();
        let result = new PurchaseOrderImportMaterial();
        result.init(json);
        return result;
    }
}

export interface IPurchaseOrderImportMaterial {
    remark: string | undefined;
    number: number | undefined;
    message: string | undefined;
    systemMaterialCode: string | undefined;
    hospitalMaterialCode: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    specification: string | undefined;
    storageConditionId: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeId: string | undefined;
    temperatureRangeName: string | undefined;
    materialTypeId: string | undefined;
    materialTypeName: string | undefined;
    brandId: string | undefined;
    brandName: string | undefined;
    price: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    minUnitId: string | undefined;
    minUnitName: string | undefined;
    unitConvertRate: number | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    supplierId: string | undefined;
    supplierName: string | undefined;
    deliveryCompanyId: string | undefined;
    deliveryCompanyName: string | undefined;
    invoicingCompanyId: string | undefined;
    invoicingCompanyName: string | undefined;
    isRegistrationCertificate: boolean | undefined;
    registrationCertificateNo: string | undefined;
    registrationCertificateFilePath: string | undefined;
    expiryDate: Date | undefined;
    outBoxExpiryDate: number | undefined;
    instrumentId: string | undefined;
    instrumentName: string | undefined;
    arrivalDateSetting: string | undefined;
    isDisabled: boolean | undefined;
    disabledDate: Date | undefined;
    disabledReasonId: string | undefined;
    disabledReasonName: string | undefined;
    vendorMaterialCode: string | undefined;
    isStopPurchase: boolean | undefined;
    isAutoGenerateUniqueCode: boolean | undefined;
    isEnableVendorMaterialCode: boolean | undefined;
    isEnableOpenLabel: boolean | undefined;
    isHavePpCertificate: boolean | undefined;
    isPublicReagent: boolean | undefined;
    isCombinationReagent: boolean | undefined;
    combinationReagentProportion: string | undefined;
    isInventoryAlert: boolean | undefined;
    alertMaterialNumber: number | undefined;
    alertMinMaterialNumber: number | undefined;
    isAvailableDayAlert: boolean | undefined;
    alertAvailableDay: number | undefined;
    alertMinAvailableDay: number | undefined;
    isAutoPurchaseCalculate: boolean | undefined;
    monthPurchaseUpperLimit: number | undefined;
    isDefaultPurchaseNumber: boolean | undefined;
    defaultPurchaseNumber: number | undefined;
    unitConvertSetting: string | undefined;
    isPerformanceVerification: boolean | undefined;
    methodologyId: string | undefined;
    methodologyName: string | undefined;
    materialOutInStorages: MaterialOutInStorageDto[] | undefined;
    organizationMaterials: OrganizationMaterialDto[] | undefined;
    performanceVerificationMaterials: PerformanceVerificationMaterialDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetMaterialRequestForEditOutput implements IGetMaterialRequestForEditOutput {
    requestOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    targetOrganizationId: number | undefined;
    targetOrganizationName: string | undefined;
    requestPurchaseState: GetMaterialRequestForEditOutputRequestPurchaseState | undefined;
    applicantUserId: string | undefined;
    applicationTime: Date | undefined;
    materialRequestDetails: MaterialRequestDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetMaterialRequestForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requestOrderNo = data["requestOrderNo"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.targetOrganizationId = data["targetOrganizationId"];
            this.targetOrganizationName = data["targetOrganizationName"];
            this.requestPurchaseState = data["requestPurchaseState"];
            this.applicantUserId = data["applicantUserId"];
            this.applicationTime = data["applicationTime"] ? new Date(data["applicationTime"].toString()) : <any>undefined;
            if (data["materialRequestDetails"] && data["materialRequestDetails"].constructor === Array) {
                this.materialRequestDetails = [];
                for (let item of data["materialRequestDetails"])
                    this.materialRequestDetails.push(MaterialRequestDetailDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetMaterialRequestForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialRequestForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestOrderNo"] = this.requestOrderNo;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["targetOrganizationId"] = this.targetOrganizationId;
        data["targetOrganizationName"] = this.targetOrganizationName;
        data["requestPurchaseState"] = this.requestPurchaseState;
        data["applicantUserId"] = this.applicantUserId;
        data["applicationTime"] = this.applicationTime ? this.applicationTime.toISOString() : <any>undefined;
        if (this.materialRequestDetails && this.materialRequestDetails.constructor === Array) {
            data["materialRequestDetails"] = [];
            for (let item of this.materialRequestDetails)
                data["materialRequestDetails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetMaterialRequestForEditOutput {
        const json = this.toJSON();
        let result = new GetMaterialRequestForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMaterialRequestForEditOutput {
    requestOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    targetOrganizationId: number | undefined;
    targetOrganizationName: string | undefined;
    requestPurchaseState: GetMaterialRequestForEditOutputRequestPurchaseState | undefined;
    applicantUserId: string | undefined;
    applicationTime: Date | undefined;
    materialRequestDetails: MaterialRequestDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class MaterialRequestDetailDto implements IMaterialRequestDetailDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    requestedNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    remark: string | undefined;
    materialRequestId: string | undefined;
    material: MaterialShareDto | undefined;
    organizationMaterialShareInfo: OrganizationMaterialShareInfo | undefined;

    constructor(data?: IMaterialRequestDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.number = data["number"];
            this.requestedNumber = data["requestedNumber"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.remark = data["remark"];
            this.materialRequestId = data["materialRequestId"];
            this.material = data["material"] ? MaterialShareDto.fromJS(data["material"]) : <any>undefined;
            this.organizationMaterialShareInfo = data["organizationMaterialShareInfo"] ? OrganizationMaterialShareInfo.fromJS(data["organizationMaterialShareInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MaterialRequestDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialRequestDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["requestedNumber"] = this.requestedNumber;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["remark"] = this.remark;
        data["materialRequestId"] = this.materialRequestId;
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        data["organizationMaterialShareInfo"] = this.organizationMaterialShareInfo ? this.organizationMaterialShareInfo.toJSON() : <any>undefined;
        return data; 
    }

    clone(): MaterialRequestDetailDto {
        const json = this.toJSON();
        let result = new MaterialRequestDetailDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialRequestDetailDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    requestedNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    remark: string | undefined;
    materialRequestId: string | undefined;
    material: MaterialShareDto | undefined;
    organizationMaterialShareInfo: OrganizationMaterialShareInfo | undefined;
}

export class CreateOrUpdateMaterialRequestInput implements ICreateOrUpdateMaterialRequestInput {
    request: CreateOrUpdateMaterialRequestDto | undefined;
    nextApprovalUser: NextHandleUsersDto | undefined;

    constructor(data?: ICreateOrUpdateMaterialRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.request = data["request"] ? CreateOrUpdateMaterialRequestDto.fromJS(data["request"]) : <any>undefined;
            this.nextApprovalUser = data["nextApprovalUser"] ? NextHandleUsersDto.fromJS(data["nextApprovalUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrUpdateMaterialRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMaterialRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["nextApprovalUser"] = this.nextApprovalUser ? this.nextApprovalUser.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateMaterialRequestInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateMaterialRequestInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMaterialRequestInput {
    request: CreateOrUpdateMaterialRequestDto | undefined;
    nextApprovalUser: NextHandleUsersDto | undefined;
}

export class CreateOrUpdateMaterialRequestDto implements ICreateOrUpdateMaterialRequestDto {
    requestOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    targetOrganizationId: number | undefined;
    targetOrganizationName: string | undefined;
    requestPurchaseState: CreateOrUpdateMaterialRequestDtoRequestPurchaseState | undefined;
    applicantUserId: string | undefined;
    applicationTime: Date | undefined;
    materialRequestDetails: CreateOrUpdateMaterialRequestDetailDto[] | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateMaterialRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requestOrderNo = data["requestOrderNo"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.targetOrganizationId = data["targetOrganizationId"];
            this.targetOrganizationName = data["targetOrganizationName"];
            this.requestPurchaseState = data["requestPurchaseState"];
            this.applicantUserId = data["applicantUserId"];
            this.applicationTime = data["applicationTime"] ? new Date(data["applicationTime"].toString()) : <any>undefined;
            if (data["materialRequestDetails"] && data["materialRequestDetails"].constructor === Array) {
                this.materialRequestDetails = [];
                for (let item of data["materialRequestDetails"])
                    this.materialRequestDetails.push(CreateOrUpdateMaterialRequestDetailDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateMaterialRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMaterialRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestOrderNo"] = this.requestOrderNo;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["targetOrganizationId"] = this.targetOrganizationId;
        data["targetOrganizationName"] = this.targetOrganizationName;
        data["requestPurchaseState"] = this.requestPurchaseState;
        data["applicantUserId"] = this.applicantUserId;
        data["applicationTime"] = this.applicationTime ? this.applicationTime.toISOString() : <any>undefined;
        if (this.materialRequestDetails && this.materialRequestDetails.constructor === Array) {
            data["materialRequestDetails"] = [];
            for (let item of this.materialRequestDetails)
                data["materialRequestDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateMaterialRequestDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateMaterialRequestDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMaterialRequestDto {
    requestOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    targetOrganizationId: number | undefined;
    targetOrganizationName: string | undefined;
    requestPurchaseState: CreateOrUpdateMaterialRequestDtoRequestPurchaseState | undefined;
    applicantUserId: string | undefined;
    applicationTime: Date | undefined;
    materialRequestDetails: CreateOrUpdateMaterialRequestDetailDto[] | undefined;
    id: string | undefined;
}

export class CreateOrUpdateMaterialRequestDetailDto implements ICreateOrUpdateMaterialRequestDetailDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    requestedNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    remark: string | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateMaterialRequestDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.number = data["number"];
            this.requestedNumber = data["requestedNumber"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.remark = data["remark"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateMaterialRequestDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMaterialRequestDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["requestedNumber"] = this.requestedNumber;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["remark"] = this.remark;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateMaterialRequestDetailDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateMaterialRequestDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMaterialRequestDetailDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    requestedNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    remark: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetMaterialRequestPaginationOutput implements IPagedResultDtoOfGetMaterialRequestPaginationOutput {
    totalCount: number | undefined;
    items: GetMaterialRequestPaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMaterialRequestPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetMaterialRequestPaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMaterialRequestPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMaterialRequestPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetMaterialRequestPaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetMaterialRequestPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetMaterialRequestPaginationOutput {
    totalCount: number | undefined;
    items: GetMaterialRequestPaginationOutput[] | undefined;
}

export class GetMaterialRequestPaginationOutput implements IGetMaterialRequestPaginationOutput {
    requestOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    targetOrganizationId: number | undefined;
    targetOrganizationName: string | undefined;
    requestPurchaseState: GetMaterialRequestPaginationOutputRequestPurchaseState | undefined;
    applicantUserId: string | undefined;
    applicationTime: Date | undefined;
    materialRequestDetails: MaterialRequestDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetMaterialRequestPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requestOrderNo = data["requestOrderNo"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.targetOrganizationId = data["targetOrganizationId"];
            this.targetOrganizationName = data["targetOrganizationName"];
            this.requestPurchaseState = data["requestPurchaseState"];
            this.applicantUserId = data["applicantUserId"];
            this.applicationTime = data["applicationTime"] ? new Date(data["applicationTime"].toString()) : <any>undefined;
            if (data["materialRequestDetails"] && data["materialRequestDetails"].constructor === Array) {
                this.materialRequestDetails = [];
                for (let item of data["materialRequestDetails"])
                    this.materialRequestDetails.push(MaterialRequestDetailDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetMaterialRequestPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialRequestPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestOrderNo"] = this.requestOrderNo;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["targetOrganizationId"] = this.targetOrganizationId;
        data["targetOrganizationName"] = this.targetOrganizationName;
        data["requestPurchaseState"] = this.requestPurchaseState;
        data["applicantUserId"] = this.applicantUserId;
        data["applicationTime"] = this.applicationTime ? this.applicationTime.toISOString() : <any>undefined;
        if (this.materialRequestDetails && this.materialRequestDetails.constructor === Array) {
            data["materialRequestDetails"] = [];
            for (let item of this.materialRequestDetails)
                data["materialRequestDetails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetMaterialRequestPaginationOutput {
        const json = this.toJSON();
        let result = new GetMaterialRequestPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMaterialRequestPaginationOutput {
    requestOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    targetOrganizationId: number | undefined;
    targetOrganizationName: string | undefined;
    requestPurchaseState: GetMaterialRequestPaginationOutputRequestPurchaseState | undefined;
    applicantUserId: string | undefined;
    applicationTime: Date | undefined;
    materialRequestDetails: MaterialRequestDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class WaitingForMaterialRequestApprovalListInput implements IWaitingForMaterialRequestApprovalListInput {
    startDate: Date | undefined;
    endDate: Date | undefined;
    requestOrderNo: string | undefined;
    userId: number | undefined;
    instrumentId: string | undefined;
    brandId: string | undefined;
    organizationId: number | undefined;
    materialTypeId: string | undefined;
    storageLocationId: string | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IWaitingForMaterialRequestApprovalListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            this.requestOrderNo = data["requestOrderNo"];
            this.userId = data["userId"];
            this.instrumentId = data["instrumentId"];
            this.brandId = data["brandId"];
            this.organizationId = data["organizationId"];
            this.materialTypeId = data["materialTypeId"];
            this.storageLocationId = data["storageLocationId"];
            this.filter = data["filter"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): WaitingForMaterialRequestApprovalListInput {
        data = typeof data === 'object' ? data : {};
        let result = new WaitingForMaterialRequestApprovalListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["requestOrderNo"] = this.requestOrderNo;
        data["userId"] = this.userId;
        data["instrumentId"] = this.instrumentId;
        data["brandId"] = this.brandId;
        data["organizationId"] = this.organizationId;
        data["materialTypeId"] = this.materialTypeId;
        data["storageLocationId"] = this.storageLocationId;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): WaitingForMaterialRequestApprovalListInput {
        const json = this.toJSON();
        let result = new WaitingForMaterialRequestApprovalListInput();
        result.init(json);
        return result;
    }
}

export interface IWaitingForMaterialRequestApprovalListInput {
    startDate: Date | undefined;
    endDate: Date | undefined;
    requestOrderNo: string | undefined;
    userId: number | undefined;
    instrumentId: string | undefined;
    brandId: string | undefined;
    organizationId: number | undefined;
    materialTypeId: string | undefined;
    storageLocationId: string | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfWaitingForMaterialRequestApprovalListOutput implements IPagedResultDtoOfWaitingForMaterialRequestApprovalListOutput {
    totalCount: number | undefined;
    items: WaitingForMaterialRequestApprovalListOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfWaitingForMaterialRequestApprovalListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(WaitingForMaterialRequestApprovalListOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWaitingForMaterialRequestApprovalListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWaitingForMaterialRequestApprovalListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfWaitingForMaterialRequestApprovalListOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfWaitingForMaterialRequestApprovalListOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfWaitingForMaterialRequestApprovalListOutput {
    totalCount: number | undefined;
    items: WaitingForMaterialRequestApprovalListOutput[] | undefined;
}

export class WaitingForMaterialRequestApprovalListOutput implements IWaitingForMaterialRequestApprovalListOutput {
    requestOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    targetOrganizationId: number | undefined;
    targetOrganizationName: string | undefined;
    requestPurchaseState: WaitingForMaterialRequestApprovalListOutputRequestPurchaseState | undefined;
    applicantUserId: string | undefined;
    applicationTime: Date | undefined;
    materialRequestDetails: MaterialRequestDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IWaitingForMaterialRequestApprovalListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requestOrderNo = data["requestOrderNo"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.targetOrganizationId = data["targetOrganizationId"];
            this.targetOrganizationName = data["targetOrganizationName"];
            this.requestPurchaseState = data["requestPurchaseState"];
            this.applicantUserId = data["applicantUserId"];
            this.applicationTime = data["applicationTime"] ? new Date(data["applicationTime"].toString()) : <any>undefined;
            if (data["materialRequestDetails"] && data["materialRequestDetails"].constructor === Array) {
                this.materialRequestDetails = [];
                for (let item of data["materialRequestDetails"])
                    this.materialRequestDetails.push(MaterialRequestDetailDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WaitingForMaterialRequestApprovalListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WaitingForMaterialRequestApprovalListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestOrderNo"] = this.requestOrderNo;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["targetOrganizationId"] = this.targetOrganizationId;
        data["targetOrganizationName"] = this.targetOrganizationName;
        data["requestPurchaseState"] = this.requestPurchaseState;
        data["applicantUserId"] = this.applicantUserId;
        data["applicationTime"] = this.applicationTime ? this.applicationTime.toISOString() : <any>undefined;
        if (this.materialRequestDetails && this.materialRequestDetails.constructor === Array) {
            data["materialRequestDetails"] = [];
            for (let item of this.materialRequestDetails)
                data["materialRequestDetails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WaitingForMaterialRequestApprovalListOutput {
        const json = this.toJSON();
        let result = new WaitingForMaterialRequestApprovalListOutput();
        result.init(json);
        return result;
    }
}

export interface IWaitingForMaterialRequestApprovalListOutput {
    requestOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    targetOrganizationId: number | undefined;
    targetOrganizationName: string | undefined;
    requestPurchaseState: WaitingForMaterialRequestApprovalListOutputRequestPurchaseState | undefined;
    applicantUserId: string | undefined;
    applicationTime: Date | undefined;
    materialRequestDetails: MaterialRequestDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class RequestOutStorageInput implements IRequestOutStorageInput {
    materialRequestId: string | undefined;
    requestOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    materialOutStorageDetails: RequestOutStorageDetailInput[] | undefined;

    constructor(data?: IRequestOutStorageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialRequestId = data["materialRequestId"];
            this.requestOrderNo = data["requestOrderNo"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            if (data["materialOutStorageDetails"] && data["materialOutStorageDetails"].constructor === Array) {
                this.materialOutStorageDetails = [];
                for (let item of data["materialOutStorageDetails"])
                    this.materialOutStorageDetails.push(RequestOutStorageDetailInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestOutStorageInput {
        data = typeof data === 'object' ? data : {};
        let result = new RequestOutStorageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialRequestId"] = this.materialRequestId;
        data["requestOrderNo"] = this.requestOrderNo;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        if (this.materialOutStorageDetails && this.materialOutStorageDetails.constructor === Array) {
            data["materialOutStorageDetails"] = [];
            for (let item of this.materialOutStorageDetails)
                data["materialOutStorageDetails"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RequestOutStorageInput {
        const json = this.toJSON();
        let result = new RequestOutStorageInput();
        result.init(json);
        return result;
    }
}

export interface IRequestOutStorageInput {
    materialRequestId: string | undefined;
    requestOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    materialOutStorageDetails: RequestOutStorageDetailInput[] | undefined;
}

export class RequestOutStorageDetailInput implements IRequestOutStorageDetailInput {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;

    constructor(data?: IRequestOutStorageDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.number = data["number"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
        }
    }

    static fromJS(data: any): RequestOutStorageDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new RequestOutStorageDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        return data; 
    }

    clone(): RequestOutStorageDetailInput {
        const json = this.toJSON();
        let result = new RequestOutStorageDetailInput();
        result.init(json);
        return result;
    }
}

export interface IRequestOutStorageDetailInput {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
}

export class WaitingForAcceptanceRequestListInput implements IWaitingForAcceptanceRequestListInput {
    startDate: Date | undefined;
    endDate: Date | undefined;
    requestOrderNo: string | undefined;
    instrumentId: string | undefined;
    brandId: string | undefined;
    organizationId: number | undefined;
    materialTypeId: string | undefined;
    storageLocationId: string | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IWaitingForAcceptanceRequestListInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            this.requestOrderNo = data["requestOrderNo"];
            this.instrumentId = data["instrumentId"];
            this.brandId = data["brandId"];
            this.organizationId = data["organizationId"];
            this.materialTypeId = data["materialTypeId"];
            this.storageLocationId = data["storageLocationId"];
            this.filter = data["filter"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): WaitingForAcceptanceRequestListInput {
        data = typeof data === 'object' ? data : {};
        let result = new WaitingForAcceptanceRequestListInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["requestOrderNo"] = this.requestOrderNo;
        data["instrumentId"] = this.instrumentId;
        data["brandId"] = this.brandId;
        data["organizationId"] = this.organizationId;
        data["materialTypeId"] = this.materialTypeId;
        data["storageLocationId"] = this.storageLocationId;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): WaitingForAcceptanceRequestListInput {
        const json = this.toJSON();
        let result = new WaitingForAcceptanceRequestListInput();
        result.init(json);
        return result;
    }
}

export interface IWaitingForAcceptanceRequestListInput {
    startDate: Date | undefined;
    endDate: Date | undefined;
    requestOrderNo: string | undefined;
    instrumentId: string | undefined;
    brandId: string | undefined;
    organizationId: number | undefined;
    materialTypeId: string | undefined;
    storageLocationId: string | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class PagedResultDtoOfWaitingForAcceptanceRequestListOutput implements IPagedResultDtoOfWaitingForAcceptanceRequestListOutput {
    totalCount: number | undefined;
    items: WaitingForAcceptanceRequestListOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfWaitingForAcceptanceRequestListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(WaitingForAcceptanceRequestListOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWaitingForAcceptanceRequestListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWaitingForAcceptanceRequestListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfWaitingForAcceptanceRequestListOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfWaitingForAcceptanceRequestListOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfWaitingForAcceptanceRequestListOutput {
    totalCount: number | undefined;
    items: WaitingForAcceptanceRequestListOutput[] | undefined;
}

export class WaitingForAcceptanceRequestListOutput implements IWaitingForAcceptanceRequestListOutput {
    request: WaitingForAcceptanceMaterialRequestDto | undefined;
    materialOutInStorageInfo: MaterialOutInStorageInfo | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    requestedNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    remark: string | undefined;
    materialRequestId: string | undefined;
    material: MaterialShareDto | undefined;
    organizationMaterialShareInfo: OrganizationMaterialShareInfo | undefined;
    id: string | undefined;

    constructor(data?: IWaitingForAcceptanceRequestListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.request = data["request"] ? WaitingForAcceptanceMaterialRequestDto.fromJS(data["request"]) : <any>undefined;
            this.materialOutInStorageInfo = data["materialOutInStorageInfo"] ? MaterialOutInStorageInfo.fromJS(data["materialOutInStorageInfo"]) : <any>undefined;
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.number = data["number"];
            this.requestedNumber = data["requestedNumber"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.remark = data["remark"];
            this.materialRequestId = data["materialRequestId"];
            this.material = data["material"] ? MaterialShareDto.fromJS(data["material"]) : <any>undefined;
            this.organizationMaterialShareInfo = data["organizationMaterialShareInfo"] ? OrganizationMaterialShareInfo.fromJS(data["organizationMaterialShareInfo"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WaitingForAcceptanceRequestListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WaitingForAcceptanceRequestListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["materialOutInStorageInfo"] = this.materialOutInStorageInfo ? this.materialOutInStorageInfo.toJSON() : <any>undefined;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["requestedNumber"] = this.requestedNumber;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["remark"] = this.remark;
        data["materialRequestId"] = this.materialRequestId;
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        data["organizationMaterialShareInfo"] = this.organizationMaterialShareInfo ? this.organizationMaterialShareInfo.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): WaitingForAcceptanceRequestListOutput {
        const json = this.toJSON();
        let result = new WaitingForAcceptanceRequestListOutput();
        result.init(json);
        return result;
    }
}

export interface IWaitingForAcceptanceRequestListOutput {
    request: WaitingForAcceptanceMaterialRequestDto | undefined;
    materialOutInStorageInfo: MaterialOutInStorageInfo | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    requestedNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    remark: string | undefined;
    materialRequestId: string | undefined;
    material: MaterialShareDto | undefined;
    organizationMaterialShareInfo: OrganizationMaterialShareInfo | undefined;
    id: string | undefined;
}

export class WaitingForAcceptanceMaterialRequestDto implements IWaitingForAcceptanceMaterialRequestDto {
    requestOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    targetOrganizationId: number | undefined;
    targetOrganizationName: string | undefined;
    requestPurchaseState: WaitingForAcceptanceMaterialRequestDtoRequestPurchaseState | undefined;
    applicantUserId: string | undefined;
    applicationTime: Date | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IWaitingForAcceptanceMaterialRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requestOrderNo = data["requestOrderNo"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.targetOrganizationId = data["targetOrganizationId"];
            this.targetOrganizationName = data["targetOrganizationName"];
            this.requestPurchaseState = data["requestPurchaseState"];
            this.applicantUserId = data["applicantUserId"];
            this.applicationTime = data["applicationTime"] ? new Date(data["applicationTime"].toString()) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WaitingForAcceptanceMaterialRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new WaitingForAcceptanceMaterialRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestOrderNo"] = this.requestOrderNo;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["targetOrganizationId"] = this.targetOrganizationId;
        data["targetOrganizationName"] = this.targetOrganizationName;
        data["requestPurchaseState"] = this.requestPurchaseState;
        data["applicantUserId"] = this.applicantUserId;
        data["applicationTime"] = this.applicationTime ? this.applicationTime.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WaitingForAcceptanceMaterialRequestDto {
        const json = this.toJSON();
        let result = new WaitingForAcceptanceMaterialRequestDto();
        result.init(json);
        return result;
    }
}

export interface IWaitingForAcceptanceMaterialRequestDto {
    requestOrderNo: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    targetOrganizationId: number | undefined;
    targetOrganizationName: string | undefined;
    requestPurchaseState: WaitingForAcceptanceMaterialRequestDtoRequestPurchaseState | undefined;
    applicantUserId: string | undefined;
    applicationTime: Date | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetMaterialStockForEditOutput implements IGetMaterialStockForEditOutput {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseInfoName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetMaterialStockForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.number = data["number"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.warehouseInfoId = data["warehouseInfoId"];
            this.warehouseInfoName = data["warehouseInfoName"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetMaterialStockForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialStockForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["warehouseInfoId"] = this.warehouseInfoId;
        data["warehouseInfoName"] = this.warehouseInfoName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetMaterialStockForEditOutput {
        const json = this.toJSON();
        let result = new GetMaterialStockForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMaterialStockForEditOutput {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseInfoName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateOrUpdateMaterialStockInput implements ICreateOrUpdateMaterialStockInput {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseInfoName: string | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateMaterialStockInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.number = data["number"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.warehouseInfoId = data["warehouseInfoId"];
            this.warehouseInfoName = data["warehouseInfoName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateMaterialStockInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMaterialStockInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["warehouseInfoId"] = this.warehouseInfoId;
        data["warehouseInfoName"] = this.warehouseInfoName;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateMaterialStockInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateMaterialStockInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMaterialStockInput {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseInfoName: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetMaterialStockPaginationOutput implements IPagedResultDtoOfGetMaterialStockPaginationOutput {
    totalCount: number | undefined;
    items: GetMaterialStockPaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMaterialStockPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetMaterialStockPaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMaterialStockPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMaterialStockPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetMaterialStockPaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetMaterialStockPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetMaterialStockPaginationOutput {
    totalCount: number | undefined;
    items: GetMaterialStockPaginationOutput[] | undefined;
}

export class GetMaterialStockPaginationOutput implements IGetMaterialStockPaginationOutput {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    materialNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseInfoName: string | undefined;
    material: MaterialShareDto | undefined;
    materialOutInStorageInfo: MaterialOutInStorageInfo | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetMaterialStockPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.number = data["number"];
            this.materialNumber = data["materialNumber"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.warehouseInfoId = data["warehouseInfoId"];
            this.warehouseInfoName = data["warehouseInfoName"];
            this.material = data["material"] ? MaterialShareDto.fromJS(data["material"]) : <any>undefined;
            this.materialOutInStorageInfo = data["materialOutInStorageInfo"] ? MaterialOutInStorageInfo.fromJS(data["materialOutInStorageInfo"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetMaterialStockPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialStockPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["materialNumber"] = this.materialNumber;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["warehouseInfoId"] = this.warehouseInfoId;
        data["warehouseInfoName"] = this.warehouseInfoName;
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        data["materialOutInStorageInfo"] = this.materialOutInStorageInfo ? this.materialOutInStorageInfo.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetMaterialStockPaginationOutput {
        const json = this.toJSON();
        let result = new GetMaterialStockPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMaterialStockPaginationOutput {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    materialNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseInfoName: string | undefined;
    material: MaterialShareDto | undefined;
    materialOutInStorageInfo: MaterialOutInStorageInfo | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class MaterialStockOutOrStorageInput implements IMaterialStockOutOrStorageInput {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseInfoName: string | undefined;
    outInStorageType: MaterialStockOutOrStorageInputOutInStorageType | undefined;

    constructor(data?: IMaterialStockOutOrStorageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.number = data["number"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.warehouseInfoId = data["warehouseInfoId"];
            this.warehouseInfoName = data["warehouseInfoName"];
            this.outInStorageType = data["outInStorageType"];
        }
    }

    static fromJS(data: any): MaterialStockOutOrStorageInput {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialStockOutOrStorageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["warehouseInfoId"] = this.warehouseInfoId;
        data["warehouseInfoName"] = this.warehouseInfoName;
        data["outInStorageType"] = this.outInStorageType;
        return data; 
    }

    clone(): MaterialStockOutOrStorageInput {
        const json = this.toJSON();
        let result = new MaterialStockOutOrStorageInput();
        result.init(json);
        return result;
    }
}

export interface IMaterialStockOutOrStorageInput {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    number: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseInfoName: string | undefined;
    outInStorageType: MaterialStockOutOrStorageInputOutInStorageType | undefined;
}

export class GetMaterialStorageForEditOutput implements IGetMaterialStorageForEditOutput {
    storageOrderNo: string | undefined;
    totalPrice: number | undefined;
    storageApprovalState: GetMaterialStorageForEditOutputStorageApprovalState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    storageUserId: number | undefined;
    storageTime: Date | undefined;
    storageType: GetMaterialStorageForEditOutputStorageType | undefined;
    materialStorageDetails: MaterialStorageDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetMaterialStorageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.storageOrderNo = data["storageOrderNo"];
            this.totalPrice = data["totalPrice"];
            this.storageApprovalState = data["storageApprovalState"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.storageUserId = data["storageUserId"];
            this.storageTime = data["storageTime"] ? new Date(data["storageTime"].toString()) : <any>undefined;
            this.storageType = data["storageType"];
            if (data["materialStorageDetails"] && data["materialStorageDetails"].constructor === Array) {
                this.materialStorageDetails = [];
                for (let item of data["materialStorageDetails"])
                    this.materialStorageDetails.push(MaterialStorageDetailDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetMaterialStorageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialStorageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storageOrderNo"] = this.storageOrderNo;
        data["totalPrice"] = this.totalPrice;
        data["storageApprovalState"] = this.storageApprovalState;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["storageUserId"] = this.storageUserId;
        data["storageTime"] = this.storageTime ? this.storageTime.toISOString() : <any>undefined;
        data["storageType"] = this.storageType;
        if (this.materialStorageDetails && this.materialStorageDetails.constructor === Array) {
            data["materialStorageDetails"] = [];
            for (let item of this.materialStorageDetails)
                data["materialStorageDetails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetMaterialStorageForEditOutput {
        const json = this.toJSON();
        let result = new GetMaterialStorageForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMaterialStorageForEditOutput {
    storageOrderNo: string | undefined;
    totalPrice: number | undefined;
    storageApprovalState: GetMaterialStorageForEditOutputStorageApprovalState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    storageUserId: number | undefined;
    storageTime: Date | undefined;
    storageType: GetMaterialStorageForEditOutputStorageType | undefined;
    materialStorageDetails: MaterialStorageDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class MaterialStorageDetailDto implements IMaterialStorageDetailDto {
    purchaseOrderNo: string | undefined;
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    actualNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    deliveryNumber: number | undefined;
    deliveryDate: Date | undefined;
    ppCertificateFilePath: string | undefined;
    invoiceNo: string | undefined;
    invoiceAmount: number | undefined;
    deliveryOrderNo: string | undefined;
    isPackageComplete: boolean | undefined;
    isMaterialWithTicket: boolean | undefined;
    temperature: string | undefined;
    materialStorageId: string | undefined;
    material: MaterialShareDto | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IMaterialStorageDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.purchaseOrderNo = data["purchaseOrderNo"];
            this.materialPurchaseId = data["materialPurchaseId"];
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.actualNumber = data["actualNumber"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.deliveryNumber = data["deliveryNumber"];
            this.deliveryDate = data["deliveryDate"] ? new Date(data["deliveryDate"].toString()) : <any>undefined;
            this.ppCertificateFilePath = data["ppCertificateFilePath"];
            this.invoiceNo = data["invoiceNo"];
            this.invoiceAmount = data["invoiceAmount"];
            this.deliveryOrderNo = data["deliveryOrderNo"];
            this.isPackageComplete = data["isPackageComplete"];
            this.isMaterialWithTicket = data["isMaterialWithTicket"];
            this.temperature = data["temperature"];
            this.materialStorageId = data["materialStorageId"];
            this.material = data["material"] ? MaterialShareDto.fromJS(data["material"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MaterialStorageDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialStorageDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["materialPurchaseId"] = this.materialPurchaseId;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["actualNumber"] = this.actualNumber;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["deliveryNumber"] = this.deliveryNumber;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["ppCertificateFilePath"] = this.ppCertificateFilePath;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceAmount"] = this.invoiceAmount;
        data["deliveryOrderNo"] = this.deliveryOrderNo;
        data["isPackageComplete"] = this.isPackageComplete;
        data["isMaterialWithTicket"] = this.isMaterialWithTicket;
        data["temperature"] = this.temperature;
        data["materialStorageId"] = this.materialStorageId;
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialStorageDetailDto {
        const json = this.toJSON();
        let result = new MaterialStorageDetailDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialStorageDetailDto {
    purchaseOrderNo: string | undefined;
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    actualNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    deliveryNumber: number | undefined;
    deliveryDate: Date | undefined;
    ppCertificateFilePath: string | undefined;
    invoiceNo: string | undefined;
    invoiceAmount: number | undefined;
    deliveryOrderNo: string | undefined;
    isPackageComplete: boolean | undefined;
    isMaterialWithTicket: boolean | undefined;
    temperature: string | undefined;
    materialStorageId: string | undefined;
    material: MaterialShareDto | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateOrUpdateMaterialStorageInput implements ICreateOrUpdateMaterialStorageInput {
    storageOrderNo: string | undefined;
    totalPrice: number | undefined;
    storageApprovalState: CreateOrUpdateMaterialStorageInputStorageApprovalState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    storageUserId: number | undefined;
    storageTime: Date | undefined;
    storageType: CreateOrUpdateMaterialStorageInputStorageType | undefined;
    materialStorageDetails: CreateOrUpdateMaterialStorageDetailDto[] | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateMaterialStorageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.storageOrderNo = data["storageOrderNo"];
            this.totalPrice = data["totalPrice"];
            this.storageApprovalState = data["storageApprovalState"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.storageUserId = data["storageUserId"];
            this.storageTime = data["storageTime"] ? new Date(data["storageTime"].toString()) : <any>undefined;
            this.storageType = data["storageType"];
            if (data["materialStorageDetails"] && data["materialStorageDetails"].constructor === Array) {
                this.materialStorageDetails = [];
                for (let item of data["materialStorageDetails"])
                    this.materialStorageDetails.push(CreateOrUpdateMaterialStorageDetailDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateMaterialStorageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMaterialStorageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storageOrderNo"] = this.storageOrderNo;
        data["totalPrice"] = this.totalPrice;
        data["storageApprovalState"] = this.storageApprovalState;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["storageUserId"] = this.storageUserId;
        data["storageTime"] = this.storageTime ? this.storageTime.toISOString() : <any>undefined;
        data["storageType"] = this.storageType;
        if (this.materialStorageDetails && this.materialStorageDetails.constructor === Array) {
            data["materialStorageDetails"] = [];
            for (let item of this.materialStorageDetails)
                data["materialStorageDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateMaterialStorageInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateMaterialStorageInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMaterialStorageInput {
    storageOrderNo: string | undefined;
    totalPrice: number | undefined;
    storageApprovalState: CreateOrUpdateMaterialStorageInputStorageApprovalState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    storageUserId: number | undefined;
    storageTime: Date | undefined;
    storageType: CreateOrUpdateMaterialStorageInputStorageType | undefined;
    materialStorageDetails: CreateOrUpdateMaterialStorageDetailDto[] | undefined;
    id: string | undefined;
}

export class CreateOrUpdateMaterialStorageDetailDto implements ICreateOrUpdateMaterialStorageDetailDto {
    purchaseOrderNo: string | undefined;
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    actualNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    deliveryNumber: number | undefined;
    deliveryDate: Date | undefined;
    ppCertificateFilePath: string | undefined;
    invoiceNo: string | undefined;
    invoiceAmount: number | undefined;
    deliveryOrderNo: string | undefined;
    isPackageComplete: boolean | undefined;
    isMaterialWithTicket: boolean | undefined;
    temperature: string | undefined;
    materialStorageId: string | undefined;
    barcodes: string[] | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateMaterialStorageDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.purchaseOrderNo = data["purchaseOrderNo"];
            this.materialPurchaseId = data["materialPurchaseId"];
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.actualNumber = data["actualNumber"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.deliveryNumber = data["deliveryNumber"];
            this.deliveryDate = data["deliveryDate"] ? new Date(data["deliveryDate"].toString()) : <any>undefined;
            this.ppCertificateFilePath = data["ppCertificateFilePath"];
            this.invoiceNo = data["invoiceNo"];
            this.invoiceAmount = data["invoiceAmount"];
            this.deliveryOrderNo = data["deliveryOrderNo"];
            this.isPackageComplete = data["isPackageComplete"];
            this.isMaterialWithTicket = data["isMaterialWithTicket"];
            this.temperature = data["temperature"];
            this.materialStorageId = data["materialStorageId"];
            if (data["barcodes"] && data["barcodes"].constructor === Array) {
                this.barcodes = [];
                for (let item of data["barcodes"])
                    this.barcodes.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateMaterialStorageDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMaterialStorageDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["materialPurchaseId"] = this.materialPurchaseId;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["actualNumber"] = this.actualNumber;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["deliveryNumber"] = this.deliveryNumber;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["ppCertificateFilePath"] = this.ppCertificateFilePath;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceAmount"] = this.invoiceAmount;
        data["deliveryOrderNo"] = this.deliveryOrderNo;
        data["isPackageComplete"] = this.isPackageComplete;
        data["isMaterialWithTicket"] = this.isMaterialWithTicket;
        data["temperature"] = this.temperature;
        data["materialStorageId"] = this.materialStorageId;
        if (this.barcodes && this.barcodes.constructor === Array) {
            data["barcodes"] = [];
            for (let item of this.barcodes)
                data["barcodes"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateMaterialStorageDetailDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateMaterialStorageDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMaterialStorageDetailDto {
    purchaseOrderNo: string | undefined;
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    actualNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    deliveryNumber: number | undefined;
    deliveryDate: Date | undefined;
    ppCertificateFilePath: string | undefined;
    invoiceNo: string | undefined;
    invoiceAmount: number | undefined;
    deliveryOrderNo: string | undefined;
    isPackageComplete: boolean | undefined;
    isMaterialWithTicket: boolean | undefined;
    temperature: string | undefined;
    materialStorageId: string | undefined;
    barcodes: string[] | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetMaterialStoragePaginationOutput implements IPagedResultDtoOfGetMaterialStoragePaginationOutput {
    totalCount: number | undefined;
    items: GetMaterialStoragePaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMaterialStoragePaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetMaterialStoragePaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMaterialStoragePaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMaterialStoragePaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetMaterialStoragePaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetMaterialStoragePaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetMaterialStoragePaginationOutput {
    totalCount: number | undefined;
    items: GetMaterialStoragePaginationOutput[] | undefined;
}

export class GetMaterialStoragePaginationOutput implements IGetMaterialStoragePaginationOutput {
    storageOrderNo: string | undefined;
    totalPrice: number | undefined;
    storageApprovalState: GetMaterialStoragePaginationOutputStorageApprovalState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    storageUserId: number | undefined;
    storageTime: Date | undefined;
    storageType: GetMaterialStoragePaginationOutputStorageType | undefined;
    materialStorageDetails: MaterialStorageDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetMaterialStoragePaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.storageOrderNo = data["storageOrderNo"];
            this.totalPrice = data["totalPrice"];
            this.storageApprovalState = data["storageApprovalState"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.storageUserId = data["storageUserId"];
            this.storageTime = data["storageTime"] ? new Date(data["storageTime"].toString()) : <any>undefined;
            this.storageType = data["storageType"];
            if (data["materialStorageDetails"] && data["materialStorageDetails"].constructor === Array) {
                this.materialStorageDetails = [];
                for (let item of data["materialStorageDetails"])
                    this.materialStorageDetails.push(MaterialStorageDetailDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetMaterialStoragePaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialStoragePaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storageOrderNo"] = this.storageOrderNo;
        data["totalPrice"] = this.totalPrice;
        data["storageApprovalState"] = this.storageApprovalState;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["storageUserId"] = this.storageUserId;
        data["storageTime"] = this.storageTime ? this.storageTime.toISOString() : <any>undefined;
        data["storageType"] = this.storageType;
        if (this.materialStorageDetails && this.materialStorageDetails.constructor === Array) {
            data["materialStorageDetails"] = [];
            for (let item of this.materialStorageDetails)
                data["materialStorageDetails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetMaterialStoragePaginationOutput {
        const json = this.toJSON();
        let result = new GetMaterialStoragePaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMaterialStoragePaginationOutput {
    storageOrderNo: string | undefined;
    totalPrice: number | undefined;
    storageApprovalState: GetMaterialStoragePaginationOutputStorageApprovalState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    storageUserId: number | undefined;
    storageTime: Date | undefined;
    storageType: GetMaterialStoragePaginationOutputStorageType | undefined;
    materialStorageDetails: MaterialStorageDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetMaterialStoragePaginationInput implements IGetMaterialStoragePaginationInput {
    startDate: Date | undefined;
    endDate: Date | undefined;
    storageOrderNo: string | undefined;
    userId: number | undefined;
    accountOrName: string | undefined;
    instrumentId: string | undefined;
    brandId: string | undefined;
    organizationId: number | undefined;
    materialTypeId: string | undefined;
    storageLocationId: string | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IGetMaterialStoragePaginationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            this.storageOrderNo = data["storageOrderNo"];
            this.userId = data["userId"];
            this.accountOrName = data["accountOrName"];
            this.instrumentId = data["instrumentId"];
            this.brandId = data["brandId"];
            this.organizationId = data["organizationId"];
            this.materialTypeId = data["materialTypeId"];
            this.storageLocationId = data["storageLocationId"];
            this.filter = data["filter"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetMaterialStoragePaginationInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialStoragePaginationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["storageOrderNo"] = this.storageOrderNo;
        data["userId"] = this.userId;
        data["accountOrName"] = this.accountOrName;
        data["instrumentId"] = this.instrumentId;
        data["brandId"] = this.brandId;
        data["organizationId"] = this.organizationId;
        data["materialTypeId"] = this.materialTypeId;
        data["storageLocationId"] = this.storageLocationId;
        data["filter"] = this.filter;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetMaterialStoragePaginationInput {
        const json = this.toJSON();
        let result = new GetMaterialStoragePaginationInput();
        result.init(json);
        return result;
    }
}

export interface IGetMaterialStoragePaginationInput {
    startDate: Date | undefined;
    endDate: Date | undefined;
    storageOrderNo: string | undefined;
    userId: number | undefined;
    accountOrName: string | undefined;
    instrumentId: string | undefined;
    brandId: string | undefined;
    organizationId: number | undefined;
    materialTypeId: string | undefined;
    storageLocationId: string | undefined;
    filter: string | undefined;
    sorting: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class SumQualtityPagedResultDtoOfXGetMaterialStoragePaginationOutput implements ISumQualtityPagedResultDtoOfXGetMaterialStoragePaginationOutput {
    sumQualtity: number | undefined;
    totalCount: number | undefined;
    items: XGetMaterialStoragePaginationOutput[] | undefined;

    constructor(data?: ISumQualtityPagedResultDtoOfXGetMaterialStoragePaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sumQualtity = data["sumQualtity"];
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(XGetMaterialStoragePaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SumQualtityPagedResultDtoOfXGetMaterialStoragePaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SumQualtityPagedResultDtoOfXGetMaterialStoragePaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sumQualtity"] = this.sumQualtity;
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SumQualtityPagedResultDtoOfXGetMaterialStoragePaginationOutput {
        const json = this.toJSON();
        let result = new SumQualtityPagedResultDtoOfXGetMaterialStoragePaginationOutput();
        result.init(json);
        return result;
    }
}

export interface ISumQualtityPagedResultDtoOfXGetMaterialStoragePaginationOutput {
    sumQualtity: number | undefined;
    totalCount: number | undefined;
    items: XGetMaterialStoragePaginationOutput[] | undefined;
}

export class XGetMaterialStoragePaginationOutput implements IXGetMaterialStoragePaginationOutput {
    materialStorage: XGetMaterialStoragePaginationMaterialStorageDto | undefined;
    purchaseOrderNo: string | undefined;
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    actualNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    deliveryNumber: number | undefined;
    deliveryDate: Date | undefined;
    ppCertificateFilePath: string | undefined;
    invoiceNo: string | undefined;
    invoiceAmount: number | undefined;
    deliveryOrderNo: string | undefined;
    isPackageComplete: boolean | undefined;
    isMaterialWithTicket: boolean | undefined;
    temperature: string | undefined;
    materialStorageId: string | undefined;
    material: MaterialShareDto | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IXGetMaterialStoragePaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialStorage = data["materialStorage"] ? XGetMaterialStoragePaginationMaterialStorageDto.fromJS(data["materialStorage"]) : <any>undefined;
            this.purchaseOrderNo = data["purchaseOrderNo"];
            this.materialPurchaseId = data["materialPurchaseId"];
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.actualNumber = data["actualNumber"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.deliveryNumber = data["deliveryNumber"];
            this.deliveryDate = data["deliveryDate"] ? new Date(data["deliveryDate"].toString()) : <any>undefined;
            this.ppCertificateFilePath = data["ppCertificateFilePath"];
            this.invoiceNo = data["invoiceNo"];
            this.invoiceAmount = data["invoiceAmount"];
            this.deliveryOrderNo = data["deliveryOrderNo"];
            this.isPackageComplete = data["isPackageComplete"];
            this.isMaterialWithTicket = data["isMaterialWithTicket"];
            this.temperature = data["temperature"];
            this.materialStorageId = data["materialStorageId"];
            this.material = data["material"] ? MaterialShareDto.fromJS(data["material"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): XGetMaterialStoragePaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new XGetMaterialStoragePaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialStorage"] = this.materialStorage ? this.materialStorage.toJSON() : <any>undefined;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["materialPurchaseId"] = this.materialPurchaseId;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["actualNumber"] = this.actualNumber;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["deliveryNumber"] = this.deliveryNumber;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["ppCertificateFilePath"] = this.ppCertificateFilePath;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceAmount"] = this.invoiceAmount;
        data["deliveryOrderNo"] = this.deliveryOrderNo;
        data["isPackageComplete"] = this.isPackageComplete;
        data["isMaterialWithTicket"] = this.isMaterialWithTicket;
        data["temperature"] = this.temperature;
        data["materialStorageId"] = this.materialStorageId;
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): XGetMaterialStoragePaginationOutput {
        const json = this.toJSON();
        let result = new XGetMaterialStoragePaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IXGetMaterialStoragePaginationOutput {
    materialStorage: XGetMaterialStoragePaginationMaterialStorageDto | undefined;
    purchaseOrderNo: string | undefined;
    materialPurchaseId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    actualNumber: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    deliveryNumber: number | undefined;
    deliveryDate: Date | undefined;
    ppCertificateFilePath: string | undefined;
    invoiceNo: string | undefined;
    invoiceAmount: number | undefined;
    deliveryOrderNo: string | undefined;
    isPackageComplete: boolean | undefined;
    isMaterialWithTicket: boolean | undefined;
    temperature: string | undefined;
    materialStorageId: string | undefined;
    material: MaterialShareDto | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class XGetMaterialStoragePaginationMaterialStorageDto implements IXGetMaterialStoragePaginationMaterialStorageDto {
    storageOrderNo: string | undefined;
    totalPrice: number | undefined;
    storageApprovalState: XGetMaterialStoragePaginationMaterialStorageDtoStorageApprovalState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    storageUserId: number | undefined;
    storageTime: Date | undefined;
    storageType: XGetMaterialStoragePaginationMaterialStorageDtoStorageType | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IXGetMaterialStoragePaginationMaterialStorageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.storageOrderNo = data["storageOrderNo"];
            this.totalPrice = data["totalPrice"];
            this.storageApprovalState = data["storageApprovalState"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.storageUserId = data["storageUserId"];
            this.storageTime = data["storageTime"] ? new Date(data["storageTime"].toString()) : <any>undefined;
            this.storageType = data["storageType"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): XGetMaterialStoragePaginationMaterialStorageDto {
        data = typeof data === 'object' ? data : {};
        let result = new XGetMaterialStoragePaginationMaterialStorageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storageOrderNo"] = this.storageOrderNo;
        data["totalPrice"] = this.totalPrice;
        data["storageApprovalState"] = this.storageApprovalState;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["storageUserId"] = this.storageUserId;
        data["storageTime"] = this.storageTime ? this.storageTime.toISOString() : <any>undefined;
        data["storageType"] = this.storageType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): XGetMaterialStoragePaginationMaterialStorageDto {
        const json = this.toJSON();
        let result = new XGetMaterialStoragePaginationMaterialStorageDto();
        result.init(json);
        return result;
    }
}

export interface IXGetMaterialStoragePaginationMaterialStorageDto {
    storageOrderNo: string | undefined;
    totalPrice: number | undefined;
    storageApprovalState: XGetMaterialStoragePaginationMaterialStorageDtoStorageApprovalState | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    storageUserId: number | undefined;
    storageTime: Date | undefined;
    storageType: XGetMaterialStoragePaginationMaterialStorageDtoStorageType | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetModuleForEditOutput implements IGetModuleForEditOutput {
    code: string | undefined;
    name: string | undefined;
    icon: string | undefined;
    url: string | undefined;
    displayName: string | undefined;
    isDefault: boolean | undefined;
    sortRank: number | undefined;
    parentId: string | undefined;
    id: string | undefined;

    constructor(data?: IGetModuleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.url = data["url"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
            this.sortRank = data["sortRank"];
            this.parentId = data["parentId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetModuleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetModuleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["url"] = this.url;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        data["sortRank"] = this.sortRank;
        data["parentId"] = this.parentId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetModuleForEditOutput {
        const json = this.toJSON();
        let result = new GetModuleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetModuleForEditOutput {
    code: string | undefined;
    name: string | undefined;
    icon: string | undefined;
    url: string | undefined;
    displayName: string | undefined;
    isDefault: boolean | undefined;
    sortRank: number | undefined;
    parentId: string | undefined;
    id: string | undefined;
}

export class CreateOrUpdateModuleInput implements ICreateOrUpdateModuleInput {
    code: string | undefined;
    name: string | undefined;
    icon: string | undefined;
    url: string | undefined;
    displayName: string | undefined;
    isDefault: boolean | undefined;
    sortRank: number | undefined;
    parentId: string | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateModuleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.url = data["url"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
            this.sortRank = data["sortRank"];
            this.parentId = data["parentId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateModuleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateModuleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["url"] = this.url;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        data["sortRank"] = this.sortRank;
        data["parentId"] = this.parentId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateModuleInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateModuleInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateModuleInput {
    code: string | undefined;
    name: string | undefined;
    icon: string | undefined;
    url: string | undefined;
    displayName: string | undefined;
    isDefault: boolean | undefined;
    sortRank: number | undefined;
    parentId: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetModulePaginationOutput implements IPagedResultDtoOfGetModulePaginationOutput {
    totalCount: number | undefined;
    items: GetModulePaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetModulePaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetModulePaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetModulePaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetModulePaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetModulePaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetModulePaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetModulePaginationOutput {
    totalCount: number | undefined;
    items: GetModulePaginationOutput[] | undefined;
}

export class GetModulePaginationOutput implements IGetModulePaginationOutput {
    code: string | undefined;
    name: string | undefined;
    icon: string | undefined;
    url: string | undefined;
    displayName: string | undefined;
    isDefault: boolean | undefined;
    sortRank: number | undefined;
    children: GetModulePaginationOutput[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetModulePaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.url = data["url"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
            this.sortRank = data["sortRank"];
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(GetModulePaginationOutput.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetModulePaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetModulePaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["url"] = this.url;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        data["sortRank"] = this.sortRank;
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetModulePaginationOutput {
        const json = this.toJSON();
        let result = new GetModulePaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetModulePaginationOutput {
    code: string | undefined;
    name: string | undefined;
    icon: string | undefined;
    url: string | undefined;
    displayName: string | undefined;
    isDefault: boolean | undefined;
    sortRank: number | undefined;
    children: GetModulePaginationOutput[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetModuleListOutput implements IGetModuleListOutput {
    code: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    parentId: string | undefined;
    children: GetModuleListOutput[] | undefined;
    id: string | undefined;

    constructor(data?: IGetModuleListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.parentId = data["parentId"];
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(GetModuleListOutput.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetModuleListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetModuleListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["parentId"] = this.parentId;
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): GetModuleListOutput {
        const json = this.toJSON();
        let result = new GetModuleListOutput();
        result.init(json);
        return result;
    }
}

export interface IGetModuleListOutput {
    code: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    parentId: string | undefined;
    children: GetModuleListOutput[] | undefined;
    id: string | undefined;
}

export class ModuleImportDto implements IModuleImportDto {
    rowNumber: number | undefined;
    code: string | undefined;
    name: string | undefined;
    icon: string | undefined;
    url: string | undefined;
    displayName: string | undefined;
    isDefault: boolean | undefined;
    sortRank: number | undefined;
    parentCode: string | undefined;
    message: string | undefined;

    constructor(data?: IModuleImportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rowNumber = data["rowNumber"];
            this.code = data["code"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.url = data["url"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
            this.sortRank = data["sortRank"];
            this.parentCode = data["parentCode"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): ModuleImportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleImportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowNumber"] = this.rowNumber;
        data["code"] = this.code;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["url"] = this.url;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        data["sortRank"] = this.sortRank;
        data["parentCode"] = this.parentCode;
        data["message"] = this.message;
        return data; 
    }

    clone(): ModuleImportDto {
        const json = this.toJSON();
        let result = new ModuleImportDto();
        result.init(json);
        return result;
    }
}

export interface IModuleImportDto {
    rowNumber: number | undefined;
    code: string | undefined;
    name: string | undefined;
    icon: string | undefined;
    url: string | undefined;
    displayName: string | undefined;
    isDefault: boolean | undefined;
    sortRank: number | undefined;
    parentCode: string | undefined;
    message: string | undefined;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount: number | undefined;
    totalCount: number | undefined;
    items: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unreadCount = data["unreadCount"];
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetNotificationsOutput {
        const json = this.toJSON();
        let result = new GetNotificationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number | undefined;
    totalCount: number | undefined;
    items: UserNotification[] | undefined;
}

export class UserNotification implements IUserNotification {
    tenantId: number | undefined;
    userId: number | undefined;
    state: UserNotificationState | undefined;
    notification: TenantNotification | undefined;
    id: string | undefined;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotification.fromJS(data["notification"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserNotification {
        const json = this.toJSON();
        let result = new UserNotification();
        result.init(json);
        return result;
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number | undefined;
    state: UserNotificationState | undefined;
    notification: TenantNotification | undefined;
    id: string | undefined;
}

export class TenantNotification implements ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData | undefined;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: TenantNotificationSeverity | undefined;
    creationTime: Date | undefined;
    id: string | undefined;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.entityTypeName = data["entityTypeName"];
            this.entityId = data["entityId"];
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantNotification {
        const json = this.toJSON();
        let result = new TenantNotification();
        result.init(json);
        return result;
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData | undefined;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: TenantNotificationSeverity | undefined;
    creationTime: Date | undefined;
    id: string | undefined;
}

export class NotificationData implements INotificationData {
    type: string | undefined;
    properties: { [key: string] : any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            if (data["properties"]) {
                this.properties = {};
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties[key] = data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }

    clone(): NotificationData {
        const json = this.toJSON();
        let result = new NotificationData();
        result.init(json);
        return result;
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string] : any; } | undefined;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetNotificationSettingsOutput {
        const json = this.toJSON();
        let result = new GetNotificationSettingsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean | undefined;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }

    clone(): NotificationSubscriptionWithDisplayNameDto {
        const json = this.toJSON();
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(json);
        return result;
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean | undefined;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdateNotificationSettingsInput {
        const json = this.toJSON();
        let result = new UpdateNotificationSettingsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean | undefined;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }

    clone(): NotificationSubscriptionDto {
        const json = this.toJSON();
        let result = new NotificationSubscriptionDto();
        result.init(json);
        return result;
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean | undefined;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfOrganizationUnitDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number | undefined;
    children: OrganizationUnitDto[] | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(OrganizationUnitDto.fromJS(item));
            }
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationUnitDto {
        const json = this.toJSON();
        let result = new OrganizationUnitDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number | undefined;
    children: OrganizationUnitDto[] | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetUserOrganizationUnitsOutput implements IGetUserOrganizationUnitsOutput {
    code: string | undefined;
    name: string | undefined;
    id: number | undefined;

    constructor(data?: IGetUserOrganizationUnitsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetUserOrganizationUnitsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserOrganizationUnitsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetUserOrganizationUnitsOutput {
        const json = this.toJSON();
        let result = new GetUserOrganizationUnitsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserOrganizationUnitsOutput {
    code: string | undefined;
    name: string | undefined;
    id: number | undefined;
}

export class GetUserOrganizationUnitsInput implements IGetUserOrganizationUnitsInput {
    userNameOrEmailAddress: string | undefined;

    constructor(data?: IGetUserOrganizationUnitsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
        }
    }

    static fromJS(data: any): GetUserOrganizationUnitsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserOrganizationUnitsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        return data; 
    }

    clone(): GetUserOrganizationUnitsInput {
        const json = this.toJSON();
        let result = new GetUserOrganizationUnitsInput();
        result.init(json);
        return result;
    }
}

export interface IGetUserOrganizationUnitsInput {
    userNameOrEmailAddress: string | undefined;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number | undefined;
    items: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfOrganizationUnitUserListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number | undefined;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: Date | undefined;
    id: number | undefined;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.addedTime = data["addedTime"] ? new Date(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationUnitUserListDto {
        const json = this.toJSON();
        let result = new OrganizationUnitUserListDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: Date | undefined;
    id: number | undefined;
}

export class CreateOrUpdateOrganizationUnitInput implements ICreateOrUpdateOrganizationUnitInput {
    id: number | undefined;
    parentId: number | undefined;
    displayName: string;
    dockingOrganizationUnitCode: string | undefined;
    dockingWarehouseCode: string | undefined;

    constructor(data?: ICreateOrUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
            this.dockingOrganizationUnitCode = data["dockingOrganizationUnitCode"];
            this.dockingWarehouseCode = data["dockingWarehouseCode"];
        }
    }

    static fromJS(data: any): CreateOrUpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        data["dockingOrganizationUnitCode"] = this.dockingOrganizationUnitCode;
        data["dockingWarehouseCode"] = this.dockingWarehouseCode;
        return data; 
    }

    clone(): CreateOrUpdateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateOrganizationUnitInput {
    id: number | undefined;
    parentId: number | undefined;
    displayName: string;
    dockingOrganizationUnitCode: string | undefined;
    dockingWarehouseCode: string | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
    dockingOrganizationUnitCode: string | undefined;
    dockingWarehouseCode: string | undefined;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
            this.dockingOrganizationUnitCode = data["dockingOrganizationUnitCode"];
            this.dockingWarehouseCode = data["dockingWarehouseCode"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        data["dockingOrganizationUnitCode"] = this.dockingOrganizationUnitCode;
        data["dockingWarehouseCode"] = this.dockingWarehouseCode;
        return data; 
    }

    clone(): CreateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new CreateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
    dockingOrganizationUnitCode: string | undefined;
    dockingWarehouseCode: string | undefined;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id: number | undefined;
    displayName: string;
    parentId: number | undefined;
    dockingOrganizationUnitCode: string | undefined;
    dockingWarehouseCode: string | undefined;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.parentId = data["parentId"];
            this.dockingOrganizationUnitCode = data["dockingOrganizationUnitCode"];
            this.dockingWarehouseCode = data["dockingWarehouseCode"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["parentId"] = this.parentId;
        data["dockingOrganizationUnitCode"] = this.dockingOrganizationUnitCode;
        data["dockingWarehouseCode"] = this.dockingWarehouseCode;
        return data; 
    }

    clone(): UpdateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UpdateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number | undefined;
    displayName: string;
    parentId: number | undefined;
    dockingOrganizationUnitCode: string | undefined;
    dockingWarehouseCode: string | undefined;
}

export class UpdateOrganizationOutInStorageSettingInput implements IUpdateOrganizationOutInStorageSettingInput {
    targetOrganizationId: number | undefined;
    targetOrganizationName: string | undefined;
    organizationOutInStorageSettings: OrganizationOutInStorageSettingDto[] | undefined;

    constructor(data?: IUpdateOrganizationOutInStorageSettingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetOrganizationId = data["targetOrganizationId"];
            this.targetOrganizationName = data["targetOrganizationName"];
            if (data["organizationOutInStorageSettings"] && data["organizationOutInStorageSettings"].constructor === Array) {
                this.organizationOutInStorageSettings = [];
                for (let item of data["organizationOutInStorageSettings"])
                    this.organizationOutInStorageSettings.push(OrganizationOutInStorageSettingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateOrganizationOutInStorageSettingInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationOutInStorageSettingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetOrganizationId"] = this.targetOrganizationId;
        data["targetOrganizationName"] = this.targetOrganizationName;
        if (this.organizationOutInStorageSettings && this.organizationOutInStorageSettings.constructor === Array) {
            data["organizationOutInStorageSettings"] = [];
            for (let item of this.organizationOutInStorageSettings)
                data["organizationOutInStorageSettings"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdateOrganizationOutInStorageSettingInput {
        const json = this.toJSON();
        let result = new UpdateOrganizationOutInStorageSettingInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateOrganizationOutInStorageSettingInput {
    targetOrganizationId: number | undefined;
    targetOrganizationName: string | undefined;
    organizationOutInStorageSettings: OrganizationOutInStorageSettingDto[] | undefined;
}

export class OrganizationOutInStorageSettingDto implements IOrganizationOutInStorageSettingDto {
    targetOrganizationId: number | undefined;
    targetOrganizationName: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseInfoName: string | undefined;
    isAutoOut: boolean | undefined;
    isAutoIn: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IOrganizationOutInStorageSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetOrganizationId = data["targetOrganizationId"];
            this.targetOrganizationName = data["targetOrganizationName"];
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.warehouseInfoId = data["warehouseInfoId"];
            this.warehouseInfoName = data["warehouseInfoName"];
            this.isAutoOut = data["isAutoOut"];
            this.isAutoIn = data["isAutoIn"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationOutInStorageSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationOutInStorageSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetOrganizationId"] = this.targetOrganizationId;
        data["targetOrganizationName"] = this.targetOrganizationName;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["warehouseInfoId"] = this.warehouseInfoId;
        data["warehouseInfoName"] = this.warehouseInfoName;
        data["isAutoOut"] = this.isAutoOut;
        data["isAutoIn"] = this.isAutoIn;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationOutInStorageSettingDto {
        const json = this.toJSON();
        let result = new OrganizationOutInStorageSettingDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationOutInStorageSettingDto {
    targetOrganizationId: number | undefined;
    targetOrganizationName: string | undefined;
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseInfoName: string | undefined;
    isAutoOut: boolean | undefined;
    isAutoIn: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class OrganizationUnitForEditDto implements IOrganizationUnitForEditDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    dockingOrganizationUnitCode: string | undefined;
    dockingWarehouseCode: string | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IOrganizationUnitForEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.dockingOrganizationUnitCode = data["dockingOrganizationUnitCode"];
            this.dockingWarehouseCode = data["dockingWarehouseCode"];
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitForEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitForEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["dockingOrganizationUnitCode"] = this.dockingOrganizationUnitCode;
        data["dockingWarehouseCode"] = this.dockingWarehouseCode;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationUnitForEditDto {
        const json = this.toJSON();
        let result = new OrganizationUnitForEditDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitForEditDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    dockingOrganizationUnitCode: string | undefined;
    dockingWarehouseCode: string | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id: number | undefined;
    newParentId: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }

    clone(): MoveOrganizationUnitInput {
        const json = this.toJSON();
        let result = new MoveOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IMoveOrganizationUnitInput {
    id: number | undefined;
    newParentId: number | undefined;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number | undefined;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [];
                for (let item of data["userIds"])
                    this.userIds.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone(): UsersToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UsersToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }

    clone(): FindOrganizationUnitUsersInput {
        const json = this.toJSON();
        let result = new FindOrganizationUnitUsersInput();
        result.init(json);
        return result;
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition: EditionSelectDto | undefined;
    additionalPrice: number | undefined;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            this.additionalPrice = data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data; 
    }

    clone(): PaymentInfoDto {
        const json = this.toJSON();
        let result = new PaymentInfoDto();
        result.init(json);
        return result;
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto | undefined;
    additionalPrice: number | undefined;
}

export class EditionSelectDto implements IEditionSelectDto {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean | undefined;
    additionalData: AdditionalData | undefined;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.isFree = data["isFree"];
            this.additionalData = data["additionalData"] ? AdditionalData.fromJS(data["additionalData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        data["additionalData"] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
        return data; 
    }

    clone(): EditionSelectDto {
        const json = this.toJSON();
        let result = new EditionSelectDto();
        result.init(json);
        return result;
    }
}

export interface IEditionSelectDto {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean | undefined;
    additionalData: AdditionalData | undefined;
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId: number | undefined;
    editionPaymentType: CreatePaymentDtoEditionPaymentType | undefined;
    paymentPeriodType: CreatePaymentDtoPaymentPeriodType | undefined;
    subscriptionPaymentGatewayType: CreatePaymentDtoSubscriptionPaymentGatewayType | undefined;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.editionId = data["editionId"];
            this.editionPaymentType = data["editionPaymentType"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = data["subscriptionPaymentGatewayType"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        return data; 
    }

    clone(): CreatePaymentDto {
        const json = this.toJSON();
        let result = new CreatePaymentDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePaymentDto {
    editionId: number | undefined;
    editionPaymentType: CreatePaymentDtoEditionPaymentType | undefined;
    paymentPeriodType: CreatePaymentDtoPaymentPeriodType | undefined;
    subscriptionPaymentGatewayType: CreatePaymentDtoSubscriptionPaymentGatewayType | undefined;
}

export class ExecutePaymentDto implements IExecutePaymentDto {
    gateway: ExecutePaymentDtoGateway | undefined;
    editionPaymentType: ExecutePaymentDtoEditionPaymentType | undefined;
    editionId: number | undefined;
    paymentPeriodType: ExecutePaymentDtoPaymentPeriodType | undefined;
    additionalData: { [key: string] : string; } | undefined;

    constructor(data?: IExecutePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.editionPaymentType = data["editionPaymentType"];
            this.editionId = data["editionId"];
            this.paymentPeriodType = data["paymentPeriodType"];
            if (data["additionalData"]) {
                this.additionalData = {};
                for (let key in data["additionalData"]) {
                    if (data["additionalData"].hasOwnProperty(key))
                        this.additionalData[key] = data["additionalData"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExecutePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExecutePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["editionPaymentType"] = this.editionPaymentType;
        data["editionId"] = this.editionId;
        data["paymentPeriodType"] = this.paymentPeriodType;
        if (this.additionalData) {
            data["additionalData"] = {};
            for (let key in this.additionalData) {
                if (this.additionalData.hasOwnProperty(key))
                    data["additionalData"][key] = this.additionalData[key];
            }
        }
        return data; 
    }

    clone(): ExecutePaymentDto {
        const json = this.toJSON();
        let result = new ExecutePaymentDto();
        result.init(json);
        return result;
    }
}

export interface IExecutePaymentDto {
    gateway: ExecutePaymentDtoGateway | undefined;
    editionPaymentType: ExecutePaymentDtoEditionPaymentType | undefined;
    editionId: number | undefined;
    paymentPeriodType: ExecutePaymentDtoPaymentPeriodType | undefined;
    additionalData: { [key: string] : string; } | undefined;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number | undefined;
    items: SubscriptionPaymentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfSubscriptionPaymentListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number | undefined;
    items: SubscriptionPaymentListDto[] | undefined;
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: string | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number | undefined;
    invoiceNo: string | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.status = data["status"];
            this.editionDisplayName = data["editionDisplayName"];
            this.tenantId = data["tenantId"];
            this.invoiceNo = data["invoiceNo"];
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): SubscriptionPaymentListDto {
        const json = this.toJSON();
        let result = new SubscriptionPaymentListDto();
        result.init(json);
        return result;
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: string | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number | undefined;
    invoiceNo: string | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetWaitForVerfifyMaterialsOutput implements IPagedResultDtoOfGetWaitForVerfifyMaterialsOutput {
    totalCount: number | undefined;
    items: GetWaitForVerfifyMaterialsOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWaitForVerfifyMaterialsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetWaitForVerfifyMaterialsOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWaitForVerfifyMaterialsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWaitForVerfifyMaterialsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetWaitForVerfifyMaterialsOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetWaitForVerfifyMaterialsOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetWaitForVerfifyMaterialsOutput {
    totalCount: number | undefined;
    items: GetWaitForVerfifyMaterialsOutput[] | undefined;
}

export class GetWaitForVerfifyMaterialsOutput implements IGetWaitForVerfifyMaterialsOutput {
    systemMaterialCode: string | undefined;
    hospitalMaterialCode: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    specification: string | undefined;
    storageConditionId: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeId: string | undefined;
    temperatureRangeName: string | undefined;
    materialTypeId: string | undefined;
    materialTypeName: string | undefined;
    brandId: string | undefined;
    brandName: string | undefined;
    price: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    minUnitId: string | undefined;
    minUnitName: string | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    supplierId: string | undefined;
    supplierName: string | undefined;
    deliveryCompanyId: string | undefined;
    deliveryCompanyName: string | undefined;
    invoicingCompanyId: string | undefined;
    invoicingCompanyName: string | undefined;
    isRegistrationCertificate: boolean | undefined;
    registrationCertificateNo: string | undefined;
    registrationCertificateFilePath: string | undefined;
    expiryDate: Date | undefined;
    outBoxExpiryDate: number | undefined;
    instrumentId: string | undefined;
    instrumentName: string | undefined;
    arrivalDateSetting: string | undefined;
    isDisabled: boolean | undefined;
    disabledDate: Date | undefined;
    disabledReasonId: string | undefined;
    disabledReasonName: string | undefined;
    vendorMaterialCode: string | undefined;
    isStopPurchase: boolean | undefined;
    isAutoGenerateUniqueCode: boolean | undefined;
    isEnableVendorMaterialCode: boolean | undefined;
    isEnableOpenLabel: boolean | undefined;
    isHavePpCertificate: boolean | undefined;
    isPublicReagent: boolean | undefined;
    isCombinationReagent: boolean | undefined;
    combinationReagentProportion: string | undefined;
    isInventoryAlert: boolean | undefined;
    alertMaterialNumber: number | undefined;
    alertMinMaterialNumber: number | undefined;
    isAvailableDayAlert: boolean | undefined;
    alertAvailableDay: number | undefined;
    alertMinAvailableDay: number | undefined;
    isAutoPurchaseCalculate: boolean | undefined;
    monthPurchaseUpperLimit: number | undefined;
    isDefaultPurchaseNumber: boolean | undefined;
    defaultPurchaseNumber: number | undefined;
    unitConvertSetting: string | undefined;
    methodologyId: string | undefined;
    methodologyName: string | undefined;
    organizationMaterials: OrganizationMaterialDto[] | undefined;
    id: string | undefined;

    constructor(data?: IGetWaitForVerfifyMaterialsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.systemMaterialCode = data["systemMaterialCode"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.name = data["name"];
            this.shortName = data["shortName"];
            this.specification = data["specification"];
            this.storageConditionId = data["storageConditionId"];
            this.storageConditionName = data["storageConditionName"];
            this.temperatureRangeId = data["temperatureRangeId"];
            this.temperatureRangeName = data["temperatureRangeName"];
            this.materialTypeId = data["materialTypeId"];
            this.materialTypeName = data["materialTypeName"];
            this.brandId = data["brandId"];
            this.brandName = data["brandName"];
            this.price = data["price"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.minUnitId = data["minUnitId"];
            this.minUnitName = data["minUnitName"];
            this.manufacturerId = data["manufacturerId"];
            this.manufacturerName = data["manufacturerName"];
            this.supplierId = data["supplierId"];
            this.supplierName = data["supplierName"];
            this.deliveryCompanyId = data["deliveryCompanyId"];
            this.deliveryCompanyName = data["deliveryCompanyName"];
            this.invoicingCompanyId = data["invoicingCompanyId"];
            this.invoicingCompanyName = data["invoicingCompanyName"];
            this.isRegistrationCertificate = data["isRegistrationCertificate"];
            this.registrationCertificateNo = data["registrationCertificateNo"];
            this.registrationCertificateFilePath = data["registrationCertificateFilePath"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.outBoxExpiryDate = data["outBoxExpiryDate"];
            this.instrumentId = data["instrumentId"];
            this.instrumentName = data["instrumentName"];
            this.arrivalDateSetting = data["arrivalDateSetting"];
            this.isDisabled = data["isDisabled"];
            this.disabledDate = data["disabledDate"] ? new Date(data["disabledDate"].toString()) : <any>undefined;
            this.disabledReasonId = data["disabledReasonId"];
            this.disabledReasonName = data["disabledReasonName"];
            this.vendorMaterialCode = data["vendorMaterialCode"];
            this.isStopPurchase = data["isStopPurchase"];
            this.isAutoGenerateUniqueCode = data["isAutoGenerateUniqueCode"];
            this.isEnableVendorMaterialCode = data["isEnableVendorMaterialCode"];
            this.isEnableOpenLabel = data["isEnableOpenLabel"];
            this.isHavePpCertificate = data["isHavePpCertificate"];
            this.isPublicReagent = data["isPublicReagent"];
            this.isCombinationReagent = data["isCombinationReagent"];
            this.combinationReagentProportion = data["combinationReagentProportion"];
            this.isInventoryAlert = data["isInventoryAlert"];
            this.alertMaterialNumber = data["alertMaterialNumber"];
            this.alertMinMaterialNumber = data["alertMinMaterialNumber"];
            this.isAvailableDayAlert = data["isAvailableDayAlert"];
            this.alertAvailableDay = data["alertAvailableDay"];
            this.alertMinAvailableDay = data["alertMinAvailableDay"];
            this.isAutoPurchaseCalculate = data["isAutoPurchaseCalculate"];
            this.monthPurchaseUpperLimit = data["monthPurchaseUpperLimit"];
            this.isDefaultPurchaseNumber = data["isDefaultPurchaseNumber"];
            this.defaultPurchaseNumber = data["defaultPurchaseNumber"];
            this.unitConvertSetting = data["unitConvertSetting"];
            this.methodologyId = data["methodologyId"];
            this.methodologyName = data["methodologyName"];
            if (data["organizationMaterials"] && data["organizationMaterials"].constructor === Array) {
                this.organizationMaterials = [];
                for (let item of data["organizationMaterials"])
                    this.organizationMaterials.push(OrganizationMaterialDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetWaitForVerfifyMaterialsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWaitForVerfifyMaterialsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemMaterialCode"] = this.systemMaterialCode;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["specification"] = this.specification;
        data["storageConditionId"] = this.storageConditionId;
        data["storageConditionName"] = this.storageConditionName;
        data["temperatureRangeId"] = this.temperatureRangeId;
        data["temperatureRangeName"] = this.temperatureRangeName;
        data["materialTypeId"] = this.materialTypeId;
        data["materialTypeName"] = this.materialTypeName;
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        data["price"] = this.price;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["minUnitId"] = this.minUnitId;
        data["minUnitName"] = this.minUnitName;
        data["manufacturerId"] = this.manufacturerId;
        data["manufacturerName"] = this.manufacturerName;
        data["supplierId"] = this.supplierId;
        data["supplierName"] = this.supplierName;
        data["deliveryCompanyId"] = this.deliveryCompanyId;
        data["deliveryCompanyName"] = this.deliveryCompanyName;
        data["invoicingCompanyId"] = this.invoicingCompanyId;
        data["invoicingCompanyName"] = this.invoicingCompanyName;
        data["isRegistrationCertificate"] = this.isRegistrationCertificate;
        data["registrationCertificateNo"] = this.registrationCertificateNo;
        data["registrationCertificateFilePath"] = this.registrationCertificateFilePath;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["outBoxExpiryDate"] = this.outBoxExpiryDate;
        data["instrumentId"] = this.instrumentId;
        data["instrumentName"] = this.instrumentName;
        data["arrivalDateSetting"] = this.arrivalDateSetting;
        data["isDisabled"] = this.isDisabled;
        data["disabledDate"] = this.disabledDate ? this.disabledDate.toISOString() : <any>undefined;
        data["disabledReasonId"] = this.disabledReasonId;
        data["disabledReasonName"] = this.disabledReasonName;
        data["vendorMaterialCode"] = this.vendorMaterialCode;
        data["isStopPurchase"] = this.isStopPurchase;
        data["isAutoGenerateUniqueCode"] = this.isAutoGenerateUniqueCode;
        data["isEnableVendorMaterialCode"] = this.isEnableVendorMaterialCode;
        data["isEnableOpenLabel"] = this.isEnableOpenLabel;
        data["isHavePpCertificate"] = this.isHavePpCertificate;
        data["isPublicReagent"] = this.isPublicReagent;
        data["isCombinationReagent"] = this.isCombinationReagent;
        data["combinationReagentProportion"] = this.combinationReagentProportion;
        data["isInventoryAlert"] = this.isInventoryAlert;
        data["alertMaterialNumber"] = this.alertMaterialNumber;
        data["alertMinMaterialNumber"] = this.alertMinMaterialNumber;
        data["isAvailableDayAlert"] = this.isAvailableDayAlert;
        data["alertAvailableDay"] = this.alertAvailableDay;
        data["alertMinAvailableDay"] = this.alertMinAvailableDay;
        data["isAutoPurchaseCalculate"] = this.isAutoPurchaseCalculate;
        data["monthPurchaseUpperLimit"] = this.monthPurchaseUpperLimit;
        data["isDefaultPurchaseNumber"] = this.isDefaultPurchaseNumber;
        data["defaultPurchaseNumber"] = this.defaultPurchaseNumber;
        data["unitConvertSetting"] = this.unitConvertSetting;
        data["methodologyId"] = this.methodologyId;
        data["methodologyName"] = this.methodologyName;
        if (this.organizationMaterials && this.organizationMaterials.constructor === Array) {
            data["organizationMaterials"] = [];
            for (let item of this.organizationMaterials)
                data["organizationMaterials"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): GetWaitForVerfifyMaterialsOutput {
        const json = this.toJSON();
        let result = new GetWaitForVerfifyMaterialsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetWaitForVerfifyMaterialsOutput {
    systemMaterialCode: string | undefined;
    hospitalMaterialCode: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    specification: string | undefined;
    storageConditionId: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeId: string | undefined;
    temperatureRangeName: string | undefined;
    materialTypeId: string | undefined;
    materialTypeName: string | undefined;
    brandId: string | undefined;
    brandName: string | undefined;
    price: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    minUnitId: string | undefined;
    minUnitName: string | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    supplierId: string | undefined;
    supplierName: string | undefined;
    deliveryCompanyId: string | undefined;
    deliveryCompanyName: string | undefined;
    invoicingCompanyId: string | undefined;
    invoicingCompanyName: string | undefined;
    isRegistrationCertificate: boolean | undefined;
    registrationCertificateNo: string | undefined;
    registrationCertificateFilePath: string | undefined;
    expiryDate: Date | undefined;
    outBoxExpiryDate: number | undefined;
    instrumentId: string | undefined;
    instrumentName: string | undefined;
    arrivalDateSetting: string | undefined;
    isDisabled: boolean | undefined;
    disabledDate: Date | undefined;
    disabledReasonId: string | undefined;
    disabledReasonName: string | undefined;
    vendorMaterialCode: string | undefined;
    isStopPurchase: boolean | undefined;
    isAutoGenerateUniqueCode: boolean | undefined;
    isEnableVendorMaterialCode: boolean | undefined;
    isEnableOpenLabel: boolean | undefined;
    isHavePpCertificate: boolean | undefined;
    isPublicReagent: boolean | undefined;
    isCombinationReagent: boolean | undefined;
    combinationReagentProportion: string | undefined;
    isInventoryAlert: boolean | undefined;
    alertMaterialNumber: number | undefined;
    alertMinMaterialNumber: number | undefined;
    isAvailableDayAlert: boolean | undefined;
    alertAvailableDay: number | undefined;
    alertMinAvailableDay: number | undefined;
    isAutoPurchaseCalculate: boolean | undefined;
    monthPurchaseUpperLimit: number | undefined;
    isDefaultPurchaseNumber: boolean | undefined;
    defaultPurchaseNumber: number | undefined;
    unitConvertSetting: string | undefined;
    methodologyId: string | undefined;
    methodologyName: string | undefined;
    organizationMaterials: OrganizationMaterialDto[] | undefined;
    id: string | undefined;
}

export class GetPerformanceVerificationInfoOutput implements IGetPerformanceVerificationInfoOutput {
    inspectionItems: InspectionItemDto[] | undefined;
    performanceVerificationMaterials: GetPerformanceVerificationMaterialDto[] | undefined;

    constructor(data?: IGetPerformanceVerificationInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["inspectionItems"] && data["inspectionItems"].constructor === Array) {
                this.inspectionItems = [];
                for (let item of data["inspectionItems"])
                    this.inspectionItems.push(InspectionItemDto.fromJS(item));
            }
            if (data["performanceVerificationMaterials"] && data["performanceVerificationMaterials"].constructor === Array) {
                this.performanceVerificationMaterials = [];
                for (let item of data["performanceVerificationMaterials"])
                    this.performanceVerificationMaterials.push(GetPerformanceVerificationMaterialDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPerformanceVerificationInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPerformanceVerificationInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.inspectionItems && this.inspectionItems.constructor === Array) {
            data["inspectionItems"] = [];
            for (let item of this.inspectionItems)
                data["inspectionItems"].push(item.toJSON());
        }
        if (this.performanceVerificationMaterials && this.performanceVerificationMaterials.constructor === Array) {
            data["performanceVerificationMaterials"] = [];
            for (let item of this.performanceVerificationMaterials)
                data["performanceVerificationMaterials"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetPerformanceVerificationInfoOutput {
        const json = this.toJSON();
        let result = new GetPerformanceVerificationInfoOutput();
        result.init(json);
        return result;
    }
}

export interface IGetPerformanceVerificationInfoOutput {
    inspectionItems: InspectionItemDto[] | undefined;
    performanceVerificationMaterials: GetPerformanceVerificationMaterialDto[] | undefined;
}

export class InspectionItemDto implements IInspectionItemDto {
    code: string | undefined;
    name: string | undefined;
    performanceVerificationType: InspectionItemDtoPerformanceVerificationType | undefined;
    minReferenceRange: number | undefined;
    maxReferenceRange: number | undefined;
    referenceResult: string | undefined;
    referenceUnit: string | undefined;
    calculationFormula: string | undefined;
    deviation: number | undefined;
    remark: string | undefined;
    calculationType: InspectionItemDtoCalculationType | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IInspectionItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.performanceVerificationType = data["performanceVerificationType"];
            this.minReferenceRange = data["minReferenceRange"];
            this.maxReferenceRange = data["maxReferenceRange"];
            this.referenceResult = data["referenceResult"];
            this.referenceUnit = data["referenceUnit"];
            this.calculationFormula = data["calculationFormula"];
            this.deviation = data["deviation"];
            this.remark = data["remark"];
            this.calculationType = data["calculationType"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): InspectionItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new InspectionItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["performanceVerificationType"] = this.performanceVerificationType;
        data["minReferenceRange"] = this.minReferenceRange;
        data["maxReferenceRange"] = this.maxReferenceRange;
        data["referenceResult"] = this.referenceResult;
        data["referenceUnit"] = this.referenceUnit;
        data["calculationFormula"] = this.calculationFormula;
        data["deviation"] = this.deviation;
        data["remark"] = this.remark;
        data["calculationType"] = this.calculationType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): InspectionItemDto {
        const json = this.toJSON();
        let result = new InspectionItemDto();
        result.init(json);
        return result;
    }
}

export interface IInspectionItemDto {
    code: string | undefined;
    name: string | undefined;
    performanceVerificationType: InspectionItemDtoPerformanceVerificationType | undefined;
    minReferenceRange: number | undefined;
    maxReferenceRange: number | undefined;
    referenceResult: string | undefined;
    referenceUnit: string | undefined;
    calculationFormula: string | undefined;
    deviation: number | undefined;
    remark: string | undefined;
    calculationType: InspectionItemDtoCalculationType | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetPerformanceVerificationMaterialDto implements IGetPerformanceVerificationMaterialDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    oldBatchNo: string | undefined;
    oldBatchNoArrivalDate: Date | undefined;
    oldExpireDate: Date | undefined;
    newBatchNo: string | undefined;
    newBatchNoArrivalDate: Date | undefined;
    newExpireDate: Date | undefined;

    constructor(data?: IGetPerformanceVerificationMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.oldBatchNo = data["oldBatchNo"];
            this.oldBatchNoArrivalDate = data["oldBatchNoArrivalDate"] ? new Date(data["oldBatchNoArrivalDate"].toString()) : <any>undefined;
            this.oldExpireDate = data["oldExpireDate"] ? new Date(data["oldExpireDate"].toString()) : <any>undefined;
            this.newBatchNo = data["newBatchNo"];
            this.newBatchNoArrivalDate = data["newBatchNoArrivalDate"] ? new Date(data["newBatchNoArrivalDate"].toString()) : <any>undefined;
            this.newExpireDate = data["newExpireDate"] ? new Date(data["newExpireDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPerformanceVerificationMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPerformanceVerificationMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["oldBatchNo"] = this.oldBatchNo;
        data["oldBatchNoArrivalDate"] = this.oldBatchNoArrivalDate ? this.oldBatchNoArrivalDate.toISOString() : <any>undefined;
        data["oldExpireDate"] = this.oldExpireDate ? this.oldExpireDate.toISOString() : <any>undefined;
        data["newBatchNo"] = this.newBatchNo;
        data["newBatchNoArrivalDate"] = this.newBatchNoArrivalDate ? this.newBatchNoArrivalDate.toISOString() : <any>undefined;
        data["newExpireDate"] = this.newExpireDate ? this.newExpireDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): GetPerformanceVerificationMaterialDto {
        const json = this.toJSON();
        let result = new GetPerformanceVerificationMaterialDto();
        result.init(json);
        return result;
    }
}

export interface IGetPerformanceVerificationMaterialDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    oldBatchNo: string | undefined;
    oldBatchNoArrivalDate: Date | undefined;
    oldExpireDate: Date | undefined;
    newBatchNo: string | undefined;
    newBatchNoArrivalDate: Date | undefined;
    newExpireDate: Date | undefined;
}

export class GetPerformanceVerificationReportForEditOutput implements IGetPerformanceVerificationReportForEditOutput {
    reportNo: string | undefined;
    performanceVerificationRecordId: string | undefined;
    applyItem: string | undefined;
    summary: string | undefined;
    instrumentId: string | undefined;
    qualifiedVerifyType: GetPerformanceVerificationReportForEditOutputQualifiedVerifyType | undefined;
    verificationStandardValue: number | undefined;
    evaluateUserId: number | undefined;
    evaluationTime: Date | undefined;
    checkUserId: number | undefined;
    checkerAccount: string | undefined;
    checkTime: Date | undefined;
    organizationId: number | undefined;
    qualifiedVerifyReportInspectItems: PerformanceVerificationReportInspectItemDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetPerformanceVerificationReportForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reportNo = data["reportNo"];
            this.performanceVerificationRecordId = data["performanceVerificationRecordId"];
            this.applyItem = data["applyItem"];
            this.summary = data["summary"];
            this.instrumentId = data["instrumentId"];
            this.qualifiedVerifyType = data["qualifiedVerifyType"];
            this.verificationStandardValue = data["verificationStandardValue"];
            this.evaluateUserId = data["evaluateUserId"];
            this.evaluationTime = data["evaluationTime"] ? new Date(data["evaluationTime"].toString()) : <any>undefined;
            this.checkUserId = data["checkUserId"];
            this.checkerAccount = data["checkerAccount"];
            this.checkTime = data["checkTime"] ? new Date(data["checkTime"].toString()) : <any>undefined;
            this.organizationId = data["organizationId"];
            if (data["qualifiedVerifyReportInspectItems"] && data["qualifiedVerifyReportInspectItems"].constructor === Array) {
                this.qualifiedVerifyReportInspectItems = [];
                for (let item of data["qualifiedVerifyReportInspectItems"])
                    this.qualifiedVerifyReportInspectItems.push(PerformanceVerificationReportInspectItemDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetPerformanceVerificationReportForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPerformanceVerificationReportForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportNo"] = this.reportNo;
        data["performanceVerificationRecordId"] = this.performanceVerificationRecordId;
        data["applyItem"] = this.applyItem;
        data["summary"] = this.summary;
        data["instrumentId"] = this.instrumentId;
        data["qualifiedVerifyType"] = this.qualifiedVerifyType;
        data["verificationStandardValue"] = this.verificationStandardValue;
        data["evaluateUserId"] = this.evaluateUserId;
        data["evaluationTime"] = this.evaluationTime ? this.evaluationTime.toISOString() : <any>undefined;
        data["checkUserId"] = this.checkUserId;
        data["checkerAccount"] = this.checkerAccount;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        data["organizationId"] = this.organizationId;
        if (this.qualifiedVerifyReportInspectItems && this.qualifiedVerifyReportInspectItems.constructor === Array) {
            data["qualifiedVerifyReportInspectItems"] = [];
            for (let item of this.qualifiedVerifyReportInspectItems)
                data["qualifiedVerifyReportInspectItems"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetPerformanceVerificationReportForEditOutput {
        const json = this.toJSON();
        let result = new GetPerformanceVerificationReportForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetPerformanceVerificationReportForEditOutput {
    reportNo: string | undefined;
    performanceVerificationRecordId: string | undefined;
    applyItem: string | undefined;
    summary: string | undefined;
    instrumentId: string | undefined;
    qualifiedVerifyType: GetPerformanceVerificationReportForEditOutputQualifiedVerifyType | undefined;
    verificationStandardValue: number | undefined;
    evaluateUserId: number | undefined;
    evaluationTime: Date | undefined;
    checkUserId: number | undefined;
    checkerAccount: string | undefined;
    checkTime: Date | undefined;
    organizationId: number | undefined;
    qualifiedVerifyReportInspectItems: PerformanceVerificationReportInspectItemDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class PerformanceVerificationReportInspectItemDto implements IPerformanceVerificationReportInspectItemDto {
    inspectionItem: InspectionItemDto | undefined;
    performanceVerificationReportId: string | undefined;
    inspectionItemId: string | undefined;
    qualifiedVerifyResultType: PerformanceVerificationReportInspectItemDtoQualifiedVerifyResultType | undefined;
    qualifiedVerifyReportMaterials: PerformanceVerificationReportMaterialDto[] | undefined;
    performanceVerificationReportTestResults: PerformanceVerificationReportTestResultDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IPerformanceVerificationReportInspectItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inspectionItem = data["inspectionItem"] ? InspectionItemDto.fromJS(data["inspectionItem"]) : <any>undefined;
            this.performanceVerificationReportId = data["performanceVerificationReportId"];
            this.inspectionItemId = data["inspectionItemId"];
            this.qualifiedVerifyResultType = data["qualifiedVerifyResultType"];
            if (data["qualifiedVerifyReportMaterials"] && data["qualifiedVerifyReportMaterials"].constructor === Array) {
                this.qualifiedVerifyReportMaterials = [];
                for (let item of data["qualifiedVerifyReportMaterials"])
                    this.qualifiedVerifyReportMaterials.push(PerformanceVerificationReportMaterialDto.fromJS(item));
            }
            if (data["performanceVerificationReportTestResults"] && data["performanceVerificationReportTestResults"].constructor === Array) {
                this.performanceVerificationReportTestResults = [];
                for (let item of data["performanceVerificationReportTestResults"])
                    this.performanceVerificationReportTestResults.push(PerformanceVerificationReportTestResultDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PerformanceVerificationReportInspectItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformanceVerificationReportInspectItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inspectionItem"] = this.inspectionItem ? this.inspectionItem.toJSON() : <any>undefined;
        data["performanceVerificationReportId"] = this.performanceVerificationReportId;
        data["inspectionItemId"] = this.inspectionItemId;
        data["qualifiedVerifyResultType"] = this.qualifiedVerifyResultType;
        if (this.qualifiedVerifyReportMaterials && this.qualifiedVerifyReportMaterials.constructor === Array) {
            data["qualifiedVerifyReportMaterials"] = [];
            for (let item of this.qualifiedVerifyReportMaterials)
                data["qualifiedVerifyReportMaterials"].push(item.toJSON());
        }
        if (this.performanceVerificationReportTestResults && this.performanceVerificationReportTestResults.constructor === Array) {
            data["performanceVerificationReportTestResults"] = [];
            for (let item of this.performanceVerificationReportTestResults)
                data["performanceVerificationReportTestResults"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PerformanceVerificationReportInspectItemDto {
        const json = this.toJSON();
        let result = new PerformanceVerificationReportInspectItemDto();
        result.init(json);
        return result;
    }
}

export interface IPerformanceVerificationReportInspectItemDto {
    inspectionItem: InspectionItemDto | undefined;
    performanceVerificationReportId: string | undefined;
    inspectionItemId: string | undefined;
    qualifiedVerifyResultType: PerformanceVerificationReportInspectItemDtoQualifiedVerifyResultType | undefined;
    qualifiedVerifyReportMaterials: PerformanceVerificationReportMaterialDto[] | undefined;
    performanceVerificationReportTestResults: PerformanceVerificationReportTestResultDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class PerformanceVerificationReportMaterialDto implements IPerformanceVerificationReportMaterialDto {
    performanceVerificationReportInspectItemId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    oldBatchNo: string | undefined;
    oldExpireDate: Date | undefined;
    newBatchNo: string | undefined;
    newExpireDate: Date | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IPerformanceVerificationReportMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.performanceVerificationReportInspectItemId = data["performanceVerificationReportInspectItemId"];
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.oldBatchNo = data["oldBatchNo"];
            this.oldExpireDate = data["oldExpireDate"] ? new Date(data["oldExpireDate"].toString()) : <any>undefined;
            this.newBatchNo = data["newBatchNo"];
            this.newExpireDate = data["newExpireDate"] ? new Date(data["newExpireDate"].toString()) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PerformanceVerificationReportMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformanceVerificationReportMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["performanceVerificationReportInspectItemId"] = this.performanceVerificationReportInspectItemId;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["oldBatchNo"] = this.oldBatchNo;
        data["oldExpireDate"] = this.oldExpireDate ? this.oldExpireDate.toISOString() : <any>undefined;
        data["newBatchNo"] = this.newBatchNo;
        data["newExpireDate"] = this.newExpireDate ? this.newExpireDate.toISOString() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PerformanceVerificationReportMaterialDto {
        const json = this.toJSON();
        let result = new PerformanceVerificationReportMaterialDto();
        result.init(json);
        return result;
    }
}

export interface IPerformanceVerificationReportMaterialDto {
    performanceVerificationReportInspectItemId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    oldBatchNo: string | undefined;
    oldExpireDate: Date | undefined;
    newBatchNo: string | undefined;
    newExpireDate: Date | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class PerformanceVerificationReportTestResultDto implements IPerformanceVerificationReportTestResultDto {
    performanceVerificationReportInspectItemId: string | undefined;
    testDate: Date | undefined;
    oldBatchNoSampleNo: string | undefined;
    oldBatchNoInspectValue: string | undefined;
    oldBatchNoInspectResult: string | undefined;
    newBatchNoSampleNo: string | undefined;
    newBatchNoInspectValue: string | undefined;
    newBatchNoInspectResult: string | undefined;
    deviationValue: number | undefined;
    inspectResultType: PerformanceVerificationReportTestResultDtoInspectResultType | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IPerformanceVerificationReportTestResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.performanceVerificationReportInspectItemId = data["performanceVerificationReportInspectItemId"];
            this.testDate = data["testDate"] ? new Date(data["testDate"].toString()) : <any>undefined;
            this.oldBatchNoSampleNo = data["oldBatchNoSampleNo"];
            this.oldBatchNoInspectValue = data["oldBatchNoInspectValue"];
            this.oldBatchNoInspectResult = data["oldBatchNoInspectResult"];
            this.newBatchNoSampleNo = data["newBatchNoSampleNo"];
            this.newBatchNoInspectValue = data["newBatchNoInspectValue"];
            this.newBatchNoInspectResult = data["newBatchNoInspectResult"];
            this.deviationValue = data["deviationValue"];
            this.inspectResultType = data["inspectResultType"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PerformanceVerificationReportTestResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PerformanceVerificationReportTestResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["performanceVerificationReportInspectItemId"] = this.performanceVerificationReportInspectItemId;
        data["testDate"] = this.testDate ? this.testDate.toISOString() : <any>undefined;
        data["oldBatchNoSampleNo"] = this.oldBatchNoSampleNo;
        data["oldBatchNoInspectValue"] = this.oldBatchNoInspectValue;
        data["oldBatchNoInspectResult"] = this.oldBatchNoInspectResult;
        data["newBatchNoSampleNo"] = this.newBatchNoSampleNo;
        data["newBatchNoInspectValue"] = this.newBatchNoInspectValue;
        data["newBatchNoInspectResult"] = this.newBatchNoInspectResult;
        data["deviationValue"] = this.deviationValue;
        data["inspectResultType"] = this.inspectResultType;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PerformanceVerificationReportTestResultDto {
        const json = this.toJSON();
        let result = new PerformanceVerificationReportTestResultDto();
        result.init(json);
        return result;
    }
}

export interface IPerformanceVerificationReportTestResultDto {
    performanceVerificationReportInspectItemId: string | undefined;
    testDate: Date | undefined;
    oldBatchNoSampleNo: string | undefined;
    oldBatchNoInspectValue: string | undefined;
    oldBatchNoInspectResult: string | undefined;
    newBatchNoSampleNo: string | undefined;
    newBatchNoInspectValue: string | undefined;
    newBatchNoInspectResult: string | undefined;
    deviationValue: number | undefined;
    inspectResultType: PerformanceVerificationReportTestResultDtoInspectResultType | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateOrUpdatePerformanceVerificationReportInput implements ICreateOrUpdatePerformanceVerificationReportInput {
    reportNo: string | undefined;
    performanceVerificationRecordId: string | undefined;
    applyItem: string | undefined;
    summary: string | undefined;
    instrumentId: string | undefined;
    qualifiedVerifyType: CreateOrUpdatePerformanceVerificationReportInputQualifiedVerifyType | undefined;
    verificationStandardValue: number | undefined;
    evaluateUserId: number | undefined;
    evaluationTime: Date | undefined;
    checkUserId: number | undefined;
    checkerAccount: string | undefined;
    checkTime: Date | undefined;
    organizationId: number | undefined;
    qualifiedVerifyReportInspectItems: CreatePerformanceVerificationReportInspectItemDto[] | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdatePerformanceVerificationReportInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reportNo = data["reportNo"];
            this.performanceVerificationRecordId = data["performanceVerificationRecordId"];
            this.applyItem = data["applyItem"];
            this.summary = data["summary"];
            this.instrumentId = data["instrumentId"];
            this.qualifiedVerifyType = data["qualifiedVerifyType"];
            this.verificationStandardValue = data["verificationStandardValue"];
            this.evaluateUserId = data["evaluateUserId"];
            this.evaluationTime = data["evaluationTime"] ? new Date(data["evaluationTime"].toString()) : <any>undefined;
            this.checkUserId = data["checkUserId"];
            this.checkerAccount = data["checkerAccount"];
            this.checkTime = data["checkTime"] ? new Date(data["checkTime"].toString()) : <any>undefined;
            this.organizationId = data["organizationId"];
            if (data["qualifiedVerifyReportInspectItems"] && data["qualifiedVerifyReportInspectItems"].constructor === Array) {
                this.qualifiedVerifyReportInspectItems = [];
                for (let item of data["qualifiedVerifyReportInspectItems"])
                    this.qualifiedVerifyReportInspectItems.push(CreatePerformanceVerificationReportInspectItemDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdatePerformanceVerificationReportInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdatePerformanceVerificationReportInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportNo"] = this.reportNo;
        data["performanceVerificationRecordId"] = this.performanceVerificationRecordId;
        data["applyItem"] = this.applyItem;
        data["summary"] = this.summary;
        data["instrumentId"] = this.instrumentId;
        data["qualifiedVerifyType"] = this.qualifiedVerifyType;
        data["verificationStandardValue"] = this.verificationStandardValue;
        data["evaluateUserId"] = this.evaluateUserId;
        data["evaluationTime"] = this.evaluationTime ? this.evaluationTime.toISOString() : <any>undefined;
        data["checkUserId"] = this.checkUserId;
        data["checkerAccount"] = this.checkerAccount;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        data["organizationId"] = this.organizationId;
        if (this.qualifiedVerifyReportInspectItems && this.qualifiedVerifyReportInspectItems.constructor === Array) {
            data["qualifiedVerifyReportInspectItems"] = [];
            for (let item of this.qualifiedVerifyReportInspectItems)
                data["qualifiedVerifyReportInspectItems"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdatePerformanceVerificationReportInput {
        const json = this.toJSON();
        let result = new CreateOrUpdatePerformanceVerificationReportInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdatePerformanceVerificationReportInput {
    reportNo: string | undefined;
    performanceVerificationRecordId: string | undefined;
    applyItem: string | undefined;
    summary: string | undefined;
    instrumentId: string | undefined;
    qualifiedVerifyType: CreateOrUpdatePerformanceVerificationReportInputQualifiedVerifyType | undefined;
    verificationStandardValue: number | undefined;
    evaluateUserId: number | undefined;
    evaluationTime: Date | undefined;
    checkUserId: number | undefined;
    checkerAccount: string | undefined;
    checkTime: Date | undefined;
    organizationId: number | undefined;
    qualifiedVerifyReportInspectItems: CreatePerformanceVerificationReportInspectItemDto[] | undefined;
    id: string | undefined;
}

export class CreatePerformanceVerificationReportInspectItemDto implements ICreatePerformanceVerificationReportInspectItemDto {
    performanceVerificationReportId: string | undefined;
    inspectionItemId: string | undefined;
    qualifiedVerifyResultType: CreatePerformanceVerificationReportInspectItemDtoQualifiedVerifyResultType | undefined;
    qualifiedVerifyReportMaterials: CreatePerformanceVerificationReportMaterialDto[] | undefined;
    performanceVerificationReportTestResults: CreatePerformanceVerificationReportTestResultDto[] | undefined;

    constructor(data?: ICreatePerformanceVerificationReportInspectItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.performanceVerificationReportId = data["performanceVerificationReportId"];
            this.inspectionItemId = data["inspectionItemId"];
            this.qualifiedVerifyResultType = data["qualifiedVerifyResultType"];
            if (data["qualifiedVerifyReportMaterials"] && data["qualifiedVerifyReportMaterials"].constructor === Array) {
                this.qualifiedVerifyReportMaterials = [];
                for (let item of data["qualifiedVerifyReportMaterials"])
                    this.qualifiedVerifyReportMaterials.push(CreatePerformanceVerificationReportMaterialDto.fromJS(item));
            }
            if (data["performanceVerificationReportTestResults"] && data["performanceVerificationReportTestResults"].constructor === Array) {
                this.performanceVerificationReportTestResults = [];
                for (let item of data["performanceVerificationReportTestResults"])
                    this.performanceVerificationReportTestResults.push(CreatePerformanceVerificationReportTestResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreatePerformanceVerificationReportInspectItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePerformanceVerificationReportInspectItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["performanceVerificationReportId"] = this.performanceVerificationReportId;
        data["inspectionItemId"] = this.inspectionItemId;
        data["qualifiedVerifyResultType"] = this.qualifiedVerifyResultType;
        if (this.qualifiedVerifyReportMaterials && this.qualifiedVerifyReportMaterials.constructor === Array) {
            data["qualifiedVerifyReportMaterials"] = [];
            for (let item of this.qualifiedVerifyReportMaterials)
                data["qualifiedVerifyReportMaterials"].push(item.toJSON());
        }
        if (this.performanceVerificationReportTestResults && this.performanceVerificationReportTestResults.constructor === Array) {
            data["performanceVerificationReportTestResults"] = [];
            for (let item of this.performanceVerificationReportTestResults)
                data["performanceVerificationReportTestResults"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreatePerformanceVerificationReportInspectItemDto {
        const json = this.toJSON();
        let result = new CreatePerformanceVerificationReportInspectItemDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePerformanceVerificationReportInspectItemDto {
    performanceVerificationReportId: string | undefined;
    inspectionItemId: string | undefined;
    qualifiedVerifyResultType: CreatePerformanceVerificationReportInspectItemDtoQualifiedVerifyResultType | undefined;
    qualifiedVerifyReportMaterials: CreatePerformanceVerificationReportMaterialDto[] | undefined;
    performanceVerificationReportTestResults: CreatePerformanceVerificationReportTestResultDto[] | undefined;
}

export class CreatePerformanceVerificationReportMaterialDto implements ICreatePerformanceVerificationReportMaterialDto {
    performanceVerificationReportInspectItemId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    oldBatchNo: string | undefined;
    oldExpireDate: Date | undefined;
    newBatchNo: string | undefined;
    newExpireDate: Date | undefined;

    constructor(data?: ICreatePerformanceVerificationReportMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.performanceVerificationReportInspectItemId = data["performanceVerificationReportInspectItemId"];
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.oldBatchNo = data["oldBatchNo"];
            this.oldExpireDate = data["oldExpireDate"] ? new Date(data["oldExpireDate"].toString()) : <any>undefined;
            this.newBatchNo = data["newBatchNo"];
            this.newExpireDate = data["newExpireDate"] ? new Date(data["newExpireDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreatePerformanceVerificationReportMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePerformanceVerificationReportMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["performanceVerificationReportInspectItemId"] = this.performanceVerificationReportInspectItemId;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["oldBatchNo"] = this.oldBatchNo;
        data["oldExpireDate"] = this.oldExpireDate ? this.oldExpireDate.toISOString() : <any>undefined;
        data["newBatchNo"] = this.newBatchNo;
        data["newExpireDate"] = this.newExpireDate ? this.newExpireDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CreatePerformanceVerificationReportMaterialDto {
        const json = this.toJSON();
        let result = new CreatePerformanceVerificationReportMaterialDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePerformanceVerificationReportMaterialDto {
    performanceVerificationReportInspectItemId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    oldBatchNo: string | undefined;
    oldExpireDate: Date | undefined;
    newBatchNo: string | undefined;
    newExpireDate: Date | undefined;
}

export class CreatePerformanceVerificationReportTestResultDto implements ICreatePerformanceVerificationReportTestResultDto {
    performanceVerificationReportInspectItemId: string | undefined;
    testDate: Date | undefined;
    oldBatchNoSampleNo: string | undefined;
    oldBatchNoInspectValue: string | undefined;
    oldBatchNoInspectResult: string | undefined;
    newBatchNoSampleNo: string | undefined;
    newBatchNoInspectValue: string | undefined;
    newBatchNoInspectResult: string | undefined;
    deviationValue: number | undefined;
    inspectResultType: CreatePerformanceVerificationReportTestResultDtoInspectResultType | undefined;

    constructor(data?: ICreatePerformanceVerificationReportTestResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.performanceVerificationReportInspectItemId = data["performanceVerificationReportInspectItemId"];
            this.testDate = data["testDate"] ? new Date(data["testDate"].toString()) : <any>undefined;
            this.oldBatchNoSampleNo = data["oldBatchNoSampleNo"];
            this.oldBatchNoInspectValue = data["oldBatchNoInspectValue"];
            this.oldBatchNoInspectResult = data["oldBatchNoInspectResult"];
            this.newBatchNoSampleNo = data["newBatchNoSampleNo"];
            this.newBatchNoInspectValue = data["newBatchNoInspectValue"];
            this.newBatchNoInspectResult = data["newBatchNoInspectResult"];
            this.deviationValue = data["deviationValue"];
            this.inspectResultType = data["inspectResultType"];
        }
    }

    static fromJS(data: any): CreatePerformanceVerificationReportTestResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePerformanceVerificationReportTestResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["performanceVerificationReportInspectItemId"] = this.performanceVerificationReportInspectItemId;
        data["testDate"] = this.testDate ? this.testDate.toISOString() : <any>undefined;
        data["oldBatchNoSampleNo"] = this.oldBatchNoSampleNo;
        data["oldBatchNoInspectValue"] = this.oldBatchNoInspectValue;
        data["oldBatchNoInspectResult"] = this.oldBatchNoInspectResult;
        data["newBatchNoSampleNo"] = this.newBatchNoSampleNo;
        data["newBatchNoInspectValue"] = this.newBatchNoInspectValue;
        data["newBatchNoInspectResult"] = this.newBatchNoInspectResult;
        data["deviationValue"] = this.deviationValue;
        data["inspectResultType"] = this.inspectResultType;
        return data; 
    }

    clone(): CreatePerformanceVerificationReportTestResultDto {
        const json = this.toJSON();
        let result = new CreatePerformanceVerificationReportTestResultDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePerformanceVerificationReportTestResultDto {
    performanceVerificationReportInspectItemId: string | undefined;
    testDate: Date | undefined;
    oldBatchNoSampleNo: string | undefined;
    oldBatchNoInspectValue: string | undefined;
    oldBatchNoInspectResult: string | undefined;
    newBatchNoSampleNo: string | undefined;
    newBatchNoInspectValue: string | undefined;
    newBatchNoInspectResult: string | undefined;
    deviationValue: number | undefined;
    inspectResultType: CreatePerformanceVerificationReportTestResultDtoInspectResultType | undefined;
}

export class PagedResultDtoOfGetPerformanceVerificationReportPaginationOutput implements IPagedResultDtoOfGetPerformanceVerificationReportPaginationOutput {
    totalCount: number | undefined;
    items: GetPerformanceVerificationReportPaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetPerformanceVerificationReportPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetPerformanceVerificationReportPaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetPerformanceVerificationReportPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetPerformanceVerificationReportPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetPerformanceVerificationReportPaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetPerformanceVerificationReportPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetPerformanceVerificationReportPaginationOutput {
    totalCount: number | undefined;
    items: GetPerformanceVerificationReportPaginationOutput[] | undefined;
}

export class GetPerformanceVerificationReportPaginationOutput implements IGetPerformanceVerificationReportPaginationOutput {
    reportNo: string | undefined;
    performanceVerificationRecordId: string | undefined;
    applyItem: string | undefined;
    summary: string | undefined;
    instrumentId: string | undefined;
    qualifiedVerifyType: GetPerformanceVerificationReportPaginationOutputQualifiedVerifyType | undefined;
    verificationStandardValue: number | undefined;
    evaluateUserId: number | undefined;
    evaluationTime: Date | undefined;
    checkUserId: number | undefined;
    checkerAccount: string | undefined;
    checkTime: Date | undefined;
    organizationId: number | undefined;
    qualifiedVerifyReportInspectItems: PerformanceVerificationReportInspectItemDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetPerformanceVerificationReportPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reportNo = data["reportNo"];
            this.performanceVerificationRecordId = data["performanceVerificationRecordId"];
            this.applyItem = data["applyItem"];
            this.summary = data["summary"];
            this.instrumentId = data["instrumentId"];
            this.qualifiedVerifyType = data["qualifiedVerifyType"];
            this.verificationStandardValue = data["verificationStandardValue"];
            this.evaluateUserId = data["evaluateUserId"];
            this.evaluationTime = data["evaluationTime"] ? new Date(data["evaluationTime"].toString()) : <any>undefined;
            this.checkUserId = data["checkUserId"];
            this.checkerAccount = data["checkerAccount"];
            this.checkTime = data["checkTime"] ? new Date(data["checkTime"].toString()) : <any>undefined;
            this.organizationId = data["organizationId"];
            if (data["qualifiedVerifyReportInspectItems"] && data["qualifiedVerifyReportInspectItems"].constructor === Array) {
                this.qualifiedVerifyReportInspectItems = [];
                for (let item of data["qualifiedVerifyReportInspectItems"])
                    this.qualifiedVerifyReportInspectItems.push(PerformanceVerificationReportInspectItemDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetPerformanceVerificationReportPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPerformanceVerificationReportPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportNo"] = this.reportNo;
        data["performanceVerificationRecordId"] = this.performanceVerificationRecordId;
        data["applyItem"] = this.applyItem;
        data["summary"] = this.summary;
        data["instrumentId"] = this.instrumentId;
        data["qualifiedVerifyType"] = this.qualifiedVerifyType;
        data["verificationStandardValue"] = this.verificationStandardValue;
        data["evaluateUserId"] = this.evaluateUserId;
        data["evaluationTime"] = this.evaluationTime ? this.evaluationTime.toISOString() : <any>undefined;
        data["checkUserId"] = this.checkUserId;
        data["checkerAccount"] = this.checkerAccount;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        data["organizationId"] = this.organizationId;
        if (this.qualifiedVerifyReportInspectItems && this.qualifiedVerifyReportInspectItems.constructor === Array) {
            data["qualifiedVerifyReportInspectItems"] = [];
            for (let item of this.qualifiedVerifyReportInspectItems)
                data["qualifiedVerifyReportInspectItems"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetPerformanceVerificationReportPaginationOutput {
        const json = this.toJSON();
        let result = new GetPerformanceVerificationReportPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetPerformanceVerificationReportPaginationOutput {
    reportNo: string | undefined;
    performanceVerificationRecordId: string | undefined;
    applyItem: string | undefined;
    summary: string | undefined;
    instrumentId: string | undefined;
    qualifiedVerifyType: GetPerformanceVerificationReportPaginationOutputQualifiedVerifyType | undefined;
    verificationStandardValue: number | undefined;
    evaluateUserId: number | undefined;
    evaluationTime: Date | undefined;
    checkUserId: number | undefined;
    checkerAccount: string | undefined;
    checkTime: Date | undefined;
    organizationId: number | undefined;
    qualifiedVerifyReportInspectItems: PerformanceVerificationReportInspectItemDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class ListResultDtoOfGetAllPermissionOutput implements IListResultDtoOfGetAllPermissionOutput {
    items: GetAllPermissionOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllPermissionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetAllPermissionOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllPermissionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllPermissionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfGetAllPermissionOutput {
        const json = this.toJSON();
        let result = new ListResultDtoOfGetAllPermissionOutput();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfGetAllPermissionOutput {
    items: GetAllPermissionOutput[] | undefined;
}

export class GetAllPermissionOutput implements IGetAllPermissionOutput {
    id: string | undefined;
    code: string | undefined;
    name: string | undefined;
    parentId: string | undefined;
    isGranted: boolean | undefined;
    children: GetAllPermissionOutput[] | undefined;

    constructor(data?: IGetAllPermissionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.code = data["code"];
            this.name = data["name"];
            this.parentId = data["parentId"];
            this.isGranted = data["isGranted"];
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(GetAllPermissionOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllPermissionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPermissionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["isGranted"] = this.isGranted;
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetAllPermissionOutput {
        const json = this.toJSON();
        let result = new GetAllPermissionOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllPermissionOutput {
    id: string | undefined;
    code: string | undefined;
    name: string | undefined;
    parentId: string | undefined;
    isGranted: boolean | undefined;
    children: GetAllPermissionOutput[] | undefined;
}

export class ListResultDtoOfGetGrantedPermissionOutput implements IListResultDtoOfGetGrantedPermissionOutput {
    items: GetGrantedPermissionOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetGrantedPermissionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetGrantedPermissionOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetGrantedPermissionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetGrantedPermissionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfGetGrantedPermissionOutput {
        const json = this.toJSON();
        let result = new ListResultDtoOfGetGrantedPermissionOutput();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfGetGrantedPermissionOutput {
    items: GetGrantedPermissionOutput[] | undefined;
}

export class GetGrantedPermissionOutput implements IGetGrantedPermissionOutput {
    code: string | undefined;
    name: string | undefined;
    icon: string | undefined;
    url: string | undefined;
    displayName: string | undefined;
    isDefault: boolean | undefined;
    sortRank: number | undefined;
    isGranted: boolean | undefined;
    children: GetGrantedPermissionOutput[] | undefined;

    constructor(data?: IGetGrantedPermissionOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.url = data["url"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
            this.sortRank = data["sortRank"];
            this.isGranted = data["isGranted"];
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(GetGrantedPermissionOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetGrantedPermissionOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGrantedPermissionOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["url"] = this.url;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        data["sortRank"] = this.sortRank;
        data["isGranted"] = this.isGranted;
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetGrantedPermissionOutput {
        const json = this.toJSON();
        let result = new GetGrantedPermissionOutput();
        result.init(json);
        return result;
    }
}

export interface IGetGrantedPermissionOutput {
    code: string | undefined;
    name: string | undefined;
    icon: string | undefined;
    url: string | undefined;
    displayName: string | undefined;
    isDefault: boolean | undefined;
    sortRank: number | undefined;
    isGranted: boolean | undefined;
    children: GetGrantedPermissionOutput[] | undefined;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.timezone = data["timezone"];
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }

    clone(): CurrentUserProfileEditDto {
        const json = this.toJSON();
        let result = new CurrentUserProfileEditDto();
        result.init(json);
        return result;
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data; 
    }

    clone(): UpdateGoogleAuthenticatorKeyOutput {
        const json = this.toJSON();
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(json);
        return result;
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data; 
    }

    clone(): VerifySmsCodeInputDto {
        const json = this.toJSON();
        let result = new VerifySmsCodeInputDto();
        result.init(json);
        return result;
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordInput {
        const json = this.toJSON();
        let result = new ChangePasswordInput();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileName: string;
    x: number | undefined;
    y: number | undefined;
    width: number | undefined;
    height: number | undefined;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }

    clone(): UpdateProfilePictureInput {
        const json = this.toJSON();
        let result = new UpdateProfilePictureInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateProfilePictureInput {
    fileName: string;
    x: number | undefined;
    y: number | undefined;
    width: number | undefined;
    height: number | undefined;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting | undefined;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.setting = data["setting"] ? PasswordComplexitySetting.fromJS(data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetPasswordComplexitySettingOutput {
        const json = this.toJSON();
        let result = new GetPasswordComplexitySettingOutput();
        result.init(json);
        return result;
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting | undefined;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }

    clone(): GetProfilePictureOutput {
        const json = this.toJSON();
        let result = new GetProfilePictureOutput();
        result.init(json);
        return result;
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: Date | undefined;
    id: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: Date | undefined;
    id: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): CreateOrUpdateRoleInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateRoleInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class UpdateRolePermissionsInput implements IUpdateRolePermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];

    constructor(data?: IUpdateRolePermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateRolePermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRolePermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): UpdateRolePermissionsInput {
        const json = this.toJSON();
        let result = new UpdateRolePermissionsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateRolePermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
    application: ApplicationInfoDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
    application: ApplicationInfoDto | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    organizationUnitId: number | undefined;
    organizationUnitName: string | undefined;
    profilePictureId: string | undefined;
    id: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.organizationUnitId = data["organizationUnitId"];
            this.organizationUnitName = data["organizationUnitName"];
            this.profilePictureId = data["profilePictureId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["organizationUnitId"] = this.organizationUnitId;
        data["organizationUnitName"] = this.organizationUnitName;
        data["profilePictureId"] = this.profilePictureId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    organizationUnitId: number | undefined;
    organizationUnitName: string | undefined;
    profilePictureId: string | undefined;
    id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: Date | undefined;
    isInTrialPeriod: boolean | undefined;
    edition: EditionInfoDto | undefined;
    creationTime: Date | undefined;
    paymentPeriodType: TenantLoginInfoDtoPaymentPeriodType | undefined;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.logoId = data["logoId"];
            this.logoFileType = data["logoFileType"];
            this.customCssId = data["customCssId"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? new Date(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.edition = data["edition"] ? EditionInfoDto.fromJS(data["edition"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionDateString = data["subscriptionDateString"];
            this.creationTimeString = data["creationTimeString"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: Date | undefined;
    isInTrialPeriod: boolean | undefined;
    edition: EditionInfoDto | undefined;
    creationTime: Date | undefined;
    paymentPeriodType: TenantLoginInfoDtoPaymentPeriodType | undefined;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: Date | undefined;
    features: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? new Date(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: Date | undefined;
    features: { [key: string] : boolean; } | undefined;
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean | undefined;
    isFree: boolean | undefined;
    id: number | undefined;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.trialDayCount = data["trialDayCount"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.isHighestEdition = data["isHighestEdition"];
            this.isFree = data["isFree"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data; 
    }

    clone(): EditionInfoDto {
        const json = this.toJSON();
        let result = new EditionInfoDto();
        result.init(json);
        return result;
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean | undefined;
    isFree: boolean | undefined;
    id: number | undefined;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.encodedUserId = data["encodedUserId"];
            this.encodedTenantId = data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }

    clone(): UpdateUserSignInTokenOutput {
        const json = this.toJSON();
        let result = new UpdateUserSignInTokenOutput();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class GetStorageLocationForEditOutput implements IGetStorageLocationForEditOutput {
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseName: string | undefined;
    locationCode: string | undefined;
    locationName: string | undefined;
    storageLocationDetails: StorageLocationDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetStorageLocationForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.warehouseInfoId = data["warehouseInfoId"];
            this.warehouseName = data["warehouseName"];
            this.locationCode = data["locationCode"];
            this.locationName = data["locationName"];
            if (data["storageLocationDetails"] && data["storageLocationDetails"].constructor === Array) {
                this.storageLocationDetails = [];
                for (let item of data["storageLocationDetails"])
                    this.storageLocationDetails.push(StorageLocationDetailDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetStorageLocationForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStorageLocationForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["warehouseInfoId"] = this.warehouseInfoId;
        data["warehouseName"] = this.warehouseName;
        data["locationCode"] = this.locationCode;
        data["locationName"] = this.locationName;
        if (this.storageLocationDetails && this.storageLocationDetails.constructor === Array) {
            data["storageLocationDetails"] = [];
            for (let item of this.storageLocationDetails)
                data["storageLocationDetails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetStorageLocationForEditOutput {
        const json = this.toJSON();
        let result = new GetStorageLocationForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetStorageLocationForEditOutput {
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseName: string | undefined;
    locationCode: string | undefined;
    locationName: string | undefined;
    storageLocationDetails: StorageLocationDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class StorageLocationDetailDto implements IStorageLocationDetailDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    storageLocationId: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IStorageLocationDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.storageLocationId = data["storageLocationId"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): StorageLocationDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new StorageLocationDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["storageLocationId"] = this.storageLocationId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): StorageLocationDetailDto {
        const json = this.toJSON();
        let result = new StorageLocationDetailDto();
        result.init(json);
        return result;
    }
}

export interface IStorageLocationDetailDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    storageLocationId: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class CreateOrUpdateStorageLocationInput implements ICreateOrUpdateStorageLocationInput {
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseName: string | undefined;
    locationCode: string | undefined;
    locationName: string | undefined;
    storageLocationDetails: CreateOrUpdateStorageLocationDetailInput[] | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateStorageLocationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.warehouseInfoId = data["warehouseInfoId"];
            this.warehouseName = data["warehouseName"];
            this.locationCode = data["locationCode"];
            this.locationName = data["locationName"];
            if (data["storageLocationDetails"] && data["storageLocationDetails"].constructor === Array) {
                this.storageLocationDetails = [];
                for (let item of data["storageLocationDetails"])
                    this.storageLocationDetails.push(CreateOrUpdateStorageLocationDetailInput.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateStorageLocationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateStorageLocationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["warehouseInfoId"] = this.warehouseInfoId;
        data["warehouseName"] = this.warehouseName;
        data["locationCode"] = this.locationCode;
        data["locationName"] = this.locationName;
        if (this.storageLocationDetails && this.storageLocationDetails.constructor === Array) {
            data["storageLocationDetails"] = [];
            for (let item of this.storageLocationDetails)
                data["storageLocationDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateStorageLocationInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateStorageLocationInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateStorageLocationInput {
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseName: string | undefined;
    locationCode: string | undefined;
    locationName: string | undefined;
    storageLocationDetails: CreateOrUpdateStorageLocationDetailInput[] | undefined;
    id: string | undefined;
}

export class CreateOrUpdateStorageLocationDetailInput implements ICreateOrUpdateStorageLocationDetailInput {
    storageLocationId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateStorageLocationDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.storageLocationId = data["storageLocationId"];
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateStorageLocationDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateStorageLocationDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storageLocationId"] = this.storageLocationId;
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateStorageLocationDetailInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateStorageLocationDetailInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateStorageLocationDetailInput {
    storageLocationId: string | undefined;
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetStorageLocationPaginationOutput implements IPagedResultDtoOfGetStorageLocationPaginationOutput {
    totalCount: number | undefined;
    items: GetStorageLocationPaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetStorageLocationPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetStorageLocationPaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetStorageLocationPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetStorageLocationPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetStorageLocationPaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetStorageLocationPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetStorageLocationPaginationOutput {
    totalCount: number | undefined;
    items: GetStorageLocationPaginationOutput[] | undefined;
}

export class GetStorageLocationPaginationOutput implements IGetStorageLocationPaginationOutput {
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseName: string | undefined;
    locationCode: string | undefined;
    locationName: string | undefined;
    storageLocationDetails: StorageLocationDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetStorageLocationPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.warehouseInfoId = data["warehouseInfoId"];
            this.warehouseName = data["warehouseName"];
            this.locationCode = data["locationCode"];
            this.locationName = data["locationName"];
            if (data["storageLocationDetails"] && data["storageLocationDetails"].constructor === Array) {
                this.storageLocationDetails = [];
                for (let item of data["storageLocationDetails"])
                    this.storageLocationDetails.push(StorageLocationDetailDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetStorageLocationPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStorageLocationPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["warehouseInfoId"] = this.warehouseInfoId;
        data["warehouseName"] = this.warehouseName;
        data["locationCode"] = this.locationCode;
        data["locationName"] = this.locationName;
        if (this.storageLocationDetails && this.storageLocationDetails.constructor === Array) {
            data["storageLocationDetails"] = [];
            for (let item of this.storageLocationDetails)
                data["storageLocationDetails"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetStorageLocationPaginationOutput {
        const json = this.toJSON();
        let result = new GetStorageLocationPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetStorageLocationPaginationOutput {
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseName: string | undefined;
    locationCode: string | undefined;
    locationName: string | undefined;
    storageLocationDetails: StorageLocationDetailDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount: number | undefined;
    items: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTenantListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTenantListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number | undefined;
    items: TenantListDto[] | undefined;
}

export class TenantListDto implements ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    creationTime: Date | undefined;
    subscriptionEndDateUtc: Date | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.editionDisplayName = data["editionDisplayName"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? new Date(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = data["editionId"];
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantListDto {
        const json = this.toJSON();
        let result = new TenantListDto();
        result.init(json);
        return result;
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    creationTime: Date | undefined;
    subscriptionEndDateUtc: Date | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: Date | undefined;
    isInTrialPeriod: boolean | undefined;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.connectionString = data["connectionString"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? new Date(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }

    clone(): CreateTenantInput {
        const json = this.toJSON();
        let result = new CreateTenantInput();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: Date | undefined;
    isInTrialPeriod: boolean | undefined;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: Date | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? new Date(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantEditDto {
        const json = this.toJSON();
        let result = new TenantEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: Date | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetTenantFeaturesEditOutput {
        const json = this.toJSON();
        let result = new GetTenantFeaturesEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id: number | undefined;
    featureValues: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdateTenantFeaturesInput {
        const json = this.toJSON();
        let result = new UpdateTenantFeaturesInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number | undefined;
    featureValues: NameValueDto[];
}

export class EntityDto implements IEntityDto {
    id: number | undefined;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDto {
        const json = this.toJSON();
        let result = new EntityDto();
        result.init(json);
        return result;
    }
}

export interface IEntityDto {
    id: number | undefined;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["memberActivities"] && data["memberActivities"].constructor === Array) {
                this.memberActivities = [];
                for (let item of data["memberActivities"])
                    this.memberActivities.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.memberActivities && this.memberActivities.constructor === Array) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetMemberActivityOutput {
        const json = this.toJSON();
        let result = new GetMemberActivityOutput();
        result.init(json);
        return result;
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;
}

export class MemberActivity implements IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number | undefined;
    closed: number | undefined;
    rate: string | undefined;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.earnings = data["earnings"];
            this.cases = data["cases"];
            this.closed = data["closed"];
            this.rate = data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data; 
    }

    clone(): MemberActivity {
        const json = this.toJSON();
        let result = new MemberActivity();
        result.init(json);
        return result;
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number | undefined;
    closed: number | undefined;
    rate: string | undefined;
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit: number | undefined;
    newFeedbacks: number | undefined;
    newOrders: number | undefined;
    newUsers: number | undefined;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number | undefined;
    revenue: number | undefined;
    expenses: number | undefined;
    growth: number | undefined;
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalProfit = data["totalProfit"];
            this.newFeedbacks = data["newFeedbacks"];
            this.newOrders = data["newOrders"];
            this.newUsers = data["newUsers"];
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [];
                for (let item of data["salesSummary"])
                    this.salesSummary.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = data["totalSales"];
            this.revenue = data["revenue"];
            this.expenses = data["expenses"];
            this.growth = data["growth"];
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
            if (data["dailySales"] && data["dailySales"].constructor === Array) {
                this.dailySales = [];
                for (let item of data["dailySales"])
                    this.dailySales.push(item);
            }
            if (data["profitShares"] && data["profitShares"].constructor === Array) {
                this.profitShares = [];
                for (let item of data["profitShares"])
                    this.profitShares.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (this.dailySales && this.dailySales.constructor === Array) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (this.profitShares && this.profitShares.constructor === Array) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }

    clone(): GetDashboardDataOutput {
        const json = this.toJSON();
        let result = new GetDashboardDataOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number | undefined;
    newFeedbacks: number | undefined;
    newOrders: number | undefined;
    newUsers: number | undefined;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number | undefined;
    revenue: number | undefined;
    expenses: number | undefined;
    growth: number | undefined;
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;
}

export class SalesSummaryData implements ISalesSummaryData {
    period: string | undefined;
    sales: number | undefined;
    profit: number | undefined;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"];
            this.sales = data["sales"];
            this.profit = data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data; 
    }

    clone(): SalesSummaryData {
        const json = this.toJSON();
        let result = new SalesSummaryData();
        result.init(json);
        return result;
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number | undefined;
    profit: number | undefined;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    salesSummary: SalesSummaryData[] | undefined;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [];
                for (let item of data["salesSummary"])
                    this.salesSummary.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetSalesSummaryOutput {
        const json = this.toJSON();
        let result = new GetSalesSummaryOutput();
        result.init(json);
        return result;
    }
}

export interface IGetSalesSummaryOutput {
    salesSummary: SalesSummaryData[] | undefined;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["stats"] && data["stats"].constructor === Array) {
                this.stats = [];
                for (let item of data["stats"])
                    this.stats.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.stats && this.stats.constructor === Array) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetRegionalStatsOutput {
        const json = this.toJSON();
        let result = new GetRegionalStatsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName: string | undefined;
    sales: number | undefined;
    change: number[] | undefined;
    averagePrice: number | undefined;
    totalPrice: number | undefined;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryName = data["countryName"];
            this.sales = data["sales"];
            if (data["change"] && data["change"].constructor === Array) {
                this.change = [];
                for (let item of data["change"])
                    this.change.push(item);
            }
            this.averagePrice = data["averagePrice"];
            this.totalPrice = data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (this.change && this.change.constructor === Array) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data; 
    }

    clone(): RegionalStatCountry {
        const json = this.toJSON();
        let result = new RegionalStatCountry();
        result.init(json);
        return result;
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number | undefined;
    change: number[] | undefined;
    averagePrice: number | undefined;
    totalPrice: number | undefined;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data; 
    }

    clone(): GetGeneralStatsOutput {
        const json = this.toJSON();
        let result = new GetGeneralStatsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: RegisterTenantInputSubscriptionStartType | undefined;
    gateway: RegisterTenantInputGateway | undefined;
    editionId: number | undefined;
    paymentId: string | undefined;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.captchaResponse = data["captchaResponse"];
            this.subscriptionStartType = data["subscriptionStartType"];
            this.gateway = data["gateway"];
            this.editionId = data["editionId"];
            this.paymentId = data["paymentId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["gateway"] = this.gateway;
        data["editionId"] = this.editionId;
        data["paymentId"] = this.paymentId;
        return data; 
    }

    clone(): RegisterTenantInput {
        const json = this.toJSON();
        let result = new RegisterTenantInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: RegisterTenantInputSubscriptionStartType | undefined;
    gateway: RegisterTenantInputGateway | undefined;
    editionId: number | undefined;
    paymentId: string | undefined;
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean | undefined;
    isActive: boolean | undefined;
    isEmailConfirmationRequired: boolean | undefined;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.isTenantActive = data["isTenantActive"];
            this.isActive = data["isActive"];
            this.isEmailConfirmationRequired = data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data; 
    }

    clone(): RegisterTenantOutput {
        const json = this.toJSON();
        let result = new RegisterTenantOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterTenantOutput {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean | undefined;
    isActive: boolean | undefined;
    isEmailConfirmationRequired: boolean | undefined;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
    tenantEditionId: number | undefined;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allFeatures"] && data["allFeatures"].constructor === Array) {
                this.allFeatures = [];
                for (let item of data["allFeatures"])
                    this.allFeatures.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (data["editionsWithFeatures"] && data["editionsWithFeatures"].constructor === Array) {
                this.editionsWithFeatures = [];
                for (let item of data["editionsWithFeatures"])
                    this.editionsWithFeatures.push(EditionWithFeaturesDto.fromJS(item));
            }
            this.tenantEditionId = data["tenantEditionId"];
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allFeatures && this.allFeatures.constructor === Array) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (this.editionsWithFeatures && this.editionsWithFeatures.constructor === Array) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        data["tenantEditionId"] = this.tenantEditionId;
        return data; 
    }

    clone(): EditionsSelectOutput {
        const json = this.toJSON();
        let result = new EditionsSelectOutput();
        result.init(json);
        return result;
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
    tenantEditionId: number | undefined;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType | undefined;
    textHtmlColor: string | undefined;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? IInputType.fromJS(data["inputType"]) : <any>undefined;
            this.textHtmlColor = data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data; 
    }

    clone(): FlatFeatureSelectDto {
        const json = this.toJSON();
        let result = new FlatFeatureSelectDto();
        result.init(json);
        return result;
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType | undefined;
    textHtmlColor: string | undefined;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition: EditionSelectDto | undefined;
    featureValues: NameValueDto[] | undefined;

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone(): EditionWithFeaturesDto {
        const json = this.toJSON();
        let result = new EditionWithFeaturesDto();
        result.init(json);
        return result;
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto | undefined;
    featureValues: NameValueDto[] | undefined;
}

export class IInputType implements IIInputType {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data; 
    }

    clone(): IInputType {
        const json = this.toJSON();
        let result = new IInputType();
        result.init(json);
        return result;
    }
}

export interface IIInputType {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general: GeneralSettingsEditDto | undefined;
    userManagement: TenantUserManagementSettingsEditDto;
    email: EmailSettingsEditDto | undefined;
    ldap: LdapSettingsEditDto | undefined;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto | undefined;
    inventory: InventorySettingsEditDto | undefined;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : <any>undefined;
            this.userManagement = data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : <any>undefined;
            this.ldap = data["ldap"] ? LdapSettingsEditDto.fromJS(data["ldap"]) : <any>undefined;
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? TenantBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
            this.inventory = data["inventory"] ? InventorySettingsEditDto.fromJS(data["inventory"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["inventory"] = this.inventory ? this.inventory.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TenantSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto | undefined;
    userManagement: TenantUserManagementSettingsEditDto;
    email: EmailSettingsEditDto | undefined;
    ldap: LdapSettingsEditDto | undefined;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto | undefined;
    inventory: InventorySettingsEditDto | undefined;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredUserActiveByDefault: boolean | undefined;
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        return data; 
    }

    clone(): TenantUserManagementSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantUserManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredUserActiveByDefault: boolean | undefined;
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled: boolean | undefined;
    isEnabled: boolean | undefined;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isModuleEnabled = data["isModuleEnabled"];
            this.isEnabled = data["isEnabled"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }

    clone(): LdapSettingsEditDto {
        const json = this.toJSON();
        let result = new LdapSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean | undefined;
    isEnabled: boolean | undefined;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }

    clone(): TenantBillingSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantBillingSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class InventorySettingsEditDto implements IInventorySettingsEditDto {
    isAutoInventoryOutOrInStorage: boolean | undefined;
    isBarcodePrintContainBatchNoExpireDate: boolean | undefined;
    barcodePrintSerialNumberCount: number | undefined;
    isSyncMaterialOutStorage: boolean | undefined;
    isSyncMaterialPurchase: boolean | undefined;
    isEnableBarcode: boolean | undefined;
    isAutoStorageAlertScanModal: boolean | undefined;
    isAutoOutStorageAlertScanModal: boolean | undefined;
    initBarcodeSerialNumber: number | undefined;

    constructor(data?: IInventorySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isAutoInventoryOutOrInStorage = data["isAutoInventoryOutOrInStorage"];
            this.isBarcodePrintContainBatchNoExpireDate = data["isBarcodePrintContainBatchNoExpireDate"];
            this.barcodePrintSerialNumberCount = data["barcodePrintSerialNumberCount"];
            this.isSyncMaterialOutStorage = data["isSyncMaterialOutStorage"];
            this.isSyncMaterialPurchase = data["isSyncMaterialPurchase"];
            this.isEnableBarcode = data["isEnableBarcode"];
            this.isAutoStorageAlertScanModal = data["isAutoStorageAlertScanModal"];
            this.isAutoOutStorageAlertScanModal = data["isAutoOutStorageAlertScanModal"];
            this.initBarcodeSerialNumber = data["initBarcodeSerialNumber"];
        }
    }

    static fromJS(data: any): InventorySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventorySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAutoInventoryOutOrInStorage"] = this.isAutoInventoryOutOrInStorage;
        data["isBarcodePrintContainBatchNoExpireDate"] = this.isBarcodePrintContainBatchNoExpireDate;
        data["barcodePrintSerialNumberCount"] = this.barcodePrintSerialNumberCount;
        data["isSyncMaterialOutStorage"] = this.isSyncMaterialOutStorage;
        data["isSyncMaterialPurchase"] = this.isSyncMaterialPurchase;
        data["isEnableBarcode"] = this.isEnableBarcode;
        data["isAutoStorageAlertScanModal"] = this.isAutoStorageAlertScanModal;
        data["isAutoOutStorageAlertScanModal"] = this.isAutoOutStorageAlertScanModal;
        data["initBarcodeSerialNumber"] = this.initBarcodeSerialNumber;
        return data; 
    }

    clone(): InventorySettingsEditDto {
        const json = this.toJSON();
        let result = new InventorySettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IInventorySettingsEditDto {
    isAutoInventoryOutOrInStorage: boolean | undefined;
    isBarcodePrintContainBatchNoExpireDate: boolean | undefined;
    barcodePrintSerialNumberCount: number | undefined;
    isSyncMaterialOutStorage: boolean | undefined;
    isSyncMaterialPurchase: boolean | undefined;
    isEnableBarcode: boolean | undefined;
    isAutoStorageAlertScanModal: boolean | undefined;
    isAutoOutStorageAlertScanModal: boolean | undefined;
    initBarcodeSerialNumber: number | undefined;
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfNameValueDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfNameValueDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean | undefined;
    organizationUnitId: number | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.rememberClient = data["rememberClient"];
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean | undefined;
    organizationUnitId: number | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
}

export class UiCustomizationSettingsEditDto implements IUiCustomizationSettingsEditDto {
    layout: UiCustomizationLayoutSettingsEditDto | undefined;
    header: UiCustomizationHeaderSettingsEditDto | undefined;
    menu: UiCustomizationMenuSettingsEditDto | undefined;
    footer: UiCustomizationFooterSettingsEditDto | undefined;

    constructor(data?: IUiCustomizationSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layout = data["layout"] ? UiCustomizationLayoutSettingsEditDto.fromJS(data["layout"]) : <any>undefined;
            this.header = data["header"] ? UiCustomizationHeaderSettingsEditDto.fromJS(data["header"]) : <any>undefined;
            this.menu = data["menu"] ? UiCustomizationMenuSettingsEditDto.fromJS(data["menu"]) : <any>undefined;
            this.footer = data["footer"] ? UiCustomizationFooterSettingsEditDto.fromJS(data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UiCustomizationSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): UiCustomizationSettingsEditDto {
        const json = this.toJSON();
        let result = new UiCustomizationSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUiCustomizationSettingsEditDto {
    layout: UiCustomizationLayoutSettingsEditDto | undefined;
    header: UiCustomizationHeaderSettingsEditDto | undefined;
    menu: UiCustomizationMenuSettingsEditDto | undefined;
    footer: UiCustomizationFooterSettingsEditDto | undefined;
}

export class UiCustomizationLayoutSettingsEditDto implements IUiCustomizationLayoutSettingsEditDto {
    layoutType: string | undefined;
    contentSkin: string | undefined;
    theme: string | undefined;

    constructor(data?: IUiCustomizationLayoutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layoutType = data["layoutType"];
            this.contentSkin = data["contentSkin"];
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): UiCustomizationLayoutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationLayoutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        data["contentSkin"] = this.contentSkin;
        data["theme"] = this.theme;
        return data; 
    }

    clone(): UiCustomizationLayoutSettingsEditDto {
        const json = this.toJSON();
        let result = new UiCustomizationLayoutSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUiCustomizationLayoutSettingsEditDto {
    layoutType: string | undefined;
    contentSkin: string | undefined;
    theme: string | undefined;
}

export class UiCustomizationHeaderSettingsEditDto implements IUiCustomizationHeaderSettingsEditDto {
    desktopFixedHeader: boolean | undefined;
    desktopMinimizeMode: string | undefined;
    mobileFixedHeader: boolean | undefined;
    dropdownSkinDesktop: string | undefined;
    displaySubmenuArrowDesktop: boolean | undefined;
    dropdownSkin: string | undefined;

    constructor(data?: IUiCustomizationHeaderSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.desktopFixedHeader = data["desktopFixedHeader"];
            this.desktopMinimizeMode = data["desktopMinimizeMode"];
            this.mobileFixedHeader = data["mobileFixedHeader"];
            this.dropdownSkinDesktop = data["dropdownSkinDesktop"];
            this.displaySubmenuArrowDesktop = data["displaySubmenuArrowDesktop"];
            this.dropdownSkin = data["dropdownSkin"];
        }
    }

    static fromJS(data: any): UiCustomizationHeaderSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationHeaderSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["desktopMinimizeMode"] = this.desktopMinimizeMode;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["dropdownSkinDesktop"] = this.dropdownSkinDesktop;
        data["displaySubmenuArrowDesktop"] = this.displaySubmenuArrowDesktop;
        data["dropdownSkin"] = this.dropdownSkin;
        return data; 
    }

    clone(): UiCustomizationHeaderSettingsEditDto {
        const json = this.toJSON();
        let result = new UiCustomizationHeaderSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUiCustomizationHeaderSettingsEditDto {
    desktopFixedHeader: boolean | undefined;
    desktopMinimizeMode: string | undefined;
    mobileFixedHeader: boolean | undefined;
    dropdownSkinDesktop: string | undefined;
    displaySubmenuArrowDesktop: boolean | undefined;
    dropdownSkin: string | undefined;
}

export class UiCustomizationMenuSettingsEditDto implements IUiCustomizationMenuSettingsEditDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean | undefined;
    allowAsideMinimizing: boolean | undefined;
    defaultMinimizedAside: boolean | undefined;
    allowAsideHiding: boolean | undefined;
    defaultHiddenAside: boolean | undefined;
    submenuToggle: string | undefined;
    dropdownSubmenuSkin: string | undefined;
    dropdownSubmenuArrow: boolean | undefined;

    constructor(data?: IUiCustomizationMenuSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.position = data["position"];
            this.asideSkin = data["asideSkin"];
            this.fixedAside = data["fixedAside"];
            this.allowAsideMinimizing = data["allowAsideMinimizing"];
            this.defaultMinimizedAside = data["defaultMinimizedAside"];
            this.allowAsideHiding = data["allowAsideHiding"];
            this.defaultHiddenAside = data["defaultHiddenAside"];
            this.submenuToggle = data["submenuToggle"];
            this.dropdownSubmenuSkin = data["dropdownSubmenuSkin"];
            this.dropdownSubmenuArrow = data["dropdownSubmenuArrow"];
        }
    }

    static fromJS(data: any): UiCustomizationMenuSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationMenuSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["allowAsideHiding"] = this.allowAsideHiding;
        data["defaultHiddenAside"] = this.defaultHiddenAside;
        data["submenuToggle"] = this.submenuToggle;
        data["dropdownSubmenuSkin"] = this.dropdownSubmenuSkin;
        data["dropdownSubmenuArrow"] = this.dropdownSubmenuArrow;
        return data; 
    }

    clone(): UiCustomizationMenuSettingsEditDto {
        const json = this.toJSON();
        let result = new UiCustomizationMenuSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUiCustomizationMenuSettingsEditDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean | undefined;
    allowAsideMinimizing: boolean | undefined;
    defaultMinimizedAside: boolean | undefined;
    allowAsideHiding: boolean | undefined;
    defaultHiddenAside: boolean | undefined;
    submenuToggle: string | undefined;
    dropdownSubmenuSkin: string | undefined;
    dropdownSubmenuArrow: boolean | undefined;
}

export class UiCustomizationFooterSettingsEditDto implements IUiCustomizationFooterSettingsEditDto {
    fixedFooter: boolean | undefined;

    constructor(data?: IUiCustomizationFooterSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedFooter = data["fixedFooter"];
        }
    }

    static fromJS(data: any): UiCustomizationFooterSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationFooterSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data; 
    }

    clone(): UiCustomizationFooterSettingsEditDto {
        const json = this.toJSON();
        let result = new UiCustomizationFooterSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUiCustomizationFooterSettingsEditDto {
    fixedFooter: boolean | undefined;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount: number | undefined;
    items: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfUserListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number | undefined;
    items: UserListDto[] | undefined;
}

export class UserListDto implements IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean | undefined;
    roles: UserListRoleDto[] | undefined;
    lastLoginTime: Date | undefined;
    isActive: boolean | undefined;
    organizationUnitName: string | undefined;
    creationTime: Date | undefined;
    id: number | undefined;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.profilePictureId = data["profilePictureId"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserListRoleDto.fromJS(item));
            }
            this.lastLoginTime = data["lastLoginTime"] ? new Date(data["lastLoginTime"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.organizationUnitName = data["organizationUnitName"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["organizationUnitName"] = this.organizationUnitName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserListDto {
        const json = this.toJSON();
        let result = new UserListDto();
        result.init(json);
        return result;
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean | undefined;
    roles: UserListRoleDto[] | undefined;
    lastLoginTime: Date | undefined;
    isActive: boolean | undefined;
    organizationUnitName: string | undefined;
    creationTime: Date | undefined;
    id: number | undefined;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }

    clone(): UserListRoleDto {
        const json = this.toJSON();
        let result = new UserListRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUserListRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetUserForEditOutput {
        const json = this.toJSON();
        let result = new GetUserForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
}

export class UserEditDto implements IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
    organizationUnitId: number | undefined;
    organizationUnitName: string | undefined;
    dockingAccount: string | undefined;
    dockingPassword: string | undefined;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.isActive = data["isActive"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
            this.organizationUnitId = data["organizationUnitId"];
            this.organizationUnitName = data["organizationUnitName"];
            this.dockingAccount = data["dockingAccount"];
            this.dockingPassword = data["dockingPassword"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["organizationUnitId"] = this.organizationUnitId;
        data["organizationUnitName"] = this.organizationUnitName;
        data["dockingAccount"] = this.dockingAccount;
        data["dockingPassword"] = this.dockingPassword;
        return data; 
    }

    clone(): UserEditDto {
        const json = this.toJSON();
        let result = new UserEditDto();
        result.init(json);
        return result;
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
    organizationUnitId: number | undefined;
    organizationUnitName: string | undefined;
    dockingAccount: string | undefined;
    dockingPassword: string | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleDisplayName = data["roleDisplayName"];
            this.isAssigned = data["isAssigned"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        return data; 
    }

    clone(): UserRoleDto {
        const json = this.toJSON();
        let result = new UserRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUserRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetUserPermissionsForEditOutput {
        const json = this.toJSON();
        let result = new GetUserPermissionsForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id: number | undefined;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDtoOfInt64 {
        const json = this.toJSON();
        let result = new EntityDtoOfInt64();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfInt64 {
    id: number | undefined;
}

export class UpdateUserPasswordInput implements IUpdateUserPasswordInput {
    id: number | undefined;
    password: string | undefined;

    constructor(data?: IUpdateUserPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): UpdateUserPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["password"] = this.password;
        return data; 
    }

    clone(): UpdateUserPasswordInput {
        const json = this.toJSON();
        let result = new UpdateUserPasswordInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserPasswordInput {
    id: number | undefined;
    password: string | undefined;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): UpdateUserPermissionsInput {
        const json = this.toJSON();
        let result = new UpdateUserPermissionsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserPermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean | undefined;
    setRandomPassword: boolean | undefined;
    organizationUnitId: number | undefined;
    organizationUnitName: string | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : new UserEditDto();
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [];
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            this.sendActivationEmail = data["sendActivationEmail"];
            this.setRandomPassword = data["setRandomPassword"];
            this.organizationUnitId = data["organizationUnitId"];
            this.organizationUnitName = data["organizationUnitName"];
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        data["organizationUnitId"] = this.organizationUnitId;
        data["organizationUnitName"] = this.organizationUnitName;
        return data; 
    }

    clone(): CreateOrUpdateUserInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateUserInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean | undefined;
    setRandomPassword: boolean | undefined;
    organizationUnitId: number | undefined;
    organizationUnitName: string | undefined;
}

export class UserImportDto implements IUserImportDto {
    rowNumber: number | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    assignedRoleNames: string | undefined;
    organizationUnits: string | undefined;
    dockingAccount: string | undefined;
    dockingPassword: string | undefined;

    constructor(data?: IUserImportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rowNumber = data["rowNumber"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.userName = data["userName"];
            this.password = data["password"];
            this.assignedRoleNames = data["assignedRoleNames"];
            this.organizationUnits = data["organizationUnits"];
            this.dockingAccount = data["dockingAccount"];
            this.dockingPassword = data["dockingPassword"];
        }
    }

    static fromJS(data: any): UserImportDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserImportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowNumber"] = this.rowNumber;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["assignedRoleNames"] = this.assignedRoleNames;
        data["organizationUnits"] = this.organizationUnits;
        data["dockingAccount"] = this.dockingAccount;
        data["dockingPassword"] = this.dockingPassword;
        return data; 
    }

    clone(): UserImportDto {
        const json = this.toJSON();
        let result = new UserImportDto();
        result.init(json);
        return result;
    }
}

export interface IUserImportDto {
    rowNumber: number | undefined;
    name: string | undefined;
    surname: string | undefined;
    emailAddress: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    assignedRoleNames: string | undefined;
    organizationUnits: string | undefined;
    dockingAccount: string | undefined;
    dockingPassword: string | undefined;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.usernameOrEmailAddress = data["usernameOrEmailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }

    clone(): LinkToUserInput {
        const json = this.toJSON();
        let result = new LinkToUserInput();
        result.init(json);
        return result;
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount: number | undefined;
    items: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfLinkedUserDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number | undefined;
    items: LinkedUserDto[] | undefined;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    lastLoginTime: Date | undefined;
    id: number | undefined;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.username = data["username"];
            this.lastLoginTime = data["lastLoginTime"] ? new Date(data["lastLoginTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): LinkedUserDto {
        const json = this.toJSON();
        let result = new LinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    lastLoginTime: Date | undefined;
    id: number | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfLinkedUserDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number | undefined;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): UnlinkUserInput {
        const json = this.toJSON();
        let result = new UnlinkUserInput();
        result.init(json);
        return result;
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfUserLoginAttemptDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: Date | undefined;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userNameOrEmail = data["userNameOrEmail"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): UserLoginAttemptDto {
        const json = this.toJSON();
        let result = new UserLoginAttemptDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: Date | undefined;
}

export class GetVendorForEditOutput implements IGetVendorForEditOutput {
    vendorType: GetVendorForEditOutputVendorType | undefined;
    code: string | undefined;
    name: string | undefined;
    contact: string | undefined;
    telephone: string | undefined;
    remark: string | undefined;
    shortName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetVendorForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vendorType = data["vendorType"];
            this.code = data["code"];
            this.name = data["name"];
            this.contact = data["contact"];
            this.telephone = data["telephone"];
            this.remark = data["remark"];
            this.shortName = data["shortName"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetVendorForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetVendorForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorType"] = this.vendorType;
        data["code"] = this.code;
        data["name"] = this.name;
        data["contact"] = this.contact;
        data["telephone"] = this.telephone;
        data["remark"] = this.remark;
        data["shortName"] = this.shortName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetVendorForEditOutput {
        const json = this.toJSON();
        let result = new GetVendorForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetVendorForEditOutput {
    vendorType: GetVendorForEditOutputVendorType | undefined;
    code: string | undefined;
    name: string | undefined;
    contact: string | undefined;
    telephone: string | undefined;
    remark: string | undefined;
    shortName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class NullableIdDtoOfGuid implements INullableIdDtoOfGuid {
    id: string | undefined;

    constructor(data?: INullableIdDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): NullableIdDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new NullableIdDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): NullableIdDtoOfGuid {
        const json = this.toJSON();
        let result = new NullableIdDtoOfGuid();
        result.init(json);
        return result;
    }
}

export interface INullableIdDtoOfGuid {
    id: string | undefined;
}

export class GetVendorListOutput implements IGetVendorListOutput {
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    vendorType: GetVendorListOutputVendorType | undefined;
    id: string | undefined;

    constructor(data?: IGetVendorListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.shortName = data["shortName"];
            this.vendorType = data["vendorType"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetVendorListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetVendorListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["vendorType"] = this.vendorType;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetVendorListOutput {
        const json = this.toJSON();
        let result = new GetVendorListOutput();
        result.init(json);
        return result;
    }
}

export interface IGetVendorListOutput {
    code: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    vendorType: GetVendorListOutputVendorType | undefined;
    id: string | undefined;
}

export class CreateOrUpdateVendorInput implements ICreateOrUpdateVendorInput {
    vendorType: CreateOrUpdateVendorInputVendorType | undefined;
    code: string | undefined;
    name: string | undefined;
    contact: string | undefined;
    telephone: string | undefined;
    remark: string | undefined;
    shortName: string | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateVendorInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vendorType = data["vendorType"];
            this.code = data["code"];
            this.name = data["name"];
            this.contact = data["contact"];
            this.telephone = data["telephone"];
            this.remark = data["remark"];
            this.shortName = data["shortName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateVendorInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateVendorInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorType"] = this.vendorType;
        data["code"] = this.code;
        data["name"] = this.name;
        data["contact"] = this.contact;
        data["telephone"] = this.telephone;
        data["remark"] = this.remark;
        data["shortName"] = this.shortName;
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateVendorInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateVendorInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateVendorInput {
    vendorType: CreateOrUpdateVendorInputVendorType | undefined;
    code: string | undefined;
    name: string | undefined;
    contact: string | undefined;
    telephone: string | undefined;
    remark: string | undefined;
    shortName: string | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetVendorPaginationOutput implements IPagedResultDtoOfGetVendorPaginationOutput {
    totalCount: number | undefined;
    items: GetVendorPaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetVendorPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetVendorPaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetVendorPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetVendorPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetVendorPaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetVendorPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetVendorPaginationOutput {
    totalCount: number | undefined;
    items: GetVendorPaginationOutput[] | undefined;
}

export class GetVendorPaginationOutput implements IGetVendorPaginationOutput {
    vendorType: GetVendorPaginationOutputVendorType | undefined;
    code: string | undefined;
    name: string | undefined;
    contact: string | undefined;
    telephone: string | undefined;
    remark: string | undefined;
    shortName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetVendorPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vendorType = data["vendorType"];
            this.code = data["code"];
            this.name = data["name"];
            this.contact = data["contact"];
            this.telephone = data["telephone"];
            this.remark = data["remark"];
            this.shortName = data["shortName"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetVendorPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetVendorPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorType"] = this.vendorType;
        data["code"] = this.code;
        data["name"] = this.name;
        data["contact"] = this.contact;
        data["telephone"] = this.telephone;
        data["remark"] = this.remark;
        data["shortName"] = this.shortName;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetVendorPaginationOutput {
        const json = this.toJSON();
        let result = new GetVendorPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetVendorPaginationOutput {
    vendorType: GetVendorPaginationOutputVendorType | undefined;
    code: string | undefined;
    name: string | undefined;
    contact: string | undefined;
    telephone: string | undefined;
    remark: string | undefined;
    shortName: string | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class VendorImportDto implements IVendorImportDto {
    rowNumber: number | undefined;
    vendorType: number | undefined;
    code: string | undefined;
    name: string | undefined;
    contact: string | undefined;
    telephone: string | undefined;
    shortName: string | undefined;

    constructor(data?: IVendorImportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rowNumber = data["rowNumber"];
            this.vendorType = data["vendorType"];
            this.code = data["code"];
            this.name = data["name"];
            this.contact = data["contact"];
            this.telephone = data["telephone"];
            this.shortName = data["shortName"];
        }
    }

    static fromJS(data: any): VendorImportDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorImportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rowNumber"] = this.rowNumber;
        data["vendorType"] = this.vendorType;
        data["code"] = this.code;
        data["name"] = this.name;
        data["contact"] = this.contact;
        data["telephone"] = this.telephone;
        data["shortName"] = this.shortName;
        return data; 
    }

    clone(): VendorImportDto {
        const json = this.toJSON();
        let result = new VendorImportDto();
        result.init(json);
        return result;
    }
}

export interface IVendorImportDto {
    rowNumber: number | undefined;
    vendorType: number | undefined;
    code: string | undefined;
    name: string | undefined;
    contact: string | undefined;
    telephone: string | undefined;
    shortName: string | undefined;
}

export class GetWarehouseInfoForEditOutput implements IGetWarehouseInfoForEditOutput {
    code: string | undefined;
    name: string | undefined;
    warehouseGradeType: GetWarehouseInfoForEditOutputWarehouseGradeType | undefined;
    organizationWarehouseInfos: OrganizationWarehouseInfoDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetWarehouseInfoForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.warehouseGradeType = data["warehouseGradeType"];
            if (data["organizationWarehouseInfos"] && data["organizationWarehouseInfos"].constructor === Array) {
                this.organizationWarehouseInfos = [];
                for (let item of data["organizationWarehouseInfos"])
                    this.organizationWarehouseInfos.push(OrganizationWarehouseInfoDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetWarehouseInfoForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWarehouseInfoForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["warehouseGradeType"] = this.warehouseGradeType;
        if (this.organizationWarehouseInfos && this.organizationWarehouseInfos.constructor === Array) {
            data["organizationWarehouseInfos"] = [];
            for (let item of this.organizationWarehouseInfos)
                data["organizationWarehouseInfos"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetWarehouseInfoForEditOutput {
        const json = this.toJSON();
        let result = new GetWarehouseInfoForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetWarehouseInfoForEditOutput {
    code: string | undefined;
    name: string | undefined;
    warehouseGradeType: GetWarehouseInfoForEditOutputWarehouseGradeType | undefined;
    organizationWarehouseInfos: OrganizationWarehouseInfoDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class OrganizationWarehouseInfoDto implements IOrganizationWarehouseInfoDto {
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    id: string | undefined;

    constructor(data?: IOrganizationWarehouseInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.warehouseInfoId = data["warehouseInfoId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationWarehouseInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationWarehouseInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["warehouseInfoId"] = this.warehouseInfoId;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationWarehouseInfoDto {
        const json = this.toJSON();
        let result = new OrganizationWarehouseInfoDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationWarehouseInfoDto {
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    id: string | undefined;
}

export class CreateOrUpdateWarehouseInfoInput implements ICreateOrUpdateWarehouseInfoInput {
    code: string | undefined;
    name: string | undefined;
    warehouseGradeType: CreateOrUpdateWarehouseInfoInputWarehouseGradeType | undefined;
    organizationWarehouseInfos: OrganizationWarehouseInfoDto[] | undefined;
    id: string | undefined;

    constructor(data?: ICreateOrUpdateWarehouseInfoInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.warehouseGradeType = data["warehouseGradeType"];
            if (data["organizationWarehouseInfos"] && data["organizationWarehouseInfos"].constructor === Array) {
                this.organizationWarehouseInfos = [];
                for (let item of data["organizationWarehouseInfos"])
                    this.organizationWarehouseInfos.push(OrganizationWarehouseInfoDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrUpdateWarehouseInfoInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateWarehouseInfoInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["warehouseGradeType"] = this.warehouseGradeType;
        if (this.organizationWarehouseInfos && this.organizationWarehouseInfos.constructor === Array) {
            data["organizationWarehouseInfos"] = [];
            for (let item of this.organizationWarehouseInfos)
                data["organizationWarehouseInfos"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): CreateOrUpdateWarehouseInfoInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateWarehouseInfoInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateWarehouseInfoInput {
    code: string | undefined;
    name: string | undefined;
    warehouseGradeType: CreateOrUpdateWarehouseInfoInputWarehouseGradeType | undefined;
    organizationWarehouseInfos: OrganizationWarehouseInfoDto[] | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGetWarehouseInfoPaginationOutput implements IPagedResultDtoOfGetWarehouseInfoPaginationOutput {
    totalCount: number | undefined;
    items: GetWarehouseInfoPaginationOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWarehouseInfoPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetWarehouseInfoPaginationOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWarehouseInfoPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWarehouseInfoPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGetWarehouseInfoPaginationOutput {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGetWarehouseInfoPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGetWarehouseInfoPaginationOutput {
    totalCount: number | undefined;
    items: GetWarehouseInfoPaginationOutput[] | undefined;
}

export class GetWarehouseInfoPaginationOutput implements IGetWarehouseInfoPaginationOutput {
    code: string | undefined;
    name: string | undefined;
    warehouseGradeType: GetWarehouseInfoPaginationOutputWarehouseGradeType | undefined;
    organizationWarehouseInfos: OrganizationWarehouseInfoDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IGetWarehouseInfoPaginationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.warehouseGradeType = data["warehouseGradeType"];
            if (data["organizationWarehouseInfos"] && data["organizationWarehouseInfos"].constructor === Array) {
                this.organizationWarehouseInfos = [];
                for (let item of data["organizationWarehouseInfos"])
                    this.organizationWarehouseInfos.push(OrganizationWarehouseInfoDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GetWarehouseInfoPaginationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWarehouseInfoPaginationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["warehouseGradeType"] = this.warehouseGradeType;
        if (this.organizationWarehouseInfos && this.organizationWarehouseInfos.constructor === Array) {
            data["organizationWarehouseInfos"] = [];
            for (let item of this.organizationWarehouseInfos)
                data["organizationWarehouseInfos"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GetWarehouseInfoPaginationOutput {
        const json = this.toJSON();
        let result = new GetWarehouseInfoPaginationOutput();
        result.init(json);
        return result;
    }
}

export interface IGetWarehouseInfoPaginationOutput {
    code: string | undefined;
    name: string | undefined;
    warehouseGradeType: GetWarehouseInfoPaginationOutputWarehouseGradeType | undefined;
    organizationWarehouseInfos: OrganizationWarehouseInfoDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetOrganizationWarehouseInfosDto implements IGetOrganizationWarehouseInfosDto {
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseInfoName: string | undefined;
    isAutoOut: boolean | undefined;
    isAutoIn: boolean | undefined;

    constructor(data?: IGetOrganizationWarehouseInfosDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationId = data["organizationId"];
            this.organizationName = data["organizationName"];
            this.warehouseInfoId = data["warehouseInfoId"];
            this.warehouseInfoName = data["warehouseInfoName"];
            this.isAutoOut = data["isAutoOut"];
            this.isAutoIn = data["isAutoIn"];
        }
    }

    static fromJS(data: any): GetOrganizationWarehouseInfosDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrganizationWarehouseInfosDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["warehouseInfoId"] = this.warehouseInfoId;
        data["warehouseInfoName"] = this.warehouseInfoName;
        data["isAutoOut"] = this.isAutoOut;
        data["isAutoIn"] = this.isAutoIn;
        return data; 
    }

    clone(): GetOrganizationWarehouseInfosDto {
        const json = this.toJSON();
        let result = new GetOrganizationWarehouseInfosDto();
        result.init(json);
        return result;
    }
}

export interface IGetOrganizationWarehouseInfosDto {
    organizationId: number | undefined;
    organizationName: string | undefined;
    warehouseInfoId: string | undefined;
    warehouseInfoName: string | undefined;
    isAutoOut: boolean | undefined;
    isAutoIn: boolean | undefined;
}

export class GetWarningInfoOutput implements IGetWarningInfoOutput {
    purchaseApprovalInfoCount: number | undefined;
    purchaseMaterialUnArrivedCount: number | undefined;
    materialStockAlertCount: number | undefined;
    certificateExpirationCount: number | undefined;
    performanceVerificationCount: number | undefined;
    stockValidityPeriodCount: number | undefined;

    constructor(data?: IGetWarningInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.purchaseApprovalInfoCount = data["purchaseApprovalInfoCount"];
            this.purchaseMaterialUnArrivedCount = data["purchaseMaterialUnArrivedCount"];
            this.materialStockAlertCount = data["materialStockAlertCount"];
            this.certificateExpirationCount = data["certificateExpirationCount"];
            this.performanceVerificationCount = data["performanceVerificationCount"];
            this.stockValidityPeriodCount = data["stockValidityPeriodCount"];
        }
    }

    static fromJS(data: any): GetWarningInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWarningInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseApprovalInfoCount"] = this.purchaseApprovalInfoCount;
        data["purchaseMaterialUnArrivedCount"] = this.purchaseMaterialUnArrivedCount;
        data["materialStockAlertCount"] = this.materialStockAlertCount;
        data["certificateExpirationCount"] = this.certificateExpirationCount;
        data["performanceVerificationCount"] = this.performanceVerificationCount;
        data["stockValidityPeriodCount"] = this.stockValidityPeriodCount;
        return data; 
    }

    clone(): GetWarningInfoOutput {
        const json = this.toJSON();
        let result = new GetWarningInfoOutput();
        result.init(json);
        return result;
    }
}

export interface IGetWarningInfoOutput {
    purchaseApprovalInfoCount: number | undefined;
    purchaseMaterialUnArrivedCount: number | undefined;
    materialStockAlertCount: number | undefined;
    certificateExpirationCount: number | undefined;
    performanceVerificationCount: number | undefined;
    stockValidityPeriodCount: number | undefined;
}

export class PurchaseMaterialUnArrivedDetailOutput implements IPurchaseMaterialUnArrivedDetailOutput {
    details: MaterialPurchaseDetailDto[] | undefined;

    constructor(data?: IPurchaseMaterialUnArrivedDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["details"] && data["details"].constructor === Array) {
                this.details = [];
                for (let item of data["details"])
                    this.details.push(MaterialPurchaseDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PurchaseMaterialUnArrivedDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseMaterialUnArrivedDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.details && this.details.constructor === Array) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PurchaseMaterialUnArrivedDetailOutput {
        const json = this.toJSON();
        let result = new PurchaseMaterialUnArrivedDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IPurchaseMaterialUnArrivedDetailOutput {
    details: MaterialPurchaseDetailDto[] | undefined;
}

export class MaterialStockAlertDetailOutput implements IMaterialStockAlertDetailOutput {
    details: MaterialStockAlertDetailDto[] | undefined;

    constructor(data?: IMaterialStockAlertDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["details"] && data["details"].constructor === Array) {
                this.details = [];
                for (let item of data["details"])
                    this.details.push(MaterialStockAlertDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MaterialStockAlertDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialStockAlertDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.details && this.details.constructor === Array) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MaterialStockAlertDetailOutput {
        const json = this.toJSON();
        let result = new MaterialStockAlertDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IMaterialStockAlertDetailOutput {
    details: MaterialStockAlertDetailDto[] | undefined;
}

export class MaterialStockAlertDetailDto implements IMaterialStockAlertDetailDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    number: number | undefined;
    alertNumber: number | undefined;
    unitName: string | undefined;

    constructor(data?: IMaterialStockAlertDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialId = data["materialId"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.materialName = data["materialName"];
            this.materialShortName = data["materialShortName"];
            this.number = data["number"];
            this.alertNumber = data["alertNumber"];
            this.unitName = data["unitName"];
        }
    }

    static fromJS(data: any): MaterialStockAlertDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialStockAlertDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialId"] = this.materialId;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["materialName"] = this.materialName;
        data["materialShortName"] = this.materialShortName;
        data["number"] = this.number;
        data["alertNumber"] = this.alertNumber;
        data["unitName"] = this.unitName;
        return data; 
    }

    clone(): MaterialStockAlertDetailDto {
        const json = this.toJSON();
        let result = new MaterialStockAlertDetailDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialStockAlertDetailDto {
    materialId: string | undefined;
    hospitalMaterialCode: string | undefined;
    materialName: string | undefined;
    materialShortName: string | undefined;
    number: number | undefined;
    alertNumber: number | undefined;
    unitName: string | undefined;
}

export class CertificateExpirationDetailOutput implements ICertificateExpirationDetailOutput {
    details: MaterialDto[] | undefined;

    constructor(data?: ICertificateExpirationDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["details"] && data["details"].constructor === Array) {
                this.details = [];
                for (let item of data["details"])
                    this.details.push(MaterialDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CertificateExpirationDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateExpirationDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.details && this.details.constructor === Array) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CertificateExpirationDetailOutput {
        const json = this.toJSON();
        let result = new CertificateExpirationDetailOutput();
        result.init(json);
        return result;
    }
}

export interface ICertificateExpirationDetailOutput {
    details: MaterialDto[] | undefined;
}

export class MaterialDto implements IMaterialDto {
    systemMaterialCode: string | undefined;
    hospitalMaterialCode: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    specification: string | undefined;
    storageConditionId: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeId: string | undefined;
    temperatureRangeName: string | undefined;
    materialTypeId: string | undefined;
    materialTypeName: string | undefined;
    brandId: string | undefined;
    brandName: string | undefined;
    price: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    minUnitId: string | undefined;
    minUnitName: string | undefined;
    unitConvertRate: number | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    supplierId: string | undefined;
    supplierName: string | undefined;
    deliveryCompanyId: string | undefined;
    deliveryCompanyName: string | undefined;
    invoicingCompanyId: string | undefined;
    invoicingCompanyName: string | undefined;
    isRegistrationCertificate: boolean | undefined;
    registrationCertificateNo: string | undefined;
    registrationCertificateFilePath: string | undefined;
    expiryDate: Date | undefined;
    outBoxExpiryDate: number | undefined;
    instrumentId: string | undefined;
    instrumentName: string | undefined;
    arrivalDateSetting: string | undefined;
    isDisabled: boolean | undefined;
    disabledDate: Date | undefined;
    disabledReasonId: string | undefined;
    disabledReasonName: string | undefined;
    vendorMaterialCode: string | undefined;
    isStopPurchase: boolean | undefined;
    isAutoGenerateUniqueCode: boolean | undefined;
    isEnableVendorMaterialCode: boolean | undefined;
    isEnableOpenLabel: boolean | undefined;
    isHavePpCertificate: boolean | undefined;
    isPublicReagent: boolean | undefined;
    isCombinationReagent: boolean | undefined;
    combinationReagentProportion: string | undefined;
    isInventoryAlert: boolean | undefined;
    alertMaterialNumber: number | undefined;
    alertMinMaterialNumber: number | undefined;
    isAvailableDayAlert: boolean | undefined;
    alertAvailableDay: number | undefined;
    alertMinAvailableDay: number | undefined;
    isAutoPurchaseCalculate: boolean | undefined;
    monthPurchaseUpperLimit: number | undefined;
    isDefaultPurchaseNumber: boolean | undefined;
    defaultPurchaseNumber: number | undefined;
    unitConvertSetting: string | undefined;
    isPerformanceVerification: boolean | undefined;
    methodologyId: string | undefined;
    methodologyName: string | undefined;
    materialOutInStorages: MaterialOutInStorageDto[] | undefined;
    organizationMaterials: OrganizationMaterialDto[] | undefined;
    performanceVerificationMaterials: PerformanceVerificationMaterialDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;

    constructor(data?: IMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.systemMaterialCode = data["systemMaterialCode"];
            this.hospitalMaterialCode = data["hospitalMaterialCode"];
            this.name = data["name"];
            this.shortName = data["shortName"];
            this.specification = data["specification"];
            this.storageConditionId = data["storageConditionId"];
            this.storageConditionName = data["storageConditionName"];
            this.temperatureRangeId = data["temperatureRangeId"];
            this.temperatureRangeName = data["temperatureRangeName"];
            this.materialTypeId = data["materialTypeId"];
            this.materialTypeName = data["materialTypeName"];
            this.brandId = data["brandId"];
            this.brandName = data["brandName"];
            this.price = data["price"];
            this.unitId = data["unitId"];
            this.unitName = data["unitName"];
            this.minUnitId = data["minUnitId"];
            this.minUnitName = data["minUnitName"];
            this.unitConvertRate = data["unitConvertRate"];
            this.manufacturerId = data["manufacturerId"];
            this.manufacturerName = data["manufacturerName"];
            this.supplierId = data["supplierId"];
            this.supplierName = data["supplierName"];
            this.deliveryCompanyId = data["deliveryCompanyId"];
            this.deliveryCompanyName = data["deliveryCompanyName"];
            this.invoicingCompanyId = data["invoicingCompanyId"];
            this.invoicingCompanyName = data["invoicingCompanyName"];
            this.isRegistrationCertificate = data["isRegistrationCertificate"];
            this.registrationCertificateNo = data["registrationCertificateNo"];
            this.registrationCertificateFilePath = data["registrationCertificateFilePath"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.outBoxExpiryDate = data["outBoxExpiryDate"];
            this.instrumentId = data["instrumentId"];
            this.instrumentName = data["instrumentName"];
            this.arrivalDateSetting = data["arrivalDateSetting"];
            this.isDisabled = data["isDisabled"];
            this.disabledDate = data["disabledDate"] ? new Date(data["disabledDate"].toString()) : <any>undefined;
            this.disabledReasonId = data["disabledReasonId"];
            this.disabledReasonName = data["disabledReasonName"];
            this.vendorMaterialCode = data["vendorMaterialCode"];
            this.isStopPurchase = data["isStopPurchase"];
            this.isAutoGenerateUniqueCode = data["isAutoGenerateUniqueCode"];
            this.isEnableVendorMaterialCode = data["isEnableVendorMaterialCode"];
            this.isEnableOpenLabel = data["isEnableOpenLabel"];
            this.isHavePpCertificate = data["isHavePpCertificate"];
            this.isPublicReagent = data["isPublicReagent"];
            this.isCombinationReagent = data["isCombinationReagent"];
            this.combinationReagentProportion = data["combinationReagentProportion"];
            this.isInventoryAlert = data["isInventoryAlert"];
            this.alertMaterialNumber = data["alertMaterialNumber"];
            this.alertMinMaterialNumber = data["alertMinMaterialNumber"];
            this.isAvailableDayAlert = data["isAvailableDayAlert"];
            this.alertAvailableDay = data["alertAvailableDay"];
            this.alertMinAvailableDay = data["alertMinAvailableDay"];
            this.isAutoPurchaseCalculate = data["isAutoPurchaseCalculate"];
            this.monthPurchaseUpperLimit = data["monthPurchaseUpperLimit"];
            this.isDefaultPurchaseNumber = data["isDefaultPurchaseNumber"];
            this.defaultPurchaseNumber = data["defaultPurchaseNumber"];
            this.unitConvertSetting = data["unitConvertSetting"];
            this.isPerformanceVerification = data["isPerformanceVerification"];
            this.methodologyId = data["methodologyId"];
            this.methodologyName = data["methodologyName"];
            if (data["materialOutInStorages"] && data["materialOutInStorages"].constructor === Array) {
                this.materialOutInStorages = [];
                for (let item of data["materialOutInStorages"])
                    this.materialOutInStorages.push(MaterialOutInStorageDto.fromJS(item));
            }
            if (data["organizationMaterials"] && data["organizationMaterials"].constructor === Array) {
                this.organizationMaterials = [];
                for (let item of data["organizationMaterials"])
                    this.organizationMaterials.push(OrganizationMaterialDto.fromJS(item));
            }
            if (data["performanceVerificationMaterials"] && data["performanceVerificationMaterials"].constructor === Array) {
                this.performanceVerificationMaterials = [];
                for (let item of data["performanceVerificationMaterials"])
                    this.performanceVerificationMaterials.push(PerformanceVerificationMaterialDto.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? new Date(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? new Date(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? new Date(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["systemMaterialCode"] = this.systemMaterialCode;
        data["hospitalMaterialCode"] = this.hospitalMaterialCode;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["specification"] = this.specification;
        data["storageConditionId"] = this.storageConditionId;
        data["storageConditionName"] = this.storageConditionName;
        data["temperatureRangeId"] = this.temperatureRangeId;
        data["temperatureRangeName"] = this.temperatureRangeName;
        data["materialTypeId"] = this.materialTypeId;
        data["materialTypeName"] = this.materialTypeName;
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        data["price"] = this.price;
        data["unitId"] = this.unitId;
        data["unitName"] = this.unitName;
        data["minUnitId"] = this.minUnitId;
        data["minUnitName"] = this.minUnitName;
        data["unitConvertRate"] = this.unitConvertRate;
        data["manufacturerId"] = this.manufacturerId;
        data["manufacturerName"] = this.manufacturerName;
        data["supplierId"] = this.supplierId;
        data["supplierName"] = this.supplierName;
        data["deliveryCompanyId"] = this.deliveryCompanyId;
        data["deliveryCompanyName"] = this.deliveryCompanyName;
        data["invoicingCompanyId"] = this.invoicingCompanyId;
        data["invoicingCompanyName"] = this.invoicingCompanyName;
        data["isRegistrationCertificate"] = this.isRegistrationCertificate;
        data["registrationCertificateNo"] = this.registrationCertificateNo;
        data["registrationCertificateFilePath"] = this.registrationCertificateFilePath;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["outBoxExpiryDate"] = this.outBoxExpiryDate;
        data["instrumentId"] = this.instrumentId;
        data["instrumentName"] = this.instrumentName;
        data["arrivalDateSetting"] = this.arrivalDateSetting;
        data["isDisabled"] = this.isDisabled;
        data["disabledDate"] = this.disabledDate ? this.disabledDate.toISOString() : <any>undefined;
        data["disabledReasonId"] = this.disabledReasonId;
        data["disabledReasonName"] = this.disabledReasonName;
        data["vendorMaterialCode"] = this.vendorMaterialCode;
        data["isStopPurchase"] = this.isStopPurchase;
        data["isAutoGenerateUniqueCode"] = this.isAutoGenerateUniqueCode;
        data["isEnableVendorMaterialCode"] = this.isEnableVendorMaterialCode;
        data["isEnableOpenLabel"] = this.isEnableOpenLabel;
        data["isHavePpCertificate"] = this.isHavePpCertificate;
        data["isPublicReagent"] = this.isPublicReagent;
        data["isCombinationReagent"] = this.isCombinationReagent;
        data["combinationReagentProportion"] = this.combinationReagentProportion;
        data["isInventoryAlert"] = this.isInventoryAlert;
        data["alertMaterialNumber"] = this.alertMaterialNumber;
        data["alertMinMaterialNumber"] = this.alertMinMaterialNumber;
        data["isAvailableDayAlert"] = this.isAvailableDayAlert;
        data["alertAvailableDay"] = this.alertAvailableDay;
        data["alertMinAvailableDay"] = this.alertMinAvailableDay;
        data["isAutoPurchaseCalculate"] = this.isAutoPurchaseCalculate;
        data["monthPurchaseUpperLimit"] = this.monthPurchaseUpperLimit;
        data["isDefaultPurchaseNumber"] = this.isDefaultPurchaseNumber;
        data["defaultPurchaseNumber"] = this.defaultPurchaseNumber;
        data["unitConvertSetting"] = this.unitConvertSetting;
        data["isPerformanceVerification"] = this.isPerformanceVerification;
        data["methodologyId"] = this.methodologyId;
        data["methodologyName"] = this.methodologyName;
        if (this.materialOutInStorages && this.materialOutInStorages.constructor === Array) {
            data["materialOutInStorages"] = [];
            for (let item of this.materialOutInStorages)
                data["materialOutInStorages"].push(item.toJSON());
        }
        if (this.organizationMaterials && this.organizationMaterials.constructor === Array) {
            data["organizationMaterials"] = [];
            for (let item of this.organizationMaterials)
                data["organizationMaterials"].push(item.toJSON());
        }
        if (this.performanceVerificationMaterials && this.performanceVerificationMaterials.constructor === Array) {
            data["performanceVerificationMaterials"] = [];
            for (let item of this.performanceVerificationMaterials)
                data["performanceVerificationMaterials"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MaterialDto {
        const json = this.toJSON();
        let result = new MaterialDto();
        result.init(json);
        return result;
    }
}

export interface IMaterialDto {
    systemMaterialCode: string | undefined;
    hospitalMaterialCode: string | undefined;
    name: string | undefined;
    shortName: string | undefined;
    specification: string | undefined;
    storageConditionId: string | undefined;
    storageConditionName: string | undefined;
    temperatureRangeId: string | undefined;
    temperatureRangeName: string | undefined;
    materialTypeId: string | undefined;
    materialTypeName: string | undefined;
    brandId: string | undefined;
    brandName: string | undefined;
    price: number | undefined;
    unitId: string | undefined;
    unitName: string | undefined;
    minUnitId: string | undefined;
    minUnitName: string | undefined;
    unitConvertRate: number | undefined;
    manufacturerId: string | undefined;
    manufacturerName: string | undefined;
    supplierId: string | undefined;
    supplierName: string | undefined;
    deliveryCompanyId: string | undefined;
    deliveryCompanyName: string | undefined;
    invoicingCompanyId: string | undefined;
    invoicingCompanyName: string | undefined;
    isRegistrationCertificate: boolean | undefined;
    registrationCertificateNo: string | undefined;
    registrationCertificateFilePath: string | undefined;
    expiryDate: Date | undefined;
    outBoxExpiryDate: number | undefined;
    instrumentId: string | undefined;
    instrumentName: string | undefined;
    arrivalDateSetting: string | undefined;
    isDisabled: boolean | undefined;
    disabledDate: Date | undefined;
    disabledReasonId: string | undefined;
    disabledReasonName: string | undefined;
    vendorMaterialCode: string | undefined;
    isStopPurchase: boolean | undefined;
    isAutoGenerateUniqueCode: boolean | undefined;
    isEnableVendorMaterialCode: boolean | undefined;
    isEnableOpenLabel: boolean | undefined;
    isHavePpCertificate: boolean | undefined;
    isPublicReagent: boolean | undefined;
    isCombinationReagent: boolean | undefined;
    combinationReagentProportion: string | undefined;
    isInventoryAlert: boolean | undefined;
    alertMaterialNumber: number | undefined;
    alertMinMaterialNumber: number | undefined;
    isAvailableDayAlert: boolean | undefined;
    alertAvailableDay: number | undefined;
    alertMinAvailableDay: number | undefined;
    isAutoPurchaseCalculate: boolean | undefined;
    monthPurchaseUpperLimit: number | undefined;
    isDefaultPurchaseNumber: boolean | undefined;
    defaultPurchaseNumber: number | undefined;
    unitConvertSetting: string | undefined;
    isPerformanceVerification: boolean | undefined;
    methodologyId: string | undefined;
    methodologyName: string | undefined;
    materialOutInStorages: MaterialOutInStorageDto[] | undefined;
    organizationMaterials: OrganizationMaterialDto[] | undefined;
    performanceVerificationMaterials: PerformanceVerificationMaterialDto[] | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    creationTime: Date | undefined;
    creatorUserId: number | undefined;
    id: string | undefined;
}

export class GetStockValidityPeriodDetailOutput implements IGetStockValidityPeriodDetailOutput {
    details: GetStockValidityPeriodDetailDto[] | undefined;

    constructor(data?: IGetStockValidityPeriodDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["details"] && data["details"].constructor === Array) {
                this.details = [];
                for (let item of data["details"])
                    this.details.push(GetStockValidityPeriodDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetStockValidityPeriodDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetStockValidityPeriodDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.details && this.details.constructor === Array) {
            data["details"] = [];
            for (let item of this.details)
                data["details"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetStockValidityPeriodDetailOutput {
        const json = this.toJSON();
        let result = new GetStockValidityPeriodDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IGetStockValidityPeriodDetailOutput {
    details: GetStockValidityPeriodDetailDto[] | undefined;
}

export class GetStockValidityPeriodDetailDto implements IGetStockValidityPeriodDetailDto {
    materialName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    stockCount: number | undefined;
    minAvailableDay: number | undefined;

    constructor(data?: IGetStockValidityPeriodDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialName = data["materialName"];
            this.batchNo = data["batchNo"];
            this.expiryDate = data["expiryDate"] ? new Date(data["expiryDate"].toString()) : <any>undefined;
            this.stockCount = data["stockCount"];
            this.minAvailableDay = data["minAvailableDay"];
        }
    }

    static fromJS(data: any): GetStockValidityPeriodDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetStockValidityPeriodDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialName"] = this.materialName;
        data["batchNo"] = this.batchNo;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["stockCount"] = this.stockCount;
        data["minAvailableDay"] = this.minAvailableDay;
        return data; 
    }

    clone(): GetStockValidityPeriodDetailDto {
        const json = this.toJSON();
        let result = new GetStockValidityPeriodDetailDto();
        result.init(json);
        return result;
    }
}

export interface IGetStockValidityPeriodDetailDto {
    materialName: string | undefined;
    batchNo: string | undefined;
    expiryDate: Date | undefined;
    stockCount: number | undefined;
    minAvailableDay: number | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["latestWebLogLines"] && data["latestWebLogLines"].constructor === Array) {
                this.latestWebLogLines = [];
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.latestWebLogLines && this.latestWebLogLines.constructor === Array) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }

    clone(): GetLatestWebLogsOutput {
        const json = this.toJSON();
        let result = new GetLatestWebLogsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export enum ScanType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum DictTypes {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _9 = 9, 
    _10 = 10, 
    _11 = 11, 
    _12 = 12, 
    _13 = 13, 
    _14 = 14, 
}

export enum IncomeStatisticsDateInterval {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum IncomeStatisticsDateInterval2 {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum PerformanceVerificationType {
    _1 = 1, 
    _2 = 2, 
}

export enum OutInStorageType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum OutInStorageType2 {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum OutInStorageType3 {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum State {
    _0 = 0, 
    _1 = 1, 
}

export enum SalesSummaryDatePeriod {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum SalesSummaryDatePeriod2 {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum DefaultTimezoneScope {
    _1 = 1, 
    _2 = 2, 
    _4 = 4, 
    _7 = 7, 
}

export enum VendorType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum VendorType2 {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum WarehouseGradeType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum IsTenantAvailableOutputState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum GetApprovalRecordDetailDtoWorkflowType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum GetApprovalRecordDetailDtoApprovalResultState {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum ApprovalActionInputApprovalResultState {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum GetApprovalWorkflowForEditOutputWorkflowType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum CreateOrUpdateApprovalWorkflowInputWorkflowType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum GetApprovalWorkflowPaginationOutputWorkflowType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum EntityChangeListDtoChangeType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum GetBarcodeInfoMaterialPurchaseDtoMaterialPurchaseState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum MaterialPurchaseDetailDtoArrivalState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum ValidateBarcodeInputOutInStorageType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum FriendDtoState {
    _1 = 1, 
    _2 = 2, 
}

export enum ChatMessageDtoSide {
    _1 = 1, 
    _2 = 2, 
}

export enum ChatMessageDtoReadState {
    _1 = 1, 
    _2 = 2, 
}

export enum ChatMessageDtoReceiverReadState {
    _1 = 1, 
    _2 = 2, 
}

export enum GetDataDictionaryForEditOutputDictType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _9 = 9, 
    _10 = 10, 
    _11 = 11, 
    _12 = 12, 
    _13 = 13, 
    _14 = 14, 
}

export enum DataDictionaryDetailDtoChildDictType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _9 = 9, 
    _10 = 10, 
    _11 = 11, 
    _12 = 12, 
    _13 = 13, 
    _14 = 14, 
}

export enum CreateOrUpdateDataDictionaryInputDictType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _9 = 9, 
    _10 = 10, 
    _11 = 11, 
    _12 = 12, 
    _13 = 13, 
    _14 = 14, 
}

export enum CreateOrUpdateDataDictionaryDetailInputChildDictType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _9 = 9, 
    _10 = 10, 
    _11 = 11, 
    _12 = 12, 
    _13 = 13, 
    _14 = 14, 
}

export enum GeDataDictionaryPaginationOutputDictType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _9 = 9, 
    _10 = 10, 
    _11 = 11, 
    _12 = 12, 
    _13 = 13, 
    _14 = 14, 
}

export enum DataDictionaryDtoDictType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _9 = 9, 
    _10 = 10, 
    _11 = 11, 
    _12 = 12, 
    _13 = 13, 
    _14 = 14, 
}

export enum GetInspectionItemForEditOutputPerformanceVerificationType {
    _1 = 1, 
    _2 = 2, 
}

export enum GetInspectionItemForEditOutputCalculationType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum CreateOrUpdateInspectionItemInputPerformanceVerificationType {
    _1 = 1, 
    _2 = 2, 
}

export enum CreateOrUpdateInspectionItemInputCalculationType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum GetInspectionItemPaginationOutputPerformanceVerificationType {
    _1 = 1, 
    _2 = 2, 
}

export enum MaterialOutInStorageDtoWarehouseGradeType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum MaterialOutInStorageDtoOutInStorageType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum PerformanceVerificationMaterialDtoPerformanceVerificationType {
    _1 = 1, 
    _2 = 2, 
}

export enum GetMaterialInventoryForEditOutputInventoryApprovalState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum CreateOrUpdateMaterialInventoryInputInventoryApprovalState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum CreateOrUpdateMaterialInventoryOutputInventoryApprovalState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum GetMaterialInventoryPaginationOutputInventoryApprovalState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum GetInventoryRecordDtoInventoryApprovalState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum GetMaterialOutStorageForEditOutputOutStorageApprovalState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum GetMaterialOutStorageForEditOutputOutStorageType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum CreateOrUpdateMaterialOutStorageInputOutStorageApprovalState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum CreateOrUpdateMaterialOutStorageInputOutStorageType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum MaterialOutStorageOutStorageApprovalState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum MaterialOutStorageOutStorageType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum GetMaterialOutStoragePaginationOutputOutStorageApprovalState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum GetMaterialOutStoragePaginationOutputOutStorageType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum XGetMaterialOutStoragePaginationMaterialOutStorageDtoOutStorageApprovalState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum XGetMaterialOutStoragePaginationMaterialOutStorageDtoOutStorageType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum GetMaterialPurchaseForEditOutputMaterialPurchaseState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum CreateOrUpdateMaterialPurchaseDtoMaterialPurchaseState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum NextHandleUsersDtoApprovalGradeType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum GetMaterialPurchasePaginationOutputMaterialPurchaseState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum WaitingForPurchaseApprovalListOutputMaterialPurchaseState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum WaitingForAcceptanceListOutputArrivalState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum WaitingForAcceptanceMaterialPurchaseDtoMaterialPurchaseState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum GetMaterialRequestForEditOutputRequestPurchaseState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum CreateOrUpdateMaterialRequestDtoRequestPurchaseState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum GetMaterialRequestPaginationOutputRequestPurchaseState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum WaitingForMaterialRequestApprovalListOutputRequestPurchaseState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum WaitingForAcceptanceMaterialRequestDtoRequestPurchaseState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum MaterialStockOutOrStorageInputOutInStorageType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum GetMaterialStorageForEditOutputStorageApprovalState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum GetMaterialStorageForEditOutputStorageType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
}

export enum CreateOrUpdateMaterialStorageInputStorageApprovalState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum CreateOrUpdateMaterialStorageInputStorageType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
}

export enum GetMaterialStoragePaginationOutputStorageApprovalState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum GetMaterialStoragePaginationOutputStorageType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
}

export enum XGetMaterialStoragePaginationMaterialStorageDtoStorageApprovalState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
}

export enum XGetMaterialStoragePaginationMaterialStorageDtoStorageType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
}

export enum UserNotificationState {
    _0 = 0, 
    _1 = 1, 
}

export enum TenantNotificationSeverity {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export class AdditionalData implements IAdditionalData {
    paypal: { [key: string] : string; } | undefined;

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Paypal"]) {
                this.paypal = {};
                for (let key in data["Paypal"]) {
                    if (data["Paypal"].hasOwnProperty(key))
                        this.paypal[key] = data["Paypal"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    data["Paypal"][key] = this.paypal[key];
            }
        }
        return data; 
    }

    clone(): AdditionalData {
        const json = this.toJSON();
        let result = new AdditionalData();
        result.init(json);
        return result;
    }
}

export interface IAdditionalData {
    paypal: { [key: string] : string; } | undefined;
}

export enum CreatePaymentDtoEditionPaymentType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum CreatePaymentDtoPaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export enum CreatePaymentDtoSubscriptionPaymentGatewayType {
    _1 = 1, 
}

export enum ExecutePaymentDtoGateway {
    _1 = 1, 
}

export enum ExecutePaymentDtoEditionPaymentType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum ExecutePaymentDtoPaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export enum InspectionItemDtoPerformanceVerificationType {
    _1 = 1, 
    _2 = 2, 
}

export enum InspectionItemDtoCalculationType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum GetPerformanceVerificationReportForEditOutputQualifiedVerifyType {
    _0 = 0, 
}

export enum PerformanceVerificationReportInspectItemDtoQualifiedVerifyResultType {
    _0 = 0, 
    _1 = 1, 
}

export enum PerformanceVerificationReportTestResultDtoInspectResultType {
    _0 = 0, 
    _1 = 1, 
}

export enum CreateOrUpdatePerformanceVerificationReportInputQualifiedVerifyType {
    _0 = 0, 
}

export enum CreatePerformanceVerificationReportInspectItemDtoQualifiedVerifyResultType {
    _0 = 0, 
    _1 = 1, 
}

export enum CreatePerformanceVerificationReportTestResultDtoInspectResultType {
    _0 = 0, 
    _1 = 1, 
}

export enum GetPerformanceVerificationReportPaginationOutputQualifiedVerifyType {
    _0 = 0, 
}

export enum TenantLoginInfoDtoPaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export enum RegisterTenantInputSubscriptionStartType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum RegisterTenantInputGateway {
    _1 = 1, 
}

export enum GetVendorForEditOutputVendorType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum GetVendorListOutputVendorType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum CreateOrUpdateVendorInputVendorType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum GetVendorPaginationOutputVendorType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum GetWarehouseInfoForEditOutputWarehouseGradeType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum CreateOrUpdateWarehouseInfoInputWarehouseGradeType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum GetWarehouseInfoPaginationOutputWarehouseGradeType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}